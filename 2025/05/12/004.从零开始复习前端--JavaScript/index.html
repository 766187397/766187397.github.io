<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>004.从零开始复习前端--JavaScript - 辰風依恛</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="辰風依恛个人博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    <link rel="shortcut icon" href="https://766187397.github.io/images/f73a765045a245e9b8e594798465112.jpg" type="image/x-icon" />
    <meta name="description" content="004.从零开始复习前端–JavaScript JavaScript内容非常多，但是常用的就是一些字符串和数组的方法已经Dom和BOM的事件 只有多用多看，没有速通的方法  复习时可以选择性的看一些书籍  JavaScript半知半解 JavaScript基础教程 JavaScript权威指南 JavaScript高级程序设计 ES6标准入门 你不知道的JavaScript 等等  常规内容1.">
<meta property="og:type" content="article">
<meta property="og:title" content="004.从零开始复习前端--JavaScript">
<meta property="og:url" content="https://766187397.github.io/2025/05/12/004.%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E4%B9%A0%E5%89%8D%E7%AB%AF--JavaScript/index.html">
<meta property="og:site_name" content="辰風依恛">
<meta property="og:description" content="004.从零开始复习前端–JavaScript JavaScript内容非常多，但是常用的就是一些字符串和数组的方法已经Dom和BOM的事件 只有多用多看，没有速通的方法  复习时可以选择性的看一些书籍  JavaScript半知半解 JavaScript基础教程 JavaScript权威指南 JavaScript高级程序设计 ES6标准入门 你不知道的JavaScript 等等  常规内容1.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://766187397.github.io/images//%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92.jpg">
<meta property="og:image" content="https://766187397.github.io/images//%E6%98%BE%E7%A4%BA%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png">
<meta property="og:image" content="https://766187397.github.io/images//%E5%8E%9F%E5%BD%A2%E9%93%BE.png">
<meta property="og:image" content="https://766187397.github.io/images//%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://766187397.github.io/2025/05/12/004.%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E4%B9%A0%E5%89%8D%E7%AB%AF--JavaScript/%E5%8E%9F%E5%9E%8B.jpg">
<meta property="og:image" content="https://766187397.github.io/images//%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.jpg">
<meta property="og:image" content="https://766187397.github.io/images//%E4%BA%A7%E7%94%9F%E9%97%AD%E5%8C%85.jpg">
<meta property="og:image" content="https://766187397.github.io/images//%E6%B2%A1%E6%9C%89%E4%BA%A7%E7%94%9F%E9%97%AD%E5%8C%85.jpg">
<meta property="og:image" content="https://766187397.github.io/images//%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8.png">
<meta property="og:image" content="https://766187397.github.io/images//%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.jpg">
<meta property="og:image" content="https://766187397.github.io/images//Promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B11.jpg">
<meta property="og:image" content="https://766187397.github.io/images//Promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B12.jpg">
<meta property="og:image" content="https://766187397.github.io/2025/05/12/004.%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E4%B9%A0%E5%89%8D%E7%AB%AF--JavaScript/004.%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E4%B9%A0%E5%89%8D%E7%AB%AF--JavaScript.assets/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="https://766187397.github.io/images//TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E9%80%9A%E4%BF%97%E7%89%88.jpeg">
<meta property="og:image" content="https://766187397.github.io/images//%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B_%E9%80%9A%E4%BF%97%E7%89%88.jpeg">
<meta property="article:published_time" content="2025-05-12T08:31:58.160Z">
<meta property="article:modified_time" content="2025-05-12T09:43:06.297Z">
<meta property="article:author" content="辰風依恛">
<meta property="article:tag" content="辰風依恛个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://766187397.github.io/images//%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92.jpg">
    
<link rel="stylesheet" href="/lib/fancybox/fancybox.css">
<link rel="stylesheet" href="/lib/mdui_043tiny/mdui.css">


    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1760953161761">
    
        <link rel="stylesheet" href="//at.alicdn.com/t/c/font_3274123_epi3bpf4j2f.css">
    
    <link rel="stylesheet" href="/css/style.css?v=1760953161761">

    
        
            <link rel="stylesheet" href="/custom.css?v=1760953161761">
        
    
<meta name="generator" content="Hexo 5.4.2"></head>

<body class="mdui-drawer-body-left">
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(https://766187397.github.io/images/533cc5ef880911ebb6edd017c2d2eca2.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="辰風依恛" class="mdui-btn mdui-btn-icon"><img src="https://766187397.github.io/images/f73a765045a245e9b8e594798465112.jpg" alt="辰風依恛"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="辰風依恛">
            <img src="https://766187397.github.io/images/f73a765045a245e9b8e594798465112.jpg" alt="辰風依恛" alt="辰風依恛">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>34</div>
        <div><span>标签</span>0</div>
        <div><span>分类</span>11</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
        
        <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        
            <form id="search_form">
                <label><input class="st-default-search-input" id="search_value" name="q" type="search" placeholder="搜索" style="
                    font-size: 15px !important;
                    height: 56px !important;
                    background-image: none;
                "></label>
            </form>
         
    </div>
</div>


	<script async src="/js/search.js?v=1760953161761"></script>



    
        
        <div class="nexmoe-widget-wrap">
	<div class="nexmoe-widget nexmoe-social">
		<a
			class="mdui-ripple"
			href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=766187397&website=www.oicqzone.com"
			target="_blank"
			mdui-tooltip="{content: 'QQ'}"
			style="
				color: rgb(249, 174, 8);
				background-color: rgba(249, 174, 8, .1);
			"
		>
			<i
				class="nexmoefont icon-QQ"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://space.bilibili.com/433804329"
			target="_blank"
			mdui-tooltip="{content: '哔哩哔哩'}"
			style="
				color: rgb(231, 106, 141);
				background-color: rgba(231, 106, 141, .1);
			"
		>
			<i
				class="nexmoefont icon-bilibili"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://github.com/766187397/"
			target="_blank"
			mdui-tooltip="{content: 'GitHub'}"
			style="
				color: rgb(25, 23, 23);
				background-color: rgba(25, 23, 23, .1);
			"
		>
			<i
				class="nexmoefont icon-github"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://gitee.com/sk20020228/"
			target="_blank"
			mdui-tooltip="{content: 'Gitee'}"
			style="
				color: rgb(165, 15, 15);
				background-color: rgba(165, 15, 15, .15);
			"
		>
			<i
				class="nexmoefont icon-gitee"
			></i> </a
		>
	</div>
</div>

    
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Go语言/">Go语言</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/NestJS/">NestJS</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/NuxtJS/">NuxtJS</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/TS/">TS</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Vue/">Vue</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/前端/">前端</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/包管理工具/">包管理工具</a>
          <span class="category-list-count">5</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/博客/">博客</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/小程序/">小程序</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/性能优化方案/">性能优化方案</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/知识碎片/">知识碎片</a>
          <span class="category-list-count">7</span>
        </li>

        
      </ul>

    </div>
  </div>


    
        
        
    
        
        <!-- 一言 -->
<div class="nexmoe-widget-wrap">
  <h3 class="nexmoe-widget-title">
    一言
  </h3>
  <div class="nexmoe-widget">
    <ul class="hitokoto-box">
      <li id="hitokoto_text_parent" class="hitokoto-text" hitokotoCategory="">
        <a href="#" id="hitokoto_text">
          
        </a>
        <a href="#" id="hitokoto_error_text" style="display: none;">
          
        </a>
      </li>
    </ul>
  </div>
</div>

<script>
  let hitokotoText = document.getElementById('hitokoto_text')
  let hitokotoErroText = document.getElementById('hitokoto_error_text')
  let hitokotoCategory = document.getElementById('hitokoto_text_parent').getAttribute('hitokotoCategory')
  window.onload = function () {
    let url = 'https://v1.hitokoto.cn'
    if (hitokotoCategory) {
      url += '?c=' + hitokotoCategory
    }
    fetch(url)
      .then(response => response.json())
      .then(data => {
        hitokotoText.innerText = "「 " + data.hitokoto + " 」 from " + data.from
        hitokotoText.href = 'https://hitokoto.cn/?uuid=' + data.uuid
      })
      .catch((reason) => {
        console.error(11, reason)
        hitokotoText.style.display = 'none'
        hitokotoErroText.style.display = 'block'
      })
  }
</script>
    
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a><span class="archive-list-count">34</span></li></ul>
    </div>
  </div>



    
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2025/10/20/%F0%9F%94%A5Knife4j%20vs%20Swagger%EF%BC%9ANode.js%20%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84API%E6%96%87%E6%A1%A3%E9%9D%A9%E5%91%BD%EF%BC%81/">🔥Knife4j vs Swagger：Node.js 开发者的API文档革命！</a>
          </li>
        
          <li>
            <a href="/2025/10/20/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82WebWorker/">一文搞懂WebWorker</a>
          </li>
        
          <li>
            <a href="/2025/10/16/Node.js%20%E5%87%BD%E6%95%B0%E6%89%93%E5%8C%85%E4%B8%BA%20npm%20%E5%8C%85%E7%9A%84%E8%A7%84%E8%8C%83%E6%B5%81%E7%A8%8B/">Node.js 函数打包为 npm 包的规范流程</a>
          </li>
        
          <li>
            <a href="/2025/10/11/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82SSR%E3%80%81SSG%E3%80%81CSR/">一文搞懂SSR、SSG、CSR</a>
          </li>
        
          <li>
            <a href="/2025/10/11/JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">JS性能优化</a>
          </li>
        
      </ul>
    </div>
  </div>

    
        
</aside>
    <div class="nexmoe-copyright">
        &copy; 2025 辰風依恛
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href="https://beian.miit.gov.cn/">鄂ICP备2020018486号</a>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
    
        <div class="nexmoe-post-cover absolute" style="padding-top: NaN%;"> 
            <img src="https://766187397.github.io/images/前端体系.jpg" alt="004.从零开始复习前端--JavaScript" loading="lazy">
            <h1>004.从零开始复习前端--JavaScript</h1>
        </div>
    
    
    <div class="nexmoe-post-meta">
    <div class="nexmoe-rainbow">
        <a class="nexmoefont icon-calendar-fill">2025年05月12日</a>
        
            <a class="nexmoefont icon-appstore-fill -link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
        
        
    </div>
    
    
    
    
    
</div>

    <h1 id="004-从零开始复习前端–JavaScript"><a href="#004-从零开始复习前端–JavaScript" class="headerlink" title="004.从零开始复习前端–JavaScript"></a>004.从零开始复习前端–JavaScript</h1><blockquote>
<p>JavaScript内容非常多，但是常用的就是一些字符串和数组的方法已经Dom和BOM的事件</p>
<p>只有多用多看，没有速通的方法</p>
</blockquote>
<p>复习时可以选择性的看一些书籍</p>
<ul>
<li>JavaScript半知半解</li>
<li>JavaScript基础教程</li>
<li>JavaScript权威指南</li>
<li>JavaScript高级程序设计</li>
<li>ES6标准入门</li>
<li>你不知道的JavaScript</li>
<li>等等</li>
</ul>
<h1 id="常规内容"><a href="#常规内容" class="headerlink" title="常规内容"></a>常规内容</h1><h2 id="1-基础部分"><a href="#1-基础部分" class="headerlink" title="1. 基础部分"></a>1. 基础部分</h2><ol>
<li><p>变量:用来存放数据,保存的数据可以修改</p>
</li>
<li><p>常量:用来存放数据,保存的数据不可修改</p>
</li>
<li><p>变量和常量的本质,无论是变量还是常量,其本身都是数据,也需要在内存中占用内存空间,保存在内存的栈结构分区中</p>
<ol start="4">
<li><p>ECMAScript标准定义了8种数据类型</p>
<pre><code>   1. 7种原始数据类型：String,Numbr,Boolean,Undefined,null,Symbol,BigInt
</code></pre>
<ol start="2">
<li>Object</li>
<li>引用数据类型</li>
</ol>
</li>
<li><p>Object,Function,Array,Date,RegExp</p>
</li>
<li><p>typeof 运算符(判断数据的类型)</p>
<ol>
<li>作用:用来获取当前变量中存储的数据的类型</li>
<li>typeof的返回值有多少个<ul>
<li>String,Number,Boolean,Undefined,Object,Function</li>
<li>特殊的有两个:null和array的结果都是Object</li>
</ul>
</li>
</ol>
</li>
<li><p>instanceOf 运算符(原生JS判断实例的类型)</p>
<ol>
<li>作用:用来判断当前实例对象是不是某种数据类型</li>
</ol>
</li>
<li><p>基本数据类型和引用数据类型在内存中,内存空间是如何存储数据的</p>
<ol>
<li>除 Object 以外的所有类型都是不可变的（值本身无法被改变）,JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。</li>
</ol>
</li>
<li><p>基本数据类型的值在栈空间中存储,如果修改了数据,则是把原来的值直接干掉,重新存放新的值</p>
</li>
<li><p>引用数据类型的对象在堆空间中存储,该空间的地址在栈空间中存储,如果修改栈空间存储的地址,则指向发生变化,也叫引用发生了变化,此时是在堆空间中重新指向了一个新的内存空间(存储了一个新的对象)</p>
</li>
<li><p>基本类型之间的值如何传递? 传递的是数值</p>
</li>
<li><p>引用类型之间的值如何传递? 传递的是引用(地址)</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92.jpg" alt="images/引用类型的传递.png" data-caption="images/引用类型的传递.png" loading="lazy"></p>
</li>
<li><p>内存:用于暂时存放CPU中的运算数据以及与硬盘等外部存储器交换的数据</p>
<ol>
<li>计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来，内存的运行也决定了计算机的稳定运行。</li>
</ol>
</li>
<li><p>内存通电后产生的存储空间(临时的)</p>
</li>
<li><p>产生和死亡:内存条(集成电路板)—&gt;通电—&gt;产生一定的容量存储空间—&gt;存储各种数据—&gt;断电—&gt;内存空间全部消失</p>
</li>
<li><p>内存的空间是临时的,而硬盘的空间是持久的</p>
</li>
<li><p>内存包含2个数据:内存存储的数据(一般数据/地址数据)和内存地址值数据</p>
</li>
<li><p>内存分类:</p>
</li>
</ol>
<pre><code> - 栈结构: 全局变量，局部变量(空间较小)
 - 堆结构(列表结构): 对象 (空间较大) 
</code></pre>
</li>
</ol>
<h2 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h2><ol>
<li><p>具有一定的属性或者方法,特指的某个事物</p>
</li>
<li><p>看得见或者是摸得到,特指的某个东西</p>
</li>
<li><p>识别对象,抽象出对象有什么特征和行为</p>
</li>
<li><p>抽象出当前的对象属于什么类别</p>
</li>
<li><p>以上都是抽象出对象和类别的过程,抽象性</p>
</li>
<li><p>抽象的过程要转变成代码的方式,写代码:先有类别(构造函数),创建对象并设置对象的属性及方法的初始值,对象的初始化过程,最终对象调用相关方法,操作相关属性及某些行为</p>
</li>
<li><p>特征就是属性,行为就是方法,类别就是构造函数,创建对象就是实例化的过程(初始化属性及方法的中)</p>
</li>
<li><p>工厂模式:自定义函数实现对象的创建</p>
</li>
<li><p>通过构造函数实现对象的创建</p>
</li>
<li><p>字面量的方式创建对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.通过字面量创建对象</span></span><br><span class="line"><span class="keyword">var</span> obj =&#123;&#125;</span><br><span class="line"><span class="comment">// 2.通过工厂模式创建对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">  obj.<span class="property">name</span> = name</span><br><span class="line">  obj.<span class="property">age</span> = age</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 =<span class="title function_">createObject</span>(<span class="string">&#x27;小明&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> obj2 =<span class="title function_">createObject</span>(<span class="string">&#x27;小红&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1,obj2)</span><br><span class="line"><span class="comment">// 3.构造函数的方式创建对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,gender</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHi</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;您好,我是:&#x27;</span>+<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">per.<span class="title function_">sayHi</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per)</span><br></pre></td></tr></table></figure></li>
<li><p>通过ES6中的class来创建</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name,age,gender</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> =age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在原型上</span></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`您好,我是<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,几年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁了,是<span class="subst">$&#123;<span class="variable language_">this</span>.gender&#125;</span>生`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在实例上</span></span><br><span class="line">  eat=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;吃东西啊&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单例模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">      instance.<span class="property">name</span> =name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getObj = <span class="title function_">createObj</span>()</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="title function_">getObj</span>(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title function_">getObj</span>(<span class="string">&#x27;小红&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1,obj2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1===obj2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 对象.属性名字</span><br><span class="line">2. 对象[&#x27;属性名字&#x27;]</span><br><span class="line">3. 什么时候使用对象[属性名字]的写法</span><br><span class="line">   - 不确定属性名字是什么(属性名字是变量)</span><br><span class="line">   - 属性名字不太规范的时候</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js是弱类型语言,声明变量都用var</span><br><span class="line">js是脚本语言 直接执行</span><br><span class="line">js是解释性语言 直接解释</span><br><span class="line">js是动态类型语言 变量在执行的时候才知道具体的类型,对象没有这个属性,点了,就有了</span><br><span class="line">js是单线程语言 执行的时候安装一定的顺序,之前的代码执行完毕后,后面才执行</span><br><span class="line">js是基于对象的语言,最终所有的对象都指向了object</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-原型"><a href="#3-原型" class="headerlink" title="3. 原型"></a>3. 原型</h2><ol>
<li><p>原型就是对象,JS中原型一共有两个,一个是prototype，一个是**<code>__proto__</code>属性**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   - prototype: 浏览器的标准属性,程序员使用的,显示原型,存在于函数中</span><br><span class="line">   - __proto__: 浏览器的非标准属性,浏览器使用的,隐式原型,存在于实例对象中</span><br><span class="line">   - 函数中有prototype,实例对象中有__proto__</span><br><span class="line">   - 实例对象也是对象,里面就有__proto__</span><br><span class="line">   - 实例的__proto__与对应函数的prototype都指向原型对象</span><br><span class="line">   - 无论是构造函数还是普通函数,或者是方法,只要是函数,内部就有prototype</span><br><span class="line">2. 原型的作用之一:共享数据,节省内存空间</span><br><span class="line">    1.实例对象一般都是通过构造函数进行创建的,实例化对象的时候做的四件事:</span><br><span class="line">    	- var per = new Person(&#x27;卡卡西&#x27;,20)</span><br><span class="line">        1) 申请一块空闲的空间,用来存储当前的实例对象</span><br><span class="line">        2) 设置this为当前的实例对象(修改this的指向)</span><br><span class="line">        3) 初始化实例对象中的属性和方法的值</span><br><span class="line">        4) 把this作为当前对象进行返回</span><br><span class="line">  	2. 在构造函数中定义的属性及方法,仅仅是编写代码进行定义而已,而实际上里面定义的属性及方法是属于每个实例对象的,所以,创建多个对象,就会开辟多个空间,每个空间中的每个对象都有自己的属性及方法,大量创建对象,对象的方法都不是同一个方法(方法也是函数,函数代码也占用空间),为了节省内存空间,那么可以使用原型的方式,实现数据共享,节省内存空间</span><br><span class="line">	3. 原型的作用之二:实现JS中的继承</span><br><span class="line">          1). 通过改变原型指向实现继承</span><br><span class="line">          2). 借用构造函数显示继承</span><br><span class="line">          3). 组合继承</span><br><span class="line">          4). 拷贝继承:浅拷贝和深拷贝(递归后再说)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>原型对象上有一个<code>constructor</code>属性指向对应的构造函数</p>
<p>function Fn () {}</p>
<p>const fn = new Fn()</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//%E6%98%BE%E7%A4%BA%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt="显示原型与隐式原型" data-caption="显示原型与隐式原型" loading="lazy"></p>
</li>
<li><p>: 区别<strong>执行函数定义</strong>与<strong>执行函数</strong></p>
<ul>
<li><p>执行函数定义: 也就是去创建函数对象, 只是有可能被JS引擎提升预处理执行</p>
</li>
<li><p>执行函数: 执行函数体中所有语句</p>
</li>
<li><p>先有函数定义的执行,才有执行函数</p>
</li>
<li><p>常见的回调</p>
<ul>
<li>DOM事件的回调</li>
<li>定时器中的回调</li>
<li>ajax回调函数(后面讲)</li>
<li>生命周期的回调(后面讲)</li>
</ul>
<ol start="2">
<li>立即执行函数(Immediately-Invokey Function Expression) 匿名函数自调用</li>
</ol>
<ul>
<li>作用:隐藏内部实现,减少命名空间的污染</li>
</ul>
</li>
</ul>
</li>
<li><p>说说函数对象上的<strong>prototype属性</strong>?(prototype什么时候出现,执行函数定义的时候)</p>
<ul>
<li><p>执行函数定义定义(有可能被提升执行)创建函数对象</p>
</li>
<li><p>给函数对象添加prototype属性, 属性值为空的Object实例对象, 也就是原型对象</p>
</li>
<li><p>给原型对象添加constructor属性, 值为函数</p>
</li>
<li><p>伪代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给函数对象添加prototype属性, 属性值为空的Object实例对象, 也就是原型对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="title class_">Fn</span>)</span><br><span class="line"><span class="keyword">var</span> obj =&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>===<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>===<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;&#125;  <span class="comment">// this就是函数对象</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Fn</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>说说实例对象上的**<code>__proto__</code>属性**?(_<em>proto</em>-什么时候出现,实例化对象的时候)</p>
<p>​    JS引擎在创建实例对象时内部自动执行时, 会自动给实例对象添加<code>__proto__</code>属性, 值为构造函数的 prototype属性的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">__proto__</span> = <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>  <span class="comment">// this是实例对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>原型链(实际上是隐式原型链,言外之意就是和显示原型没毛关系,显示原型产生实例的一瞬间起的作用)</p>
<ul>
<li><p>从对象的<code>__proto__</code>开始, 连接的所有对象, 就是我们常说的原型链, 也可称为<code>隐式原型链</code></p>
</li>
<li><p>查找对象属性简单说: 先在自身上查找, 找不到就沿着原型链查找,如果还找不到返回undefined</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//%E5%8E%9F%E5%BD%A2%E9%93%BE.png" alt="image-20201113231139677" data-caption="image-20201113231139677" loading="lazy"></p>
</li>
</ul>
</li>
<li><p>查找对象上属性的基本流程</p>
<ol>
<li><p>先在对象自身上查找, 如果有, 直接返回</p>
</li>
<li><p>如果没有, 根据<code>__proto__</code>在原型对象上查找, 如果有, 直接返回</p>
</li>
<li><p>如果没有根据原型对象的<code>__proto__</code>在原型对象的原型对象上查找, 一直查找到Object原型对象为止</p>
</li>
<li><p>如果找到了返回, 如果查找不到由于它的<code>__proto__</code>为null, 只能返回undefined</p>
</li>
<li><p>查找对象属性时候,会不会读函数的prototype?(会还是不会)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的原型链</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F1</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable constant_">F1</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">number</span> =<span class="number">100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F2</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable constant_">F2</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title function_">F1</span>()</span><br><span class="line"><span class="variable constant_">F2</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">number</span> =<span class="number">200</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F3</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable constant_">F3</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title function_">F2</span>()</span><br><span class="line"><span class="variable constant_">F3</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">number</span> =<span class="number">300</span></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="title function_">F3</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f3.<span class="property">number</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(f3)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>表达式a.b的解析流程</p>
<ul>
<li>查看a变量: 作用域链查看<ul>
<li>不存在 ==&gt; 报错</li>
<li>存在, 得到它的值<ul>
<li>基本类型(var a=null/a=undefined,此时a.b报错)<ul>
<li>null/undefined  ===&gt; 报错</li>
<li>number/string/boolean  ==&gt; 创建一个包含此值的包装类型对象, 进入下面流程</li>
</ul>
</li>
<li>地址值   ===&gt; 解析.b  ===&gt; 查找b属性<ul>
<li>先在自身找, 找到了返回, 如果没有找到</li>
<li>原型链查找<ul>
<li>找到了返回</li>
<li>没找到, 返回undefined</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>instanceOf</p>
<ul>
<li><p>作用: 判断一个任意类型对象的具体类型</p>
</li>
<li><p>如何判断?</p>
<ul>
<li>对于 A instanceof B</li>
<li>A是实例对象, B是构造函数</li>
<li>如果B的prototype属性所指向的原型对象是A实例对象的原型链接上的某个对象, 返回true, 否则返回false</li>
</ul>
</li>
</ul>
</li>
<li><p>原型与原型链结构图</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">const</span> f2 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> o1 = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;</span><br><span class="line"><span class="comment">// 下面的结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Foo</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1 <span class="keyword">instanceof</span> <span class="title class_">Function</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>)</span><br></pre></td></tr></table></figure>

<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="原型与原型链结构图" data-caption="原型与原型链结构图" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 对象中有__proto__,函数中有prototype</span><br><span class="line">  - 实例对象中__proto__指向的是当前实例对象对应的构造函数中的prototype</span><br><span class="line">  - 而每个prototype都是一个对象,所以,内部必然有__proto__，普通函数中的prototype的__proto__指向的是Object的prototype</span><br><span class="line">  - 每个函数是Function的实例对象,所以,只要是函数,那么函数对象中__proto__指向的都是Function的prototype,那么这个prototype中的__proto__指向的仍然是Object的prototype</span><br><span class="line">  - 但是,Object这个构造函数也是函数,所以,Object的__proto__指向的是Function的prototype</span><br><span class="line">  - Function这个构造函数也是对象,所以里面的__proto__指向的是Function的prototype</span><br></pre></td></tr></table></figure>

<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="%E5%8E%9F%E5%9E%8B.jpg" alt="img" data-caption="img" loading="lazy"></p>
</li>
<li><p>继承(改变原型指向/借用构造函数/组合/拷贝)</p>
<ul>
<li><em><strong>方式一: 基于构造函数的继承: 原型链 + 借用构造函数的组合式继承</strong></em><ul>
<li><em><strong>借用父类型构造函数: Person.call(this, name, age)</strong></em></li>
<li><em><strong>让子类的原型为父类的实例: Student.prototype = new Person()</strong></em></li>
<li><em><strong>让子类型原型的构造器为子类型: Student.prototype.constructor = Student</strong></em></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过原型实现继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age,gender</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> =age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;您好&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;好吃&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name,age,gender,score</span>)&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数实现属性的继承</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name,age,gender)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">score</span> = score</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型实现方法的继承</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span></span><br><span class="line"><span class="comment">// 重写方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;学生吃&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">stu.<span class="title function_">sayHi</span>()</span><br><span class="line">stu.<span class="title function_">eat</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu)</span><br></pre></td></tr></table></figure>



<ul>
<li><em><strong>方式二: 基于class/类的继承</strong></em><ul>
<li><em><strong>子类 extends 父类: class Teacher extends Person2</strong></em></li>
<li><em><strong>子类构造器中调用父类的构造: super(name, age)</strong></em></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6的方式实现继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 原型上的方法</span></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;您好&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 赋值的写法就是给实例添加属性或者方法--------</span></span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  sex = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">  <span class="comment">// 实例上的方法 run =function()&#123;&#125;</span></span><br><span class="line">  eat=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;好吃啊&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> gender=<span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小明明&#x27;</span>,<span class="number">30</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="title class_">Person</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name,age,gender</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(name,age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写父类中的方法</span></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我很好&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-预解析"><a href="#4-预解析" class="headerlink" title="4. 预解析"></a>4. 预解析</h2><ol>
<li><p>js引擎在js代码正式执行之前会做一些预解析的操作</p>
</li>
<li><p>先找关键字var,function</p>
</li>
<li><p>找到var以后将var后面的变量提前声明,但是不赋值</p>
</li>
<li><p>找到function以后将function后面的函数提前声明,但是不赋值,也就是说函数在解析之前已经定义完毕了</p>
</li>
<li><p>变量的提升</p>
</li>
</ol>
<pre><code>- 浏览器在解析js代码之前,先把变量的声明提升

6. 函数的提升

- 浏览器在解析js代码之前,先把函数的声明提升

- 函数提升 ==&gt; 变量提升, 同名的变量忽略

  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先提升的谁?</span></span><br><span class="line"><span class="title function_">a</span>()</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure>
</code></pre>
<p>​<br>​    </p>
<pre><code>7. 注意:f2() var f2=function()&#123;&#125;; 报错:因为f2是undefined

8. 预解析:全局预解析和局部预解析
</code></pre>
<h2 id="5-执行上下文"><a href="#5-执行上下文" class="headerlink" title="5. 执行上下文"></a>5. 执行上下文</h2><ol>
<li><p>执行上下文(动态的):就是一个代码的执行环境(全局执行上下文和函数执行上下文,eval函数执行上下文)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 执行上下文概念:代表了代码执行的环境,包含:执行环境,变量对象,<span class="variable language_">this</span>,作用域链</span><br><span class="line"><span class="number">2.</span> 流程:</span><br><span class="line">- js引擎在js代码正式执行前会先创建一个执行环境</span><br><span class="line">- 进入该环境以后会创建一个变量对象,该对象用于收集:变量,函数,函数的参数,<span class="variable language_">this</span></span><br><span class="line">- 找关键字<span class="keyword">var</span>,<span class="keyword">function</span></span><br><span class="line">- 确认<span class="variable language_">this</span></span><br><span class="line">- 创建作用域链</span><br><span class="line"><span class="number">3.</span> 在全局代码执行前,js引擎就会创建一个栈来存储管理所有的执行上下文</span><br><span class="line"><span class="number">4.</span> 在全局执行上下文(<span class="variable language_">window</span>)确定后,将其添加到栈中(压栈)</span><br><span class="line"><span class="number">5.</span> 在函数执行上下文创建后,将其添加到栈中(压栈)</span><br><span class="line"><span class="number">6.</span> 在当前函数执行完毕后,将栈顶的对象移除(出栈)</span><br><span class="line"><span class="number">7.</span> 当所有的代码执行完毕后,栈中只剩下<span class="variable language_">window</span></span><br><span class="line"><span class="number">8.</span> 重点:执行上下文是动态创建的,尤其是针对函数,每调用一次函数都会创建一次执行上下文</span><br></pre></td></tr></table></figure>

<p>总结执行上下文: 当代码要执行,但是没有执行,或者将要执行,在预解析之后,此时出现了全局执行上下文环境(全局执行上下文),创建了一个变量对象,用来收集var , function ,函数参数,确定this的指向,默认全局执行上下文是确定了this是window,这个变量对象会被压入到栈中(全局执行上下文的变量对象在栈中的最下面),如果出现了函数调用,此时出现了局部执行上下文环境(局部执行上下文),再次创建一个变量对象,用来收集函数参数,var ,function,改变this的指向,这个变量对象会被再次压入栈中,在全局执行上下文的变量对象的上面,如果当前函数调用完毕,此时出栈(把局部上下文的变量对象干掉),依次弹出变量对象,就结束了</p>
</li>
</ol>
<h2 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6. 作用域"></a>6. 作用域</h2><ol>
<li><p>概念:变量的使用范围,静态的(编写代码的时候就已经确定了)</p>
</li>
<li><p>全局作用域和局部作用域</p>
</li>
<li><p>全局作用域:函数外部变量的使用范围</p>
</li>
<li><p>局部作用域:函数内变量的使用范围(一个函数就是一个作用域)</p>
</li>
<li><p>块级作用域(ES6新增): const / let</p>
</li>
<li><p>作用:隔离变量,不同的作用域下同名的变量不会冲突</p>
</li>
<li><p>变量分为:全局变量(非函数内部定义的变量)和局部变量(函数内部定义的变量)</p>
</li>
<li><p>多个嵌套的作用域形成的由内向外的结构, 用于查找变量</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.jpg" alt="作用域链" data-caption="作用域链" loading="lazy"></p>
</li>
<li><p>作用域于执行上下文</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 全局作用域之外,每个函数都会创建自己的作用域,作用域在函数定义时已经确定了,而不是函数调用时</span><br><span class="line">2. 全局执行上下文环境在全局作用域确定之后,js代码马上执行之前创建</span><br><span class="line">3. 函数执行上下文环境是在调用函数时,函数体代码执行之前创建</span><br><span class="line">4. 作用域是静态的,只要函数定义好了就一直存在,且不会再变化</span><br><span class="line">5. 执行上下文是动态的,调用函数时创建,函数调用结束时上下文环境就会释放</span><br><span class="line">6. 上下文环境(对象)是从属于所在的作用域</span><br><span class="line">7. 全局上下文环境--&gt;全局作用域</span><br><span class="line">8. 作用域链</span><br><span class="line">  1. 用来决定代码执行的范围,变量的作用范围</span><br><span class="line">  2. 作用域是代码定义的时候决定的</span><br><span class="line">  3. 作用域链是如何产生的</span><br><span class="line">    - 函数在定义的时候自动添加一个属性&#x27;[[Scopes]]&#x27;该属性保存的是其上级作用域链</span><br><span class="line">    - 当函数执行的时候,进入执行上下文环境,将创建的变量对象添加到&#x27;[[Scopes]]&#x27;数组的第一个位置,形成新的数组</span><br><span class="line">  4. 查找变量的规则</span><br><span class="line">    - 先在当前作用域的变量对象中查找,找到则使用</span><br><span class="line">    - 如果没有则沿着作用域链的数组去上级作用域中的变量对象中查找</span><br><span class="line">    - 找到就返回对应的值,如果没有继续向上查找,知道找到最后一个变量对象(全局的变量对象),如果没有则报错</span><br><span class="line">变量的查找:</span><br><span class="line">代码编写的时候确定了当前全局作用域及局部作用域</span><br><span class="line">在代码马上执行,还没执行,执行上下文环境就出现了,函数调用完毕后,局部执行上下文没了,整个代码结束,全局的执行上下文环境也没了</span><br><span class="line">全局作用域----&gt;预解析---&gt;全局执行上下文环境---&gt;全局的变量对象&#123;var ,function ,函数参数,this的指向&#125;-----&gt;函数定义----&gt;局部作用域----&gt;出现了函数调用-----&gt;局部局解析---&gt;局部的执行上下文环境----&gt;局部的变量对象&#123;var ,function ,函数参数,this的指向&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7. 闭包"></a>7. 闭包</h2><pre><code>- 理解:
  - 当嵌套的内部函数引用了外部函数的变量时就产生了闭包(执行外部函数,不一定就会产生闭包)
  - 什么时候产生的闭包?  执行内部函数定义(创建内部函数对象)后
  - 通过chrome工具得知: 闭包本质是内部函数中的一个对象(非js的容器), 这个容器中包含引用的变量

1. 闭包内部包含了被引用变量(函数)的对象
2. 说白了,闭包其实就是一种引用关系,引用关系存在于内部函数中,引用的是外部函数的变量的对象(深入理解)
2. 函数内部本身是个局部作用域,如果出现闭包,延长了局部作用域的生命周期
3. 闭包延长局部变量的生命周期后,如果不及时释放会出现内存泄漏
4. 闭包作用:
  - 闭包的作用:延长外部函数变量对象的生命周期
  - 让函数外部可以操作(读写)函数内部的数据(变量/函数)
5. 闭包什么产生的?
  - 闭包在嵌套内部函数定义执行完成时就产生了(不是调用)
6. 闭包什么时候挂的?
  - 在嵌套的内部函数成为垃圾对象的时候
7. 闭包的优点/缺点及如何清除闭包
  - 优点/缺点: 延长外部函数变量对象的生命周期(不及时清除容易造成内存溢出、泄漏)
  - 释放闭包: 让内部函数对象成为垃圾对象, 断开指向它的所有引用
注意问题:函数中定义函数,内部函数没有调用,则不会出现在局部执行上下文的变量对象中
</code></pre>
<p>​<br>​<br>​    </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时fn2释放了没有呢?</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="comment">// 产生一个闭包</span></span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// 产生一个闭包</span></span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="keyword">var</span> f2 = f</span><br><span class="line">f = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showDedelay</span> (time, msg) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(msg)</span><br><span class="line">    &#125;, time)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showDelay</span>(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>闭包什么时候产生的? 执行函数定义产生引用变量的的时候产生闭包</p>
<p><img src="https://766187397.github.io/images//%E4%BA%A7%E7%94%9F%E9%97%AD%E5%8C%85.jpg"></p>
<p>下面的没有产生闭包(没有产生内部函数引用变量,函数引用变量是执行函数定义才能有该应用变量,fn2就是内部引用变量)</p>
<p><img src="https://766187397.github.io/images//%E6%B2%A1%E6%9C%89%E4%BA%A7%E7%94%9F%E9%97%AD%E5%8C%85.jpg"></p>
<p>闭包的应用: </p>
<ul>
<li><p>举删除删除列表中的的某个商品的例子(带确定框)</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8.png" alt="image-20201114144206567" data-caption="image-20201114144206567" loading="lazy"></p>
</li>
</ul>
<p>内存溢出和内存泄漏</p>
<pre><code>1. 内存泄露 ：是指程序在申请内存后，无法释放已申请的内存空间就造成了内存泄漏，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。

2. 内存溢出： 指程序申请内存时，没有足够的内存供申请者使用，或者说，一个杯子里你非要装一桶的水，那么结果就是内存不够用，即所谓的内存溢出，简单来说就是自己所需要使用的空间比我们拥有的内存大内存不够使用所造成的内存溢出。
</code></pre>
<p>this在不同场景下的取值?</p>
<ul>
<li><p>this学习的2个目标:</p>
<ul>
<li><strong>能判断出函数中的this是谁</strong></li>
<li><strong>能控制函数的this是需要的特定对象</strong></li>
</ul>
</li>
<li><p>常规情况下, 函数中的this取决于执行函数的方式</p>
<ul>
<li>fn(): 直接调用  ==&gt; <strong>this是?</strong>  window</li>
<li>new fn(): new调用 ==&gt; <strong>this是?</strong>  新建的对象</li>
<li>obj.fn(): 通过对象调用 ==&gt; <strong>this是?</strong>  obj        obj.fn()()</li>
<li>fn.call/apply(obj): 通过函数对象的call/apply来调用 ==&gt; <strong>this是?</strong>  obj   (调用fn这个函数,指定或绑定了内部的this为obj)</li>
</ul>
</li>
<li><p>特殊情况:</p>
<ul>
<li>bind(obj)返回的函数  ==&gt; <strong>this是?</strong>  obj</li>
<li>箭头函数 ==&gt; <strong>this是?</strong>  外部作用域的this</li>
<li>回调函数<ul>
<li>定时器/ajax/promise/数组遍历相关方法回调  ==&gt; <strong>this是?</strong>  window(非严格模式,否则都是undefined)</li>
<li>vue控制的回调函数  ==&gt; <strong>this是?</strong>  组件的实例</li>
<li>React控制的生命周期回调, 事件监听回调  ==&gt;  <strong>this是?</strong>  组件对象 / undefined</li>
</ul>
</li>
</ul>
</li>
<li><p>如何控制函数的this?  </p>
<ul>
<li><p>利用函数的bind()</p>
</li>
<li><p>利用箭头函数</p>
</li>
<li><p>也可以用外部保存了this的变量</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> m = <span class="number">1</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">m</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;<span class="attr">m</span>:<span class="number">2</span>&#125;</span><br><span class="line">   f1.<span class="title function_">bind</span>(obj)</span><br><span class="line">   <span class="comment">// 结果?</span></span><br><span class="line">   <span class="title function_">f1</span>()</span><br><span class="line">   <span class="comment">// 结果??</span></span><br><span class="line">   f1.<span class="title function_">bind</span>(obj)()</span><br><span class="line"><span class="comment">// 结果???</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">bind</span>(obj)())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 自己实现bind</span></span><br><span class="line">   <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myBind&#x27;</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">call</span>(obj)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2= &#123;</span><br><span class="line">  <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">f1</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;+++&#x27;</span>,<span class="variable language_">this</span>)  <span class="comment">// 谁?</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">f1</span>()</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----&#x27;</span>,<span class="variable language_">this</span>) <span class="comment">// 谁?</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">f2</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.<span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>



<h2 id="9-同步-异步"><a href="#9-同步-异步" class="headerlink" title="9. 同步/异步"></a>9. 同步/异步</h2><p>进程: 程序的一次执行,它占有一片独有的内存空间</p>
<p>线程: CPU的基本调度单位,是程序执行的一个完整流程</p>
<pre><code>1. 一个进程中一般至少有一个运行的线程:主线程
2. 一个进程中也可以同时运行多个线程,我们会说程序是多线程的
3. 一个进程中的数据可以供其多个线程直接共享
4. 多个进行质检的数据是不能直接共享的
</code></pre>
<p>浏览器运行是单进程还是多进程</p>
<pre><code>1. 有的是单进程的
  - firefox
  - 老版本IE
2. 有的是多进程
  - chrome
  - 新版IE
  - 新版火狐
3. 如何查看浏览器是否是多进程运行的
  - 任务管理器-----&gt;进程
  - 都是多线程运行的
</code></pre>
<p>浏览器内核</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 支持浏览器运行的核心的程序</span><br><span class="line">2. 不同的浏览器内核不太一样</span><br><span class="line">  - IE浏览器内核：Trident内核，也是俗称的IE内核；</span><br><span class="line">  - Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；</span><br><span class="line">  - Firefox浏览器内核：Gecko内核，俗称Firefox内核；</span><br><span class="line">  - Safari浏览器内核：Webkit内核；</span><br><span class="line">  - Opera浏览器内核：最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核；</span><br><span class="line">  - 360浏览器、猎豹浏览器内核：IE+Chrome双内核；</span><br><span class="line">  - 搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；</span><br><span class="line">  - 百度浏览器、世界之窗内核：IE内核；</span><br><span class="line">  - 2345浏览器内核：好像以前是IE内核，现在也是IE+Chrome双内核了；</span><br><span class="line">  - UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident，还有说是基于火狐内核。。</span><br></pre></td></tr></table></figure>

<p>js是单线程的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 如何证明JS执行是单线程的</span><br><span class="line">  - setImteout()的回调函数是在主线程执行的</span><br><span class="line">  - 定时器回调函数只有在运行栈中的代码全部执行完毕后才有可能执行</span><br><span class="line">2. 为什么JS要用单线程模式，而不是多线程模式</span><br><span class="line">  - JS的单线程与它的用途</span><br><span class="line">  - 作为浏览器脚本语言,JS的主要用途是与用户互动,以及操作DOM</span><br><span class="line">  - 这决定了它只能是单线程,否则会带来很复杂的同步问题</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  - 同步会阻塞代码执行</span><br><span class="line">  - 异步不会阻塞代码执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>JS是单线程编程语言, 只能同时做一件事(普通人-&gt;单线程,影分身–&gt;多线程)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步回调</span></span><br><span class="line">   [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;forEach()之后&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// excutor  执行器函数,作用:执行异步代码</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行excutor&#x27;</span>)</span><br><span class="line">     <span class="comment">// 执行异步任务</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Promise()之后&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 异步回调,宏任务</span></span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行timout回调&#x27;</span>)</span><br><span class="line">   &#125;, <span class="number">0</span>);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout()之后&#x27;</span>)</span><br><span class="line"><span class="comment">// 微任务</span></span><br><span class="line">   <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise成功的回调&#x27;</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;.then之后&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>js引擎是在一个线程(可以称为JS线程)上解析执行js代码的(web worker除外), 无论是同步代码还是异步代码</p>
</li>
<li><p>界面第一次渲染: 初始化同步代码 ==&gt; 所有的微任务==&gt; 渲染界面==&gt; 执行第一个宏任务</p>
<p>​                        ==&gt; 所有的微任务==&gt; 渲染界面==&gt; 执行第一个宏任务</p>
<ul>
<li>界面更新渲染: 所有的微任务==&gt; 渲染界面==&gt; 执行第一个宏任务<br>总结: 清空微队列中所有微任务 ==&gt; 渲染界(UI线程) ==&gt; 执行宏队列中的第一个宏任务</li>
</ul>
</li>
<li><p>浏览器在另一个线程(GUI渲染线程)进行页面渲染操作, </p>
</li>
<li><p>GUI渲染线程与js线程是互斥(不会同时执行), 因为 JS 可以修改 DOM 结构</p>
</li>
<li><p>遇到需要等待 (网络请求, 定时任务) 不能卡住，需要异步</p>
</li>
<li><p>回调callback函数</p>
</li>
</ul>
<p>浏览器多线程演示</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">   aaaaaaa</span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微任务</span></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">alert</span>(<span class="string">&#x27;promise1&#x27;</span>) <span class="comment">// 页面渲染了吗?</span></span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br><span class="line"><span class="language-javascript">   <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微任务</span></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">alert</span>(<span class="string">&#x27;promise2&#x27;</span>) <span class="comment">// 页面渲染了吗?</span></span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br><span class="line"><span class="language-javascript">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="comment">// 宏任务</span></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>).<span class="property">innerHTML</span>)  <span class="comment">// 页面渲染了吗?</span></span></span><br><span class="line"><span class="language-javascript">   &#125;, <span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>).<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;<span class="comment">// 宏任务</span></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;xxxx&#x27;</span>  <span class="comment">// dom渲染 </span></span></span><br><span class="line"><span class="language-javascript">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="comment">// 宏任务  </span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>).<span class="property">innerHTML</span>) <span class="comment">// 页面更新渲染了吗?</span></span></span><br><span class="line"><span class="language-javascript">     &#125;, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">     <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微任务 </span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">alert</span>(<span class="string">&#x27;promise3&#x27;</span>) <span class="comment">//页面更新渲染了吗?</span></span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="title function_">alert</span>(<span class="string">&#x27;1111&#x27;</span>) <span class="comment">// 页面渲染了吗?  </span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用Promise解决回调地狱问题(可阅读性很差,仍然要用回调,但是没有嵌套了)</p>
<p>Promise相对纯回调形式, 指定回调函数的时机更灵活(可以在发送请求后或请求结束后)</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.jpg" alt="回调地狱" data-caption="回调地狱" loading="lazy"></p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//Promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B11.jpg" alt="Promise解决回调地狱2" data-caption="Promise解决回调地狱2" loading="lazy"></p>
<p>​                                        <img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//Promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B12.jpg" alt="Promise解决回调地狱2" data-caption="Promise解决回调地狱2" loading="lazy"></p>
<h2 id="10-事件轮询机制event-loop1-异步实现的原理统称-事件循环-轮询机制"><a href="#10-事件轮询机制event-loop1-异步实现的原理统称-事件循环-轮询机制" class="headerlink" title="10. 事件轮询机制event loop1(异步实现的原理统称:事件循环(轮询机制))"></a>10. 事件轮询机制event loop1(异步实现的原理统称:事件循环(轮询机制))</h2><p>​    </p>
<ul>
<li>JS是通过事件循环机制来实现JS的单线程异步</li>
<li>js确实是单线程的,也确实可以异步执行函数,之所以能做到(浏览器中有辅助它单线程异步执行的分线程管理模块)</li>
<li>js是单线程运行的</li>
<li>异步要基于回调来实现</li>
<li>event loop 就是异步回调的实现原理</li>
</ul>
<p>![](004.从零开始复习前端–JavaScript.assets/event loop(只有宏任务).png)</p>
<p>事件循环机制的2个重要部分</p>
<p>​        在分线程执行的管理模块: 定时器/ajax/dom事件</p>
<p>​        保存待执行的回调函数的事件队列(Event queue)/任务队列(Task queue)</p>
<p>事件轮询的执行过程:首先执行初始化代码,就是先执行同步代码,执行同步代码的时候,有可能启动定时器,有可能发送ajax请求,有可能绑定事件监听,执行这些代码的时候,会把回调函数交给对应的管理模块进行管理,而对应的管理模块在分线程执行,不会影响js执行,js会继续向下执行,比如启动一个setTimeout定时器(有个定时器的管理模块),假设1秒后执行,就会在1秒后把回调放在待执行的回调队列里,此时js有可能还在执行初始化代码,只有初始化代码全部的执行完毕后,一个一个,依次的取出执行</p>
<p>宏任务与微任务(任务就是回调,任务的本质就是回调)</p>
<ul>
<li>宏任务: setTimeout, setInterval, Ajax, DOM事件监听</li>
<li>微任务: Promise, async/await, mutationobserver(H5)(用来监视标签的变化的,标签只要有任何的变化,对应的回调就会微任务异步执行)</li>
</ul>
<p>宏队列与微队列(队列本质就是数组)</p>
<ul>
<li>宏队列: 用来保存n个宏任务的队列容器</li>
<li>微队列: 用来保存n个微任务的队列容器</li>
</ul>
<p>event loop2</p>
<ul>
<li>js-web中的dom事件回调, 定时器回调与ajax回调异步执行, 都是基于event loop   ===&gt; 宏任务</li>
<li>H5新的MutationObserver也基于event loop   ==&gt; 微任务</li>
<li>promise成功和失败的回调也是异步执行的, 也是基于event loop  ==&gt; 微任务</li>
<li>执行顺序:<ul>
<li>第一步: 先执行script下的所有同步代码</li>
<li>第二步: 再依次取出微列中的所有微任务执行</li>
<li>第三步: 再取出宏队列中第一个宏任务执行</li>
<li>再循环第二步与第三步</li>
</ul>
</li>
</ul>
<p>![](004.从零开始复习前端–JavaScript.assets/event loop(宏任务与微任务).png)</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="004.%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E4%B9%A0%E5%89%8D%E7%AB%AF--JavaScript.assets/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="宏任务与微任务执行流程图" data-caption="宏任务与微任务执行流程图" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定时器注意:</span><br><span class="line">1. 千万不要在定时器后面放大量的代码块(会阻塞定时器,导致定时器不准确的)</span><br><span class="line">2. 定时器模块何时开始计时:</span><br><span class="line">  - 开定时器的时候交给定时器管理模块就执行</span><br><span class="line"> </span><br><span class="line">H5规范提供了js分线程的实现,取名:Web Workers(了解)</span><br><span class="line">1. Worker:构造函数,加载分线程执行的js文件</span><br><span class="line">2. Worker.prototype.onmessage:用于接收另一个线程的回调函数</span><br><span class="line">3. Worker.prototype.postMessage:向另一个线程发送消息</span><br><span class="line">4. 不足</span><br><span class="line">  - Worker 内代码不能操作DOM(更新UI)</span><br><span class="line">  - 不能跨域加载JS</span><br><span class="line">  - 不是每个浏览器都支持这个新特性</span><br></pre></td></tr></table></figure>





<h2 id="11-Promise"><a href="#11-Promise" class="headerlink" title="11. Promise"></a>11. Promise</h2><ol>
<li><p>ES6推出的新的更好的异步编程解决方案(相对于纯回调的方式)</p>
<ul>
<li>可以异步操作启动后或完成后, 再指定回调函数得到异步结果数据</li>
<li>解决嵌套回调的回调地狱问题  —promise链式调用</li>
</ul>
</li>
<li><p>promise对象有3种状态</p>
<ul>
<li>pending </li>
<li>resolved/fulfilled </li>
<li>rejected</li>
</ul>
</li>
<li><p>promise状态的2种变化</p>
<ul>
<li>pending –&gt; resolved</li>
<li>pending –&gt; rejected</li>
<li>注意:  变化是不可逆</li>
</ul>
<p>4..promise的then()的理解</p>
<ul>
<li><p>then()总是返回一个新的promise</p>
</li>
<li><p>新promise的结果状态由then指定的回调函数执行的结果决定</p>
<ul>
<li>抛出错误</li>
<li>返回失败的promise</li>
<li>返回成功的promise</li>
<li>返回其它任何值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    .then()返回的promise的结果状态由什么决定?</span></span><br><span class="line"><span class="comment">      简单说: 由.then()指定并执行的回调函数的执行结果决定</span></span><br><span class="line"><span class="comment">      详细说: </span></span><br><span class="line"><span class="comment">        什么情况导致promise是失败的?</span></span><br><span class="line"><span class="comment">          执行出错(抛异常了), 失败的reason就是抛出的错误</span></span><br><span class="line"><span class="comment">          返回一个失败的promise, 失败的reason就是返回的promise的reason</span></span><br><span class="line"><span class="comment">        什么情况导致promise是成功的?</span></span><br><span class="line"><span class="comment">          返回一个成功的promise, 成功的value就是返回promise的value</span></span><br><span class="line"><span class="comment">          返回一个非promise任务值, 也可以不返回(返回undefined), 成功的value就是返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 成功</span></span><br><span class="line">      <span class="comment">// resolve(1)</span></span><br><span class="line">      <span class="comment">// 失败</span></span><br><span class="line">      <span class="title function_">reject</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onResolved1&#x27;</span>, value)</span><br><span class="line">      &#125;,   <span class="comment">// onResolved</span></span><br><span class="line">      <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onRejected1&#x27;</span>, reason)</span><br><span class="line">        <span class="comment">// 抛出错误</span></span><br><span class="line">        <span class="comment">// throw 100</span></span><br><span class="line">        <span class="comment">// 返回一个失败的promise</span></span><br><span class="line">        <span class="comment">// return Promise.reject(200)</span></span><br><span class="line">        <span class="comment">// 返回一个成功的promise</span></span><br><span class="line">   <span class="comment">// return Promise.resolve(300)</span></span><br><span class="line">        <span class="comment">// 返回一个其他的值</span></span><br><span class="line">     <span class="comment">// return 1000</span></span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2000</span>)</span><br><span class="line">   &#125;</span><br><span class="line">    ).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onResolved1&#x27;</span>, value)</span><br><span class="line">    &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onRejected2&#x27;</span>, reason)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">   5.Promise.all([promise1, promise2, promise3])</span><br><span class="line">   </span><br><span class="line">   - 批量/一次性发送多个异步请求</span><br><span class="line">   </span><br><span class="line">   - 当都成功时, 返回的promise才成功</span><br><span class="line">   </span><br><span class="line">   - 一旦有一个失败的, 返回的promise就失败了</span><br><span class="line">   </span><br><span class="line">     问题: 发3请求成功后再4个请求</span><br><span class="line">   </span><br><span class="line">   ```js</span><br><span class="line">      function ajax(url) &#123;</span><br><span class="line">         return axios.get(url)</span><br><span class="line">       &#125;</span><br><span class="line">       const p1 = ajax(url1)</span><br><span class="line">       const p2 = ajax(url2)</span><br><span class="line">       const p3 = ajax(url3)</span><br><span class="line">       Promise.all([p1, p2, p3])</span><br><span class="line">// values和数组中数据的顺序有关系</span><br><span class="line">         .then(values =&gt; &#123;</span><br><span class="line">        return ajax(url4)</span><br><span class="line">         &#125;)</span><br><span class="line">      .then(value =&gt; &#123;</span><br><span class="line">           console.log(value) // 就是第4个请求成功的value</span><br><span class="line">      &#125;)</span><br><span class="line">         .catch(error =&gt; &#123;</span><br><span class="line"></span><br><span class="line">         &#125;)</span><br></pre></td></tr></table></figure>



<p>6.async/await与promise的关系</p>
<ul>
<li><p>async/await是消灭异步回调的终极武器</p>
</li>
<li><p>作用: 简化promise对象的使用, 不用再使用then/catch来指定回调函数</p>
</li>
<li><p>但和Promise并不互斥</p>
<ul>
<li><p>反而, 两者相辅相成</p>
</li>
<li><p>执行async函数, 返回promise对象</p>
</li>
<li><p>await相当于promise的then</p>
</li>
<li><p>try…catch可捕获异常, 相当于promise的catch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// function ajax(url) &#123;</span><br><span class="line">   //   return axios.get(url)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">  // async function getProduct() &#123;</span><br><span class="line">  //   try &#123;</span><br><span class="line">  //     const response = await ajax(&#x27;/product2.json&#x27;)</span><br><span class="line">  //     return response.data</span><br><span class="line">  //   &#125; catch (error) &#123;</span><br><span class="line">  //     console.log(&#x27;请求出错&#x27;, error.message)</span><br><span class="line">  //     // throw error</span><br><span class="line">  //     return Promise.reject(error)</span><br><span class="line">  //   &#125;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // // 等同于上面async&amp;await的函数</span><br><span class="line">  // function getProduct() &#123;</span><br><span class="line">  //   return ajax(&#x27;/product.json&#x27;)</span><br><span class="line">  //     .then(response =&gt; &#123;</span><br><span class="line">  //       return response.data</span><br><span class="line">  //     &#125;)</span><br><span class="line">  //     .catch(error =&gt; &#123;</span><br><span class="line">  //       console.log(&#x27;请求出错&#x27;, error.message)</span><br><span class="line">  //       // throw error</span><br><span class="line">  //       return Promise.reject(error)</span><br><span class="line">  //     &#125;)</span><br><span class="line">  // &#125;</span><br><span class="line">     // function test() &#123;</span><br><span class="line">  //   getProduct().then(value =&gt; &#123;</span><br><span class="line">  //     console.log(value)</span><br><span class="line">  //   &#125;).catch(error =&gt; &#123;</span><br><span class="line">  //     console.log(&#x27;error&#x27;, error.message)</span><br><span class="line">  //   &#125;)</span><br><span class="line">  // &#125;</span><br><span class="line">  // test()</span><br></pre></td></tr></table></figure></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<p>##12.ES6</p>
<ol>
<li><p>ECMA组织:欧洲计算机制造商协会,制定和发布的脚本语言规范</p>
</li>
<li><p>ECMAscript是基于Netscape javaScript的一种标准脚本语言。</p>
</li>
<li><p>JavaScript包含3个部分:<br>1)ECMAScript核心(JS标准语法)<br>2)浏览器端的扩展<br>  BOM(浏览器对象模型)<br>  DOM(文档对象模型)<br>3)服务器端的扩展<br>  Node.js</p>
</li>
<li><p>ES的几个重要版本<br>ES5:09年发布<br>ES6:15年发布,也叫ECMA2015<br>ES7:16年发布,也叫ECMA2016</p>
</li>
<li><p>ES5给Object扩展了一些静态方法,常用的2个:</p>
<ol>
<li><p>Object.create(prototype,[descriptors]) 创建对象并继承</p>
<ol>
<li><p>作用: 以指定对象为原型创建新的对象</p>
</li>
<li><p>为新的对象指定新的属性,并对属性进行描述</p>
</li>
<li><p>value: 指定的值</p>
</li>
<li><p>weitable:标识当前属性值是否是可修改的,默认为false</p>
</li>
<li><p>configurable:标识当前属性是否可以被删除,默认是false</p>
</li>
<li><p>enumberable: 标识当前属性是否能用for in 枚举,默认为false</p>
</li>
<li><p>for-in(性能问题)不仅枚举自身属性,也可以枚举原型对象上的属性,一般配合对象.hasOwnProperty()方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line"><span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;您好&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新创建的stu对象和person对象是继承关系</span></span><br><span class="line"><span class="keyword">var</span> stu = <span class="title class_">Object</span>.<span class="title function_">create</span>(person)  <span class="comment">// stu.__proto__----&gt;person</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">name</span>)</span><br><span class="line">stu.<span class="title function_">sayHi</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Objectt.defineProperties(object, descriptors)</p>
<ol>
<li><p>作用:为指定对象定义扩展多个属性</p>
</li>
<li><p>get: 用来获取当前属性值的回调函数</p>
</li>
<li><p>set: 修改当前属性值的触发的回调函数,并且实参为修改后的值</p>
</li>
<li><p>存储器属性: settter,getter一个用来存值,一个用来取值</p>
<ol>
<li>对象本身有两个方法</li>
</ol>
<ul>
<li>get propertyName(){} 用来得到当前属性值的回调函数</li>
<li>set propertyName(){} 用来监视当前属性值变化的回调函</li>
</ul>
</li>
</ol>
</li>
<li><p>Array的方法扩展</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Array.prototype.indexOf(value):得到数组中的某个数据的第一个下标,用来找数据的</span><br><span class="line">2. Array.prototype.lastIndexOf(value):得到数组中某个数据的最后一个小标</span><br><span class="line">3. Array.prototype.forEach(function(item,index)&#123;&#125;):遍历数组</span><br><span class="line">4. Array.prototype.map(function(item,index)&#123;&#125;):遍历数组,返回新数组</span><br><span class="line">5. Array.prototype.filter(function(item,index)&#123;&#125;):遍历数组,过滤后的数组</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>ES6+</p>
</li>
<li><p>箭头函数</p>
<ol>
<li>作用: 定义匿名函数</li>
<li>基本语法: ()=&gt;{console.log(‘xxxx’)}</li>
<li>一个参数: msg=&gt; msg+2</li>
<li>多个参数: (m,n)=&gt;m+n</li>
<li>函数体不用大括号:默认有返回结果</li>
<li>函数体如果有多个语句,需要使用{}包裹,如果内部有需要返回的值,则手动return</li>
<li>使用场景: 多用来定义回调函数</li>
<li>箭头函数的特定:</li>
</ol>
<ul>
<li>简洁</li>
<li>箭头函数没有自己的this,箭头函数的this不是调用的时候决定的,而是在定义的时候处在自己对象就是它的this</li>
<li>扩展理解: 箭头函数的this看外层的是否有函数,如果有,外层函数的this就是内部箭头函数的this,如果没有则this是window</li>
</ul>
</li>
</ol>
<p>7.三点运算符: 拆包和打包</p>
<p>8.形参默认值: 简化函数的形参语法</p>
<p>9.Symbol:</p>
<pre><code>1. ES5中对象的属性名都是字符串,容易造承重名,污染环境
2. 概念:ES6中的添加了一种原始数据类型Symbol(已有的原始数据类型:String,Number,Boolean,null,undefined,对象)
3. 特点:
  - Symbol 属性对应的值是唯一的,解决命名冲突问题
  - Symbol 值不能与其他数据进行计算,包括同字符串拼串
  - for in , for of 遍历时不会遍历symbol 属性 
4. 使用:
  - 调用Symbol 函数得到symbol 值
  - let symbol =Symbol()
  - let obj =&#123;&#125;
  - obj[symbol]=&#39;hello&#39;;
5. 传参标识
  - let symbol = Symbol(&#39;one&#39;)
  - let symbol2 = Symbol(&#39;two&#39;)
  - console.log(symbol) // Symbol(&#39;one&#39;)
  - console.log(symbol2) // Symbol(&#39;two&#39;)
6. 定义常量标识
  - 可以定义常量,就是标识
  - const person_key = Symbol(&#39;person_key&#39;)
  - console.log(person_key)
7. 内置Symbol值
  - 除了定义自己使用的Symbol值以外,ES6还提供了11个内置的Symbol值,指向语言内部使用的方法
  - Symbol.iterator
  - 对象的Symbol.iterator属性,指向该对象的默认遍历器方法(很快就讲了)
</code></pre>
<p>10.iterator 是一种接口机制,为各种不同的数据结构提供统一的访问机制</p>
<pre><code>1. 作用:
  - 为各种数据结构,提供一个统一的，简便的访问接口
  - 使得数据结构的成员能够按某种次序排列
  - ES6创造了一种新的遍历命令,for..of循环,Iterator接口主要提供for...of消费
2. 工作原理
  - 创建一个指针对象(遍历器对象),指向数据结构的起始位置
  - 第一次调用next方法,指针自动指向数据结构的第一个成员
  - 接下来不断调用next方法,指针会一直往后移动,知道指向最后一个成员
  - 每调用next方法返回的是一个包含value和done的对象,&#123;value:当前成员的值,done:布尔值&#125;
  - value表示当前成员的值,done对应的布尔值表示当前的数据的结构是否遍历结束
  - 当遍历结束的时候返回的value值是undefine,done值为false
  - 原生具备iterator接口的数据(可用for of遍历)
  - 扩展理解:
    - 当数据结构上部署了Symbol.iterator接口,该数据可以用for-of遍历
    - 当使用for of去遍历目标数据的时候,该数据会自动去找Symbol.iterator
  - Symbol.iterator属性指向对象的默认遍历器方法(iterator接口)
    - Array
    - arguments
    - set容器
    - map容器
    - String
    ....
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟遍历器对象(指针对象)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myIterator</span>(<span class="params">arr</span>) &#123; <span class="comment">// iterator接口</span></span><br><span class="line">  <span class="keyword">let</span> nextIndex = <span class="number">0</span> <span class="comment">// 默认第一次记录指针的位置</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历器对象</span></span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; arr.<span class="property">length</span> ? &#123;</span><br><span class="line">        <span class="attr">value</span>: arr[nextIndex++],</span><br><span class="line">        <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">      &#125; : &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> interatorObj = <span class="title function_">myIterator</span>(arr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(interatorObj.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(interatorObj.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(interatorObj.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(interatorObj.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(interatorObj.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(interatorObj.<span class="title function_">next</span>())</span><br></pre></td></tr></table></figure>



<p>11.Generator函数</p>
<pre><code>1. 概念:
  - ES6提供的解决异步编程的方案之一
  - Generator函数是一个状态,内部封装了不同状态数据
  - 用来生成遍历对象
  - 可暂停函数(惰性求值),yield可暂停,next方法可启动,每次返回的是yield后的表达式结果
2. 特点:
  - function 与函数名之间有一个星号
  - 内部用yield表达式来定义不同的状态
  - 例如:
    function * generatorExample()&#123;
      let result = yield &#39;hello&#39;; // 状态值为hello
      yield &#39;generator&#39;; // 状态值为generator
    &#125;
  - generator函数返回的是指针对象(接iterator),而不会执行函数内部逻辑
  - 调用next方法函数内部逻辑开始执行,遇到yield表达式停止,返回&#123;value:yield后的表达式结果/undefined,done:true&#125;
  - 再次调用next方法会从上一次停止时的yield处开始,直到最后
  - yield语句返回结果通常为undefine,当调用next方法时传参内容会作为启动时yield语句的返回值
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求,先做第一件事,然后做第二件事,最后最第三件事</span></span><br><span class="line">  <span class="keyword">function</span>* <span class="title function_">generator</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一件是做完了&#x27;</span>)</span><br><span class="line">      iterator.<span class="title function_">next</span>(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">let</span> result=<span class="keyword">yield</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二件是做完了&#x27;</span>)</span><br><span class="line">      iterator.<span class="title function_">next</span>(<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">   <span class="keyword">let</span> result2=<span class="keyword">yield</span>;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三件是做完了&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> iterator = <span class="title function_">generator</span>()</span><br><span class="line">  iterator.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure>



<p>12.async 函数是generator函数的语法糖</p>
<pre><code>1. 概念: 真正意义上去解决异步回调问题,同步流程表达异步操作
2. 本质: Generator的语法糖
3. 语法:
  - async function foo()&#123;
      await 异步操作;
      await 异步操作;
  &#125;
4. 特点:
  - 不需要像Generator去调用next方法,遇到await等待,当恰你的异步操作完成就往下执行
  - 返回的总是Promise对象,可以用then方法进行下一步操作
  - async 取代Generator函数的星号*,await 取代Generator的yield
  - 语义上更为明确,使用简单,经临床验证,暂时没有副作用及不良反应
1. await 是暂停,但是必须跟着promise对象才会暂停,其他的都不暂停
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async 函数</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数开始执行&#x27;</span>)</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">2000</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数执行中&#x27;</span>)</span><br><span class="line">      <span class="keyword">await</span> <span class="number">456</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数执行结束&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">f1</span>()</span><br><span class="line">    <span class="comment">// 只有在await后面有promise才会暂停,如果要继续执行,修改promise对象的状态(暂停到promise对象状态为成功的情况,如果是失败状态,则直接报错)</span></span><br><span class="line">    <span class="comment">// resolve(value) value就会作为await的返回值返回</span></span><br><span class="line">    <span class="comment">// async 函数调用返回的是Promise对象</span></span><br><span class="line">    <span class="comment">// 默认是peding状态</span></span><br><span class="line">    <span class="comment">// 当async 函数所有代码全部执行完毕,并且没有出错,此时就会变成成功状态</span></span><br><span class="line">    <span class="comment">// 当async 函数代码出错了,就会变成失败状态</span></span><br></pre></td></tr></table></figure>



<p>12.字符串扩展</p>
<pre><code>1. includes(str) 判断是否包含指定的字符串
2. startsWith(str) 判断是否以指定字符串开头
3. endsWith(str) 判断是否以指定字符串结尾
4. repeat(count) 重复指定的次数
</code></pre>
<p>13.二进制与八进制数值表示法:二进制用0b,八进制用0o</p>
<pre><code>1. Number.isFinite(i) 判断是否是有限大的数
2. Number.isNaN(i) 判断是否是NaN
3. Number.isInteger(i) 判断是否是整数
4. Number.parseInt(str) 将字符串转换为对应的数值
5. Math.trunc(i) 直接去除小数部分
</code></pre>
<p>14.数组扩展</p>
<pre><code>1. Array.form(伪数组) 伪数组转真数组
2. Array.of(val1,val2,val3)将一些列数值转换为数组
3. find(回调) 找出第一个满足条件的元素
4. findIndex(回调) 找出第一个满足条件的元素的下标
</code></pre>
<p>15.对象扩展</p>
<pre><code>1. Object.is(v1,v2)
2. Object.assign(target,obj1,obj2) 将对象的属性复制到目标对象上
3. 直接操作__proto__属性
  - let obj2=&#123;&#125;
  - obj2.__proto__=obj1
</code></pre>
<p>16.拷贝数据</p>
<pre><code>1. 基本数据类型
  - 拷贝后悔生成一份新的数据,修改拷贝以后的数据不会影响原数据
2. 对象/数组
  - 拷贝后不会生成新的数据,而是拷贝的是引用,修改拷贝以后的数据会影响原来的数据
3. 拷贝数据的方法:
  - 直接赋值给一个变量 浅拷贝
  - Object.assgin() 浅拷贝
  - Array.prototype.concat() 浅拷贝
  - Array.pototype.slice() 浅拷贝
  - JSON.parse(JSON.stringify()) 深拷贝(深度克隆),拷贝的数据里不能有函数,处理不了
4. 浅拷贝(对象/数组)
  - 特点: 拷贝引用,修改拷贝以后的数据会影响原数据
5. 深拷贝(深度克隆)
  - 特点: 拷贝的时候生成新数据,修改拷贝以后的数据不会影响原数据
  - 深度克隆会进行深度的遍历(会用到递归)
  - 需要进行类型的检测 : typeof 返回数据类型:String,Number,Boolean,Undefined,Object,Function
  - Object.prototype.toString.call(obj) 返回的是该对象到底是什么类型
  - console.log(Object.prototype.toString.call(result))
  - 截取获取的真正的数据类型
  - console.log(Object.prototype.toString.call(result).slice(8, -1))
  - for-in循环 对象(属性名) 数组(下标)
</code></pre>
<p>17.Set容器:无序不可重复的多个值的集合体</p>
<pre><code>1. Set()
2. Set(array)
3. add(value)
4. delete(value)
5. has(value)
6. clear()
7. size
</code></pre>
<p>18.Map容器: 无序的key不重复的多个key-value的集合体</p>
<pre><code>1. Map()
2. Map(array)
3. set(key,value) 添加
4. get(key)
5. delete(key)
6. has(key)
7. clear()
8. size
</code></pre>
<p>19.for-of循环可以遍历下面内容:</p>
<pre><code>1. 遍历数组
2. 遍历Set
3. 遍历Map
4. 遍历字符串
5. 遍历伪数组
</code></pre>
<p>20.ES7</p>
<pre><code> Array.prototype.includes() 判断数组中是否包含指定的value
 指数运算符(幂): **
</code></pre>
<p>21.ES8</p>
<pre><code> Object.values(对象) 获取对象中所有的属性的值 
 Object.entries(对象) 把对象转数组
</code></pre>
<p>22.ES9</p>
<pre><code>Promise.finally
  let promise = new Promise((resolve,reject)=&gt;&#123;
      console.log(&#39;开始执行&#39;)
      resolve(&#39;111&#39;)
      console.log(&#39;结束执行&#39;)
  &#125;)

  promise.then((data)=&gt;&#123;
      console.log(&#39;成功:&#39;+data)
    &#125;).catch((errorMsg)=&gt;&#123;
      console.log(&#39;报错啦:&#39;+errorMsg)
    &#125;).finally(()=&gt;&#123;
      console.log(&#39;成功失败都会执行的&#39;)
  &#125;)
</code></pre>
<p>23.总结ES6+面试题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">ES6+常用语法</span><br><span class="line">列出整体ES6+新语法列表</span><br><span class="line">说明: 跟面试官交流ES6, 先快速说出这套列表, 再选择几个常用的/有些难度的/有说头的说, 或者看面试官关注哪方面的</span><br><span class="line">1. const与let</span><br><span class="line">2. 解构赋值</span><br><span class="line">==================</span><br><span class="line">1. 字符串的扩展</span><br><span class="line">2. 数值的扩展</span><br><span class="line">3. 函数的扩展</span><br><span class="line">4. 数组的扩展</span><br><span class="line">5. 对象的扩展</span><br><span class="line">====================</span><br><span class="line">6. 类语法</span><br><span class="line">7. 模块化语法</span><br><span class="line">8. 异步语法</span><br><span class="line">9. 新容器语法</span><br><span class="line">10. 代理(Proxy)与反射(Reflect)语法</span><br><span class="line">===================================</span><br><span class="line">const与let</span><br><span class="line">- const定义常量, let定义变量</span><br><span class="line">- 相对于var</span><br><span class="line">  - 有块作用域</span><br><span class="line">  - 没有变量提升</span><br><span class="line">  - 不会添加到window上</span><br><span class="line">  - 不能重复声明</span><br><span class="line">==============================</span><br><span class="line">解构赋值</span><br><span class="line">- 解构对象: const &#123;id, name&#125; = this.product</span><br><span class="line">- 解构数组: const [count, setCount] = useState() </span><br><span class="line">- 形参解构: add (&#123; id, title &#125;) &#123;&#125;</span><br><span class="line">- 引入模块解构: import &#123; getProductList &#125; from &#x27;@/api&#x27;</span><br><span class="line">===================================</span><br><span class="line">字符串的扩展</span><br><span class="line">- 模板字符串: 我是$&#123;name&#125;, 今年$&#123;age&#125;</span><br><span class="line">- 方法: includes() / startsWith() / endswith()</span><br><span class="line">数值的扩展</span><br><span class="line">- 完善二进制(0b)与八进制(0o)表示</span><br><span class="line">- 给Math添加方法: parseInt()与parseFloat()  (原本window上有)</span><br><span class="line">- 指数计算: **</span><br><span class="line">函数的扩展</span><br><span class="line">- 箭头函数</span><br><span class="line">  - 没有自己的this, 使用外部作用域中的this, 不能通过bind来绑定this</span><br><span class="line">  - 不能通过new来创建实例对象</span><br><span class="line">  - 内部没有arguments, 可以通过rest参数来代替</span><br><span class="line">- 形参默认值: fn (a=2, b=&#123;&#125;) &#123;&#125;</span><br><span class="line">- rest参数: fn (a, ...args) &#123;&#125; / fn (a, ...args) &#123;&#125;      fn(1, 2, 3, 4)</span><br><span class="line">数组的扩展</span><br><span class="line">- 扩展运算符</span><br><span class="line">  - 浅拷贝数组: const arr2 = [...arr]</span><br><span class="line">  - 合并多个数组: const arr3 =  [...arr1, ...arr2]</span><br><span class="line">- 静态方法</span><br><span class="line">  - Array.from():  将类数组对象和可遍历对象转为真数组</span><br><span class="line">    - Array.from(new Set(arr))</span><br><span class="line">    - [...new Set(arr)]</span><br><span class="line">  - Array.of(1, 2, 3): 将一组值，转换为数组</span><br><span class="line">- 实例方法</span><br><span class="line">  - find() / findIndex(): 查找匹配的元素或下标</span><br><span class="line">  - arr.flat(): 将多维数组转为一维数组(也称为: 数组扁平化)</span><br><span class="line">对象的扩展</span><br><span class="line">- 扩展运算符</span><br><span class="line">  - 浅拷贝对象: const obj2 = &#123;...obj1&#125;</span><br><span class="line">  - 合并多个对象: const obj3 =  &#123;...obj1, ...obj2&#125;</span><br><span class="line">- 属性/方法的简洁写法:  &#123;name, getName () &#123;&#125;&#125;</span><br><span class="line">- 遍历内部属性</span><br><span class="line">  - for..of: 遍历对象及其原型链上所有属性</span><br><span class="line">  - Object.keys(obj): 得到对象自身可遍历的所有属性名的数组</span><br><span class="line">- 静态方法:</span><br><span class="line">  - Object.is(value1, value2): 判断2个值是否完全一样</span><br><span class="line">  - Object.assign(target, ...sources): 将后面任意多个对象合并到target对象上 </span><br><span class="line">类语法</span><br><span class="line">- class</span><br><span class="line">- extends</span><br><span class="line">- constructor</span><br><span class="line">- super() / super.xxx()</span><br><span class="line">- static</span><br><span class="line">模块化语法</span><br><span class="line">- export  </span><br><span class="line">- export default  value</span><br><span class="line">- import: 静态导入, 合并一起打包</span><br><span class="line">- import(): 动态导入, 拆分打包, 用于懒加载      const Home = () =&gt; import(&#x27;./views/Home.vue&#x27;)</span><br><span class="line">  import(&#x27;./views/Home.vue&#x27;).then((module) =&gt; &#123;</span><br><span class="line">  	// 使用module块</span><br><span class="line">  	module.default</span><br><span class="line">  	module.xxx</span><br><span class="line">  &#125;)</span><br><span class="line">异步语法</span><br><span class="line">- Promise</span><br><span class="line">- async 函数</span><br><span class="line">- await 表达式</span><br><span class="line">新容器语法</span><br><span class="line">- Map</span><br><span class="line">- Set</span><br><span class="line">代理(Proxy)与反射(Reflect)语法</span><br><span class="line">- Proxy</span><br><span class="line">- Reflect</span><br><span class="line">面试可说的: ES6常用语法</span><br><span class="line">- const与let</span><br><span class="line">- 箭头函数</span><br><span class="line">- 解构赋值</span><br><span class="line">- 形参默认值</span><br><span class="line">- rest/剩余参数</span><br><span class="line">- 类语法: class / extends / constructor / static /super</span><br><span class="line">- 扩展运算符: ...</span><br><span class="line">- 模板字符串</span><br><span class="line">- 异步语法: promise / async &amp; await</span><br><span class="line">- 对象的属性与方法简写</span><br><span class="line">- set / map</span><br><span class="line">- 模块化语法: export / default / import / import()</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="JS其他内容"><a href="#JS其他内容" class="headerlink" title="JS其他内容"></a>JS其他内容</h1><h2 id="事件冒泡与事件委托"><a href="#事件冒泡与事件委托" class="headerlink" title="事件冒泡与事件委托"></a>事件冒泡与事件委托</h2><h3 id="1-事件冒泡的流程"><a href="#1-事件冒泡的流程" class="headerlink" title="1) 事件冒泡的流程"></a>1) 事件冒泡的流程</h3><ul>
<li>基于DOM树形结构</li>
<li>事件在目标元素上处理后, 会由内向外(上)逐层传递</li>
<li>应用场景: 事件代理/委托/委派</li>
</ul>
<h3 id="2-事件委托"><a href="#2-事件委托" class="headerlink" title="2) 事件委托"></a>2) 事件委托</h3><ul>
<li>减少内存占用(事件监听回调从n变为1)</li>
<li>动态添加的内部元素也能响应</li>
<li>不要滥用</li>
</ul>
<h3 id="3-封装一个绑带事件监听的函数-有难度"><a href="#3-封装一个绑带事件监听的函数-有难度" class="headerlink" title="3) 封装一个绑带事件监听的函数(有难度)"></a>3) 封装一个绑带事件监听的函数(有难度)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">绑定事件监听的通用函数(不带委托)</span><br><span class="line">*/</span><br><span class="line">function bindEvent1 (ele, type, fn) &#123;</span><br><span class="line">  ele.addEventListener(type, fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">绑定事件监听的通用函数(带委托)</span><br><span class="line">*/</span><br><span class="line">function bindEvent2(ele, type, fn, selector) &#123;</span><br><span class="line"></span><br><span class="line">  ele.addEventListener(type, event =&gt; &#123;</span><br><span class="line">    // 得到发生事件的目标</span><br><span class="line">    const target = event.target</span><br><span class="line">    if (selector) &#123;</span><br><span class="line">      // 如果元素被指定的选择器字符串选择, 返回true; 否则返回false。</span><br><span class="line">      if (target.matches(selector)) &#123;</span><br><span class="line">        // 委托绑定调用</span><br><span class="line">        fn.call(target, event)</span><br><span class="line">      &#125; </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 普通绑定调用</span><br><span class="line">      fn.call(ele, event)</span><br><span class="line">      // fn(event) // this不对</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;span&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">    </span><br><span class="line">bindEvent2(ul, &#x27;click&#x27;, (event) =&gt; &#123;&#125;, &#x27;li&#x27;)</span><br><span class="line">bindEvent2(ul, &#x27;click&#x27;, (event) =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><h3 id="xhr-status"><a href="#xhr-status" class="headerlink" title="xhr.status"></a>xhr.status</h3><ul>
<li>2XX: 表示成功处理请求, 如200, 201</li>
<li>3XX: 需要生定向, 浏览器直接跳转, 如302</li>
<li>4XX: 客户端请求错误, 如:  401, 404 </li>
<li>5XX: 服务器端错误, 如: 500</li>
</ul>
<h3 id="区别ajax请求与一般HTTP请求"><a href="#区别ajax请求与一般HTTP请求" class="headerlink" title="区别ajax请求与一般HTTP请求"></a>区别ajax请求与一般HTTP请求</h3><ul>
<li>ajax请求是一种特别的http请求</li>
<li>对服务器端来说, 没有任何区别, 区别在浏览器端</li>
<li>浏览器端发请求: 只有XHR或fetch发出的才是ajax请求, 其它所有的都是非ajax请求</li>
<li>浏览器端接收到响应<ul>
<li>一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面</li>
<li>ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据</li>
</ul>
</li>
</ul>
<h3 id="封装一个简易的ajax异步请求函数"><a href="#封装一个简易的ajax异步请求函数" class="headerlink" title="封装一个简易的ajax异步请求函数"></a>封装一个简易的ajax异步请求函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">xhr + promise 封装一个异步ajax请求的通用函数  简洁版</span><br><span class="line">*/</span><br><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 创建一个XHR对象</span><br><span class="line">    const xhr = new XMLHttpRequest()</span><br><span class="line">    // 初始化一个异步请求(还没发请求)</span><br><span class="line">    xhr.open(&#x27;GET&#x27;, url, true)</span><br><span class="line">      </span><br><span class="line">    xhr.onreadystatechange = function () &#123; </span><br><span class="line">        /*</span><br><span class="line">        ajax引擎得到响应数据后</span><br><span class="line">            将xhr的readyState属性指定为4</span><br><span class="line">            将响应数据保存在response / responseText属性上</span><br><span class="line">            调用此回调函数</span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">      // 如果状态值不为4, 直接结束(请求还没有结束)</span><br><span class="line">      if (xhr.readyState !== 4) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      // 如果响应码在200~~299之间, 说明请求都是成功的</span><br><span class="line">      if (xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) &#123;</span><br><span class="line">        // 指定promise成功及结果值</span><br><span class="line">        resolve(JSON.parse(xhr.responseText))</span><br><span class="line">      &#125; else &#123; // 请求失败了</span><br><span class="line">        // 指定promise失败及结果值</span><br><span class="line">        reject(new Error(&#x27;request error staus &#x27;+ request.status))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send(null)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">xhr + promise 封装一个异步ajax请求的通用函数  加强版</span><br><span class="line">  返回值: promise</span><br><span class="line">  参数为配置对象</span><br><span class="line">    url: 请求地址</span><br><span class="line">    params: 包含所有query请求参数的对象</span><br><span class="line">    data: 包含所有请求体参数数据的对象</span><br><span class="line">    method: 为请求方式</span><br><span class="line">*/</span><br><span class="line">function axios(&#123;url, params=&#123;&#125;, data=&#123;&#125;, method=&#x27;GET&#x27;&#125;) &#123;</span><br><span class="line">  // 返回一个promise对象</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 创建一个XHR对象</span><br><span class="line">    const request = new XMLHttpRequest()</span><br><span class="line">    </span><br><span class="line">    // 根据params拼接query参数</span><br><span class="line">    let queryStr = Object.keys(params).reduce((pre, key) =&gt; &#123;</span><br><span class="line">      pre += `&amp;$&#123;key&#125;=$&#123;params[key]&#125;`</span><br><span class="line">      return pre</span><br><span class="line">    &#125;, &#x27;&#x27;)</span><br><span class="line">    if (queryStr.length&gt;0) &#123;</span><br><span class="line">      queryStr = queryStr.substring(1)</span><br><span class="line">      url += &#x27;?&#x27; + queryStr</span><br><span class="line">    &#125;</span><br><span class="line">    // 请求方式转换为大写</span><br><span class="line">    method = method.toUpperCase()</span><br><span class="line">    </span><br><span class="line">    // 初始化一个异步请求(还没发请求)</span><br><span class="line">    request.open(method, url, true)</span><br><span class="line">    // 绑定请求状态改变的监听</span><br><span class="line">    request.onreadystatechange = function () &#123;</span><br><span class="line">      // 如果状态值不为4, 直接结束(请求还没有结束)</span><br><span class="line">      if (request.readyState !== 4) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      // 如果响应码在200~~299之间, 说明请求都是成功的</span><br><span class="line">      if (request.status&gt;=200 &amp;&amp; request.status&lt;300) &#123;</span><br><span class="line">        // 准备响应数据对象</span><br><span class="line">        const responseData = &#123;</span><br><span class="line">          data: JSON.parse(request.response),</span><br><span class="line">          status: request.status,</span><br><span class="line">          statusText: request.statusText</span><br><span class="line">        &#125;</span><br><span class="line">        // 指定promise成功及结果值</span><br><span class="line">        resolve(responseData)</span><br><span class="line">      &#125; else &#123; // 请求失败了</span><br><span class="line">        // 指定promise失败及结果值</span><br><span class="line">        const error = new Error(&#x27;request error staus &#x27;+ request.status)</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果是post/put请求</span><br><span class="line">    if (method===&#x27;POST&#x27; || method===&#x27;PUT&#x27; || method===&#x27;DELETE&#x27;) &#123;</span><br><span class="line">      // 设置请求头: 使请求体参数以json形式传递</span><br><span class="line">      request.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json;charset=utf-8&#x27;)</span><br><span class="line">      // 包含所有请求参数的对象转换为json格式</span><br><span class="line">      const dataJson = JSON.stringify(data)</span><br><span class="line">      // 发送请求, 指定请求体数据</span><br><span class="line">      request.send(dataJson)</span><br><span class="line">    &#125; else &#123;// GET请求</span><br><span class="line">      // 发送请求</span><br><span class="line">      request.send(null)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li>什么是跨域(同源策略)</li>
<li>JSONP</li>
<li>CORS</li>
<li>代理服务器</li>
</ul>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><ul>
<li>同源: 协议, 域名, 端口, 三者都相同</li>
<li>ajax请求时, 浏览器要求当前网页和Server必须同源(安全), 否则会抛出跨域的错误</li>
<li>加载image/link/script不受同源策略限制</li>
</ul>
<h3 id="JSONP原理"><a href="#JSONP原理" class="headerlink" title="JSONP原理"></a>JSONP原理</h3><ul>
<li><p>前台:</p>
<ul>
<li><code>&lt;script src=&quot;目标url?callback=fn&quot; /&gt;</code></li>
<li>接收响应数据的函数: function fn (data) {}</li>
</ul>
</li>
<li><p>后台</p>
<ul>
<li>处理请求, 产生需要返回的数据data</li>
<li>读取callback请求参数得到前台处理响应数据的函数名fn</li>
<li>返回执行函数fn的js代码: ‘fn &amp;&amp; fn(data)’</li>
</ul>
</li>
<li><p>不足</p>
<ul>
<li>只能处理GET请求</li>
<li>每个请求在后台都要做处理, 麻烦</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 发送jsonp请求的函数</span><br><span class="line">function jsonp() &#123;</span><br><span class="line">    var script = document.createElement(&#x27;script&#x27;)</span><br><span class="line">    script.type = &#x27;text/javascript&#x27;</span><br><span class="line">    // 传参并指定回调执行函数为backFn</span><br><span class="line">    script.src = &#x27;http://localhost:4000/getUserInfo?id=100&amp;callback=fn&#x27;</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回调函数, 接收响应数据</span><br><span class="line">function fn(data) &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CORS原理"><a href="#CORS原理" class="headerlink" title="CORS原理"></a>CORS原理</h3><ul>
<li>后台: 返回允许浏览器在某个域上发送跨域请求的相关响应头</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 使用cors, 允许跨域, 且允许携带跨域cookie</span><br><span class="line">app.use(function (req, res, next) &#123;</span><br><span class="line">  // console.log(&#x27;----&#x27;)</span><br><span class="line">  // 允许跨域的地址</span><br><span class="line">  res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://localhost:5500&#x27;)  // 不要是*</span><br><span class="line">  // 允许携带凭证(也就是cookie)</span><br><span class="line">  res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;)</span><br><span class="line">  // 允许跨域的请求头</span><br><span class="line">  res.set(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;)</span><br><span class="line">  // 放行</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>前台: 不需要做特别任何处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = true // 允许携带cookie</span><br><span class="line">xhr.withCredentials = true</span><br></pre></td></tr></table></figure>

<h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><ul>
<li>开发环境: 利用webpack-dev-server中的http-proxy-middle  进行正向代理<ul>
<li>vue脚手架项目</li>
<li>react脚手架项目</li>
<li>自定义webpack配置</li>
<li>直接使用http-proxy-middle配置</li>
</ul>
</li>
<li>生产环境: 利用nigix  进行反向代理</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/taostaryu/p/10547132.html">https://www.cnblogs.com/taostaryu/p/10547132.html</a></li>
</ul>
<h3 id="使用axios发送ajax请求"><a href="#使用axios发送ajax请求" class="headerlink" title="使用axios发送ajax请求"></a>使用axios发送ajax请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">axios(url)</span><br><span class="line">axios(&#123;</span><br><span class="line">    method: &#x27;&#x27;,</span><br><span class="line">    url: &#x27;&#x27;,  // 如果有params参数必须拼接在url中</span><br><span class="line">    params: &#123;&#125;, // query参数</span><br><span class="line">    data: &#123;&#125; // 请求体参数</span><br><span class="line">&#125;)</span><br><span class="line">axios.get(url, &#123;配置&#125;)</span><br><span class="line">axios.post(url, data, &#123;配置&#125;)</span><br><span class="line">axios.put(url, data, &#123;配置&#125;)</span><br><span class="line">axios.delete(url, &#123;配置&#125;)</span><br><span class="line"></span><br><span class="line">const service = axios.create(&#123;</span><br><span class="line">    baseURL: &#x27;&#x27;,</span><br><span class="line">    timeout: 20000,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">service.interceptors.request.use((config) =&gt; &#123;</span><br><span class="line">    // 添加请求头</span><br><span class="line">    config.headers[&#x27;token&#x27;] = token值</span><br><span class="line">    return config // 必须返回config</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">xhr.send()</span><br><span class="line"></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">        // return response</span><br><span class="line">        return response.data</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">service(&#123;&#125;).then(data =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Promise.resolve(config)</span><br><span class="line">    .then((config) =&gt; &#123;  // 请求拦截器的回调</span><br><span class="line">        return config</span><br><span class="line">    &#125;)  </span><br><span class="line">    .then((config) =&gt; &#123; // 用来发ajax的回调</span><br><span class="line">        return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            // 根据config使用xhr发请求</span><br><span class="line">            resolve(response)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(   // 响应拦截器</span><br><span class="line">        (response) =&gt; &#123;</span><br><span class="line">            return response.data</span><br><span class="line">        &#125;, </span><br><span class="line">        (error) =&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .then((data) =&gt; &#123; // 最终发具体请求的成功回调</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="axios二次封装"><a href="#axios二次封装" class="headerlink" title="axios二次封装"></a>axios二次封装</h3><ol>
<li>配置通用的基础路径和超时</li>
<li>显示请求进度条<ol>
<li>显示进度条: 请求拦截器回调</li>
<li>结束进度条: 响应拦截器回调</li>
</ol>
</li>
<li>成功返回的数据不再是response, 而直接是响应体数据response.data</li>
<li>统一处理请求错误, 具体请求也可以选择处理或不处理</li>
<li>每个请求自动携带userTempId的请求头: 在请求拦截器中实现</li>
<li>如果当前有token, 自动携带token的请求头</li>
<li>对token过期的错误进行处理</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">import NProgress from &#x27;nprogress&#x27;</span><br><span class="line">import &#x27;nprogress/nprogress.css&#x27;</span><br><span class="line">import store from &#x27;@/store&#x27;</span><br><span class="line">import router from &#x27;@/router&#x27;</span><br><span class="line"></span><br><span class="line">NProgress.configure(&#123; showSpinner: false &#125;) // 隐藏右侧的旋转进度条</span><br><span class="line"></span><br><span class="line">// 创建instance</span><br><span class="line">const instance = axios.create(&#123;</span><br><span class="line">  // baseURL: &#x27;http://182.92.128.115/api&#x27;,</span><br><span class="line">  baseURL: &#x27;/api&#x27;,</span><br><span class="line">  timeout: 20000</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 指定请求拦截器</span><br><span class="line">instance.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">  // 显示进度条: 请求拦截器回调</span><br><span class="line">  NProgress.start()</span><br><span class="line"></span><br><span class="line">  /* 每个请求自动携带userTempId的请求头: 在请求拦截器中实现 */</span><br><span class="line">  const userTempId = store.state.user.userTempId</span><br><span class="line">  config.headers.userTempId = userTempId</span><br><span class="line">  </span><br><span class="line">  /* 6. 如果当前有token, 自动携带token的请求头 */</span><br><span class="line">  const token = store.state.user.token</span><br><span class="line">  if (token) &#123;</span><br><span class="line">    config.headers.token = token</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return config // 必须返回config</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 指定响应拦截器</span><br><span class="line">instance.interceptors.response.use(</span><br><span class="line">  response =&gt; &#123; // 成功的回调</span><br><span class="line">    // 结束进度条: 响应拦截器回调</span><br><span class="line">    NProgress.done()</span><br><span class="line">    // 成功返回的数据不再是response, 而直接是响应体数据response.data</span><br><span class="line">    return response.data</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  async error =&gt; &#123; // 失败的回调</span><br><span class="line">    // 结束进度条: 响应拦截器回调</span><br><span class="line">    NProgress.done()</span><br><span class="line"></span><br><span class="line">    // 统一处理请求错误, 具体请求也可以选择处理或不处理</span><br><span class="line">    // alert(&#x27;请求出错: &#x27; + error.message||&#x27;未知错误&#x27;)</span><br><span class="line"></span><br><span class="line">    // 取出响应对象</span><br><span class="line">    const &#123; response &#125; = error</span><br><span class="line">    // 如果是请求处理出错</span><br><span class="line">    if (response &amp;&amp; response.status) &#123;</span><br><span class="line">      // 401说明token非法</span><br><span class="line">      if (response.status === 401) &#123;</span><br><span class="line">        // 如果当前没在登陆页</span><br><span class="line">        if (router.currentRoute.path!==&#x27;/login&#x27;) &#123;</span><br><span class="line">          // 分发action去清除用户token信息</span><br><span class="line">          await store.dispatch(&#x27;logout&#x27;)</span><br><span class="line">          // 跳转到登陆页面</span><br><span class="line">          router.replace(&#x27;/login&#x27;)</span><br><span class="line">          // 提示</span><br><span class="line">          message.error(&#x27;登陆已过期, 请重新登陆&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        message.error(&#x27;请求出错: &#x27; + error.message||&#x27;未知错误&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (!response) &#123; // 网络连接不上服务器</span><br><span class="line">      message.error(&#x27;您的网络发生异常，无法连接服务器&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // throw error</span><br><span class="line">    return Promise.reject(error) // 将错误向下传递</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 向外暴露instance</span><br><span class="line">export default instance</span><br></pre></td></tr></table></figure>



<h3 id="Restless-API-与-Restful-API"><a href="#Restless-API-与-Restful-API" class="headerlink" title="Restless API 与 Restful API"></a>Restless API 与 Restful API</h3><ul>
<li><p>Restless API  </p>
<ul>
<li>传统的API, 把每个url当作一个功能操作      /deleteUser</li>
<li>同一个url, 后台只进行CRUD的某一种操作</li>
<li>请求方式不决定请求的CRUD操作</li>
<li>一个请求路径只对应一个操作</li>
<li>一般只有GET/POST</li>
</ul>
</li>
<li><p>Restful API </p>
<ul>
<li>新式的API, 把每个url当作一个唯一资源   /user/2</li>
<li>同一个url, 可以通过不同类型的请求对后台资源数据进行CRUD四种操作</li>
<li>请求方式来决定了请求在后台进行CRUD的哪种操作<ul>
<li>GET: 查询</li>
<li>POST: 添加</li>
<li>PUT: 更新</li>
<li>DELETE: 删除</li>
</ul>
</li>
<li>同一个请求路径可以进行多个操作</li>
<li>请求方式会用到GET/POST/PUT/DELETE</li>
</ul>
</li>
<li><p>测试: 可以使用json-server快速搭建模拟的rest api 接口</p>
</li>
</ul>
<h2 id="前台数据存储"><a href="#前台数据存储" class="headerlink" title="前台数据存储"></a>前台数据存储</h2><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><ul>
<li>cookie</li>
<li>sessionStorage</li>
<li>localStorage</li>
</ul>
<p>注意: session后台数据存储</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul>
<li>本身用于浏览器和Server通讯</li>
<li>被 “借用” 到本地存储</li>
<li>可用document.cookie读取或保存</li>
<li>可以利用cookies工具库简化编码</li>
</ul>
<h3 id="cookie的缺点"><a href="#cookie的缺点" class="headerlink" title="cookie的缺点"></a>cookie的缺点</h3><ul>
<li>存储大小有限, 最大4KB</li>
<li>http请求时会自动发送给服务器, 增加了请求的数据量</li>
<li>原生的操作语法不太方便操作cookie</li>
<li>浏览器可以设置禁用</li>
</ul>
<h3 id="localStoarge与sessionStorage"><a href="#localStoarge与sessionStorage" class="headerlink" title="localStoarge与sessionStorage"></a>localStoarge与sessionStorage</h3><ul>
<li>相同点:<ul>
<li>纯浏览器端存储, 大小不受限制, 请求时不会自动携带</li>
<li>只能保存文本, 如果是对象或数组, 需要转换为JSON</li>
<li>API相同:<ul>
<li>setItem(key, value)</li>
<li>getItem(key, value)</li>
<li>removeitem(key, value)</li>
</ul>
</li>
<li>浏览器不能禁用</li>
</ul>
</li>
<li>不同点:<ul>
<li>localStorage保存在本地文件中, 除非编码或手动删除, 否则一直存在</li>
<li>sessonStorage数据保存在当前会话内存中, 关闭浏览器则清除</li>
</ul>
</li>
</ul>
<h3 id="区别cookie-与-localStorage和sessionStorage"><a href="#区别cookie-与-localStorage和sessionStorage" class="headerlink" title="区别cookie 与 localStorage和sessionStorage"></a>区别cookie 与 localStorage和sessionStorage</h3><ul>
<li>容量</li>
<li>请求时是否自动携带</li>
<li>API易用性</li>
<li>浏览器是否可禁用</li>
</ul>
<h3 id="区别cookie与session"><a href="#区别cookie与session" class="headerlink" title="区别cookie与session"></a>区别cookie与session</h3><ul>
<li>cookie保存在浏览器端(前台可以操作)</li>
<li>session保存在服务器端(前台不能操作)</li>
<li>session依赖于cookie(session的id以cookie的形式保存在浏览器端)</li>
</ul>
<h3 id="从输入url到渲染出页面的整个过程"><a href="#从输入url到渲染出页面的整个过程" class="headerlink" title="从输入url到渲染出页面的整个过程"></a>从输入url到渲染出页面的整个过程</h3><p><a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a></p>
<ol>
<li>DNS 解析（查询）：将域名地址解析 ip 地址</li>
</ol>
<ul>
<li>浏览器 DNS 缓存</li>
<li>计算机 DNS 缓存</li>
<li>路由器 DNS 缓存</li>
<li>网络运营商 DNS 缓存</li>
<li>递归查询</li>
</ul>
<ol>
<li>TCP 链接：TCP 三次握手  ===&gt; 建立连接</li>
</ol>
<ul>
<li>客户端发送服务端：我准备好了，请你准备一下</li>
<li>服务端发送客户端：我也准备好了，请你确认一下</li>
<li>客户端发送服务端：确认完毕</li>
</ul>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E9%80%9A%E4%BF%97%E7%89%88.jpeg" alt="TCP三次握手_通俗版" data-caption="TCP三次握手_通俗版" loading="lazy"></p>
<ol>
<li>发送请求</li>
</ol>
<ul>
<li>将请求报文发送过去</li>
</ul>
<ol>
<li>返回响应</li>
</ol>
<ul>
<li>将响应报文发送过来</li>
</ul>
<ol>
<li>解析渲染页面</li>
</ol>
<ul>
<li>遇到 HTML，调用 HTML 解析器，解析成 DOM 树</li>
<li>遇到 CSS，调用 CSS 解析器，解析成 CSSOM 树</li>
<li>遇到 JS，调用 JS 解析器（JS 引擎），解析 JS 代码<ul>
<li>可能要修改元素节点，重新调用 HTML 解析器，解析更新DOM 树</li>
<li>可能要修改样式节点，重新调用 CSS 解析器，解析更新 CSSOM 树</li>
</ul>
</li>
<li>将 DOM + CSSOM = Render Tree（渲染树）</li>
<li>layout 布局：计算元素的位置和大小信息</li>
<li>render 渲染：将颜色/文字/图片等渲染上去</li>
</ul>
<ol>
<li>断开链接：TCP 四次挥手 (断开请求链接 2 次, 断开响应链接 2 次)</li>
</ol>
<ul>
<li>客户端发送服务端：请求数据发送完毕，可以断开了</li>
<li>服务端发送客户端：请求数据接受完毕，可以断开了</li>
<li>服务端发送客户端：响应数据发送完毕，可以断开了</li>
<li>客户端发送服务端：响应数据接受完毕，可以断开了</li>
</ul>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://766187397.github.io/images//%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B_%E9%80%9A%E4%BF%97%E7%89%88.jpeg" alt="四次挥手_通俗版" data-caption="四次挥手_通俗版" loading="lazy"></p>
<h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><h3 id="函数的call-apply-bind"><a href="#函数的call-apply-bind" class="headerlink" title="函数的call() / apply() / bind()"></a>函数的call() / apply() / bind()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">自定义函数对象的call方法</span><br><span class="line">*/</span><br><span class="line">function call (fn, obj, ...args) &#123;</span><br><span class="line">  // 如果传入的是null/undefined, this指定为window</span><br><span class="line">  if (obj===null || obj===undefined) &#123;</span><br><span class="line">    obj = obj || window</span><br><span class="line">  &#125;</span><br><span class="line">  // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象</span><br><span class="line">  obj.tempFn = fn</span><br><span class="line">  // 通过obj调用这个方法</span><br><span class="line">  const result = obj.tempFn(...args)</span><br><span class="line">  // 删除新添加的方法</span><br><span class="line">  delete obj.tempFn</span><br><span class="line">  // 返回函数调用的结果</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">自定义函数对象的apply方法</span><br><span class="line">*/</span><br><span class="line">function apply (fn, obj, args) &#123;</span><br><span class="line">  // 如果传入的是null/undefined, this指定为window</span><br><span class="line">  if (obj===null || obj===undefined) &#123;</span><br><span class="line">    obj = obj || window</span><br><span class="line">  &#125;</span><br><span class="line">  // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象</span><br><span class="line">  obj.tempFn = fn</span><br><span class="line">  // 通过obj调用这个方法</span><br><span class="line">  const result = obj.tempFn(...args)</span><br><span class="line">  // 删除新添加的方法</span><br><span class="line">  delete obj.tempFn</span><br><span class="line">  // 返回函数调用的结果</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">  自定义函数对象的bind方法</span><br><span class="line">  重要技术:</span><br><span class="line">    高阶函数</span><br><span class="line">    闭包</span><br><span class="line">    call()</span><br><span class="line">    三点运算符</span><br><span class="line">*/</span><br><span class="line">function bind (fn, obj, ...args) &#123;</span><br><span class="line">  if (obj===null || obj===undefined) &#123;</span><br><span class="line">    obj = obj || window</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return function (...args2) &#123;</span><br><span class="line">    return call(fn, obj, ...args, ...args2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数的节流-throttle-与防抖-debounce"><a href="#函数的节流-throttle-与防抖-debounce" class="headerlink" title="函数的节流(throttle)与防抖(debounce)"></a>函数的节流(throttle)与防抖(debounce)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">实现函数节流的函数</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">function throttle(callback, delay) &#123;</span><br><span class="line">  let start = 0 // 必须保存第一次点击立即调用</span><br><span class="line">  return function (event) &#123; // 事件回调函数</span><br><span class="line">    // this是发生事件的dom元素</span><br><span class="line">    console.log(&#x27;throttle 事件&#x27;)</span><br><span class="line">    const current = Date.now()</span><br><span class="line">    if (current - start &gt; delay) &#123; // 从第2次点击开始, 需要间隔时间超过delay</span><br><span class="line">      callback.call(this, event)</span><br><span class="line">      // 将当前时间指定为start, ==&gt; 为后面的比较做准备</span><br><span class="line">      start = current</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">实现函数防抖的函数</span><br><span class="line">*/</span><br><span class="line">function debounce(callback, delay) &#123;</span><br><span class="line">  return function (event) &#123;</span><br><span class="line">    console.log(&#x27;debounce 事件...&#x27;)</span><br><span class="line">    </span><br><span class="line">    // 清除待执行的定时器任务</span><br><span class="line">    if (callback.timeoutId) &#123;</span><br><span class="line">      clearTimeout(callback.timeoutId)</span><br><span class="line">    &#125;</span><br><span class="line">    // 每隔delay的时间, 启动一个新的延迟定时器, 去准备调用callback</span><br><span class="line">    callback.timeoutId = setTimeout(() =&gt; &#123;</span><br><span class="line">      callback.call(this, event)</span><br><span class="line">      // 如果定时器回调执行了, 删除标记</span><br><span class="line">      delete callback.timeoutId</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组去重-unique"><a href="#数组去重-unique" class="headerlink" title="数组去重(unique)"></a>数组去重(unique)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">方法1: 利用forEach()和indexOf()</span><br><span class="line">  说明: 本质是双重遍历, 效率差些</span><br><span class="line">*/</span><br><span class="line">function unique1 (array) &#123;</span><br><span class="line">  const arr = []</span><br><span class="line">  array.forEach(item =&gt; &#123;</span><br><span class="line">    if (arr.indexOf(item)===-1) &#123; // 内部在遍历判断出来的</span><br><span class="line">      arr.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">方法2: 利用forEach() + 对象容器</span><br><span class="line">  说明: 只需一重遍历, 效率高些</span><br><span class="line">*/</span><br><span class="line">function unique2 (array) &#123;</span><br><span class="line">  const arr = []</span><br><span class="line">  const obj = &#123;&#125;</span><br><span class="line">  array.forEach(item =&gt; &#123;</span><br><span class="line">    if (!obj.hasOwnProperty(item)) &#123;// 不用遍历就能判断出是否已经有了</span><br><span class="line">      obj[item] = true</span><br><span class="line">      arr.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">方法3: 利用ES6语法</span><br><span class="line">    1). from + Set</span><br><span class="line">    2). ... + Set</span><br><span class="line">    说明: 编码简洁</span><br><span class="line">*/</span><br><span class="line">function unique3 (array) &#123;</span><br><span class="line">  // return Array.from(new Set(array))</span><br><span class="line">  return [...new Set(array)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组扁平化-flatten"><a href="#数组扁平化-flatten" class="headerlink" title="数组扁平化(flatten)"></a>数组扁平化(flatten)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">数组扁平化: 取出嵌套数组(多维)中的所有元素放到一个新数组(一维)中</span><br><span class="line">  如: [1, [3, [2, 4]]]  ==&gt;  [1, 3, 2, 4]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">方法一: 递归 + reduce() + concat()</span><br><span class="line">*/</span><br><span class="line">function flatten1 (array) &#123;</span><br><span class="line"></span><br><span class="line">  return array.reduce((pre, item) =&gt; &#123;</span><br><span class="line">    if (Array.isArray(item) &amp;&amp; item.some((cItem =&gt; Array.isArray(cItem)))) &#123;</span><br><span class="line">      return pre.concat(flatten1(item))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return pre.concat(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">方法二: ... + some() + concat()</span><br><span class="line">*/</span><br><span class="line">function flatten2 (array) &#123;</span><br><span class="line"></span><br><span class="line">  let arr = [].concat(...array)</span><br><span class="line">  while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">深度克隆</span><br><span class="line">1). 大众乞丐版</span><br><span class="line">    问题1: 函数属性会丢失</span><br><span class="line">    问题2: 循环引用会出错</span><br><span class="line">2). 面试基础版本</span><br><span class="line">    解决问题1: 函数属性还没丢失</span><br><span class="line">3). 面试加强版本</span><br><span class="line">    解决问题2: 循环引用正常</span><br><span class="line">4). 面试加强版本2(优化遍历性能)</span><br><span class="line">    数组: while | for | forEach() 优于 for-in | keys()&amp;forEach() </span><br><span class="line">    对象: for-in 与 keys()&amp;forEach() 差不多</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    b: [],</span><br><span class="line">    fn: function ()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a.c = obj.b</span><br><span class="line">obj.b[0] = obj.a</span><br><span class="line">/* </span><br><span class="line">1). 大众乞丐版</span><br><span class="line">  问题1: 函数属性会丢失</span><br><span class="line">  问题2: 循环引用会出错</span><br><span class="line">*/</span><br><span class="line">export function deepClone1(target) &#123;</span><br><span class="line">  return JSON.parse(JSON.stringify(target))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">获取数据的类型字符串名</span><br><span class="line">*/</span><br><span class="line">function getType(data) &#123;</span><br><span class="line">  return Object.prototype.toString.call(data).slice(8, -1)  // -1代表最后一位</span><br><span class="line">    // [object Array]  ===&gt; Array  [object Object] ==&gt; Object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">2). 面试基础版本</span><br><span class="line">  解决问题1: 函数属性还没丢失</span><br><span class="line">*/</span><br><span class="line">function deepClone2(target) &#123;</span><br><span class="line">  const type = getType(target)</span><br><span class="line"></span><br><span class="line">  if (type===&#x27;Object&#x27; || type===&#x27;Array&#x27;) &#123;</span><br><span class="line">    const cloneTarget = type === &#x27;Array&#x27; ? [] : &#123;&#125;</span><br><span class="line">    for (const key in target) &#123;</span><br><span class="line">      if (target.hasOwnProperty(key)) &#123;</span><br><span class="line">        cloneTarget[key] = deepClone2(target[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cloneTarget</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">3). 面试加强版本</span><br><span class="line">  解决问题2: 循环引用正常</span><br><span class="line">*/</span><br><span class="line">function deepClone3(target, map = new Map()) &#123;</span><br><span class="line">  const type = getType(target)</span><br><span class="line">  if (type===&#x27;Object&#x27; || type===&#x27;Array&#x27;) &#123;</span><br><span class="line">     // 从map容器取对应的clone对象</span><br><span class="line">    let cloneTarget = map.get(target)</span><br><span class="line">    // 如果有, 直接返回这个clone对象</span><br><span class="line">    if (cloneTarget) &#123;</span><br><span class="line">      return cloneTarget</span><br><span class="line">    &#125;</span><br><span class="line">    cloneTarget = type===&#x27;Array&#x27; ? [] : &#123;&#125;</span><br><span class="line">    // 将clone产生的对象保存到map容器</span><br><span class="line">    map.set(target, cloneTarget)</span><br><span class="line">    for (const key in target) &#123;</span><br><span class="line">      if (target.hasOwnProperty(key)) &#123;</span><br><span class="line">        cloneTarget[key] = deepClone3(target[key], map)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cloneTarget</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">4). 面试加强版本2(优化遍历性能)</span><br><span class="line">    数组: while | for | forEach() 优于 for-in | keys()&amp;forEach() </span><br><span class="line">    对象: for-in 与 keys()&amp;forEach() 差不多</span><br><span class="line">*/</span><br><span class="line">function deepClone4(target, map = new Map()) &#123;</span><br><span class="line">  const type = getType(target)</span><br><span class="line">  if (type===&#x27;Object&#x27; || type===&#x27;Array&#x27;) &#123;</span><br><span class="line">    let cloneTarget = map.get(target)</span><br><span class="line">    if (cloneTarget) &#123;</span><br><span class="line">      return cloneTarget</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (type===&#x27;Array&#x27;) &#123;</span><br><span class="line">      cloneTarget = []</span><br><span class="line">      map.set(target, cloneTarget)</span><br><span class="line">      target.forEach((item, index) =&gt; &#123;</span><br><span class="line">        cloneTarget[index] = deepClone4(item, map)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cloneTarget = &#123;&#125;</span><br><span class="line">      map.set(target, cloneTarget)</span><br><span class="line">      Object.keys(target).forEach(key =&gt; &#123;</span><br><span class="line">        cloneTarget[key] = deepClone4(target[key], map)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cloneTarget</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自定义new和instanceof工具函数"><a href="#自定义new和instanceof工具函数" class="headerlink" title="自定义new和instanceof工具函数"></a>自定义new和instanceof工具函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">自定义new工具函数</span><br><span class="line">  语法: newInstance(Fn, ...args)</span><br><span class="line">  功能: 创建Fn构造函数的实例对象</span><br><span class="line">  实现: 创建空对象obj, 调用Fn指定this为obj, 返回obj</span><br><span class="line">*/</span><br><span class="line">function newInstance(Fn, ...args) &#123;</span><br><span class="line">  // 创建一个新的对象</span><br><span class="line">  const obj = &#123;&#125;</span><br><span class="line">  // 执行构造函数</span><br><span class="line">  const result = Fn.apply(obj, args) // 相当于: obj.Fn()</span><br><span class="line">  // 如果构造函数执行的结果是对象, 返回这个对象</span><br><span class="line">  if (result instanceof Object) &#123;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果不是, 返回新创建的对象</span><br><span class="line">  obj.__proto__.constructor = Fn // 让原型对象的构造器属性指向Fn</span><br><span class="line">  </span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">自定义instanceof工具函数: </span><br><span class="line">  语法: myInstanceOf(obj, Type)</span><br><span class="line">  功能: 判断obj是否是Type类型的实例</span><br><span class="line">  实现: Type的原型对象是否是obj的原型链上的某个对象, 如果是返回true, 否则返回false</span><br><span class="line">*/</span><br><span class="line">function myInstanceOf(obj, Type) &#123;</span><br><span class="line">  // 得到原型对象</span><br><span class="line">  let protoObj = obj.__proto__</span><br><span class="line"></span><br><span class="line">  // 只要原型对象存在</span><br><span class="line">  while(protoObj) &#123;</span><br><span class="line">    // 如果原型对象是Type的原型对象, 返回true</span><br><span class="line">    if (protoObj === Type.prototype) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">    // 指定原型对象的原型对象</span><br><span class="line">    protoObj = protoObj.__proto__</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">1. 字符串倒序: reverseString(str)  生成一个倒序的字符串</span><br><span class="line">2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false</span><br><span class="line">3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">1. 字符串倒序: reverseString(str)  生成一个倒序的字符串</span><br><span class="line">*/</span><br><span class="line">function reverseString(str) &#123;</span><br><span class="line">  // return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">  // return [...str].reverse().join(&#x27;&#x27;)</span><br><span class="line">  return Array.from(str).reverse().join(&#x27;&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false</span><br><span class="line">*/</span><br><span class="line">function palindrome(str) &#123;</span><br><span class="line">  return str === reverseString(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束</span><br><span class="line">*/</span><br><span class="line">function truncate(str, num) &#123;</span><br><span class="line">  return str.length &gt; num ? str.slice(0, num) + &#x27;...&#x27; : str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="简单排序-冒泡-选择-插入"><a href="#简单排序-冒泡-选择-插入" class="headerlink" title="简单排序: 冒泡 / 选择 / 插入"></a>简单排序: 冒泡 / 选择 / 插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">冒泡排序的方法</span><br><span class="line">*/</span><br><span class="line">function bubbleSort (array) &#123;</span><br><span class="line">  // 1.获取数组的长度</span><br><span class="line">  var length = array.length;</span><br><span class="line"></span><br><span class="line">  // 2.反向循环, 因此次数越来越少</span><br><span class="line">  for (var i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    // 3.根据i的次数, 比较循环到i位置</span><br><span class="line">    for (var j = 0; j &lt; i; j++) &#123;</span><br><span class="line">      // 4.如果j位置比j+1位置的数据大, 那么就交换</span><br><span class="line">      if (array[j] &gt; array[j + 1]) &#123;</span><br><span class="line">        // 交换</span><br><span class="line">        // const temp = array[j+1]</span><br><span class="line">        // array[j+1] = array[j]</span><br><span class="line">        // array[j] = temp</span><br><span class="line">        [array[j + 1], array[j]] = [array[j], array[j + 1]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">选择排序的方法</span><br><span class="line">*/</span><br><span class="line">function selectSort (array) &#123;</span><br><span class="line">  // 1.获取数组的长度</span><br><span class="line">  var length = array.length</span><br><span class="line"></span><br><span class="line">  // 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span><br><span class="line">  for (var i = 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">    // 3.内层循环: 从i+1位置开始, 和后面的内容比较</span><br><span class="line">    var min = i</span><br><span class="line">    for (var j = min + 1; j &lt; length; j++) &#123;</span><br><span class="line">      // 4.如果i位置的数据大于j位置的数据, 记录最小的位置</span><br><span class="line">      if (array[min] &gt; array[j]) &#123;</span><br><span class="line">        min = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (min !== i) &#123;</span><br><span class="line">      // 交换</span><br><span class="line">      [array[min], array[i]] = [array[i], array[min]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">插入排序的方法</span><br><span class="line">*/</span><br><span class="line">function insertSort (array) &#123;</span><br><span class="line">  // 1.获取数组的长度</span><br><span class="line">  var length = array.length</span><br><span class="line"></span><br><span class="line">  // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span><br><span class="line">  for (var i = 1; i &lt; length; i++) &#123;</span><br><span class="line">    // 3.记录选出的元素, 放在变量temp中</span><br><span class="line">    var j = i</span><br><span class="line">    var temp = array[i]</span><br><span class="line"></span><br><span class="line">    // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span><br><span class="line">    while (j &gt; 0 &amp;&amp; array[j - 1] &gt; temp) &#123;</span><br><span class="line">      array[j] = array[j - 1]</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5.将选出的j位置, 放入temp元素</span><br><span class="line">    array[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    
  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>辰風依恛<br>
        <strong>本文链接：</strong><a href="https://766187397.github.io/2025/05/12/004.%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E4%B9%A0%E5%89%8D%E7%AB%AF--JavaScript/" title="https:&#x2F;&#x2F;766187397.github.io&#x2F;2025&#x2F;05&#x2F;12&#x2F;004.%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E4%B9%A0%E5%89%8D%E7%AB%AF--JavaScript&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;766187397.github.io&#x2F;2025&#x2F;05&#x2F;12&#x2F;004.%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E4%B9%A0%E5%89%8D%E7%AB%AF--JavaScript&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
   
    
</div>

  
      <div class="nexmoe-post-footer">
          
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#004-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E4%B9%A0%E5%89%8D%E7%AB%AF%E2%80%93JavaScript"><span class="toc-number">1.</span> <span class="toc-text">004.从零开始复习前端–JavaScript</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text">常规内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="toc-number">2.1.</span> <span class="toc-text">1. 基础部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">2. 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3. 原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%A2%84%E8%A7%A3%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">4. 预解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.5.</span> <span class="toc-text">5. 执行上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.6.</span> <span class="toc-text">6. 作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%97%AD%E5%8C%85"><span class="toc-number">2.7.</span> <span class="toc-text">7. 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5"><span class="toc-number">2.8.</span> <span class="toc-text">9. 同步&#x2F;异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6event-loop1-%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%9F%E7%A7%B0-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6"><span class="toc-number">2.9.</span> <span class="toc-text">10. 事件轮询机制event loop1(异步实现的原理统称:事件循环(轮询机制))</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Promise"><span class="toc-number">2.10.</span> <span class="toc-text">11. Promise</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9"><span class="toc-number">3.</span> <span class="toc-text">JS其他内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">3.1.</span> <span class="toc-text">事件冒泡与事件委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">1) 事件冒泡的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">2) 事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%BB%91%E5%B8%A6%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%9A%84%E5%87%BD%E6%95%B0-%E6%9C%89%E9%9A%BE%E5%BA%A6"><span class="toc-number">3.1.3.</span> <span class="toc-text">3) 封装一个绑带事件监听的函数(有难度)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax"><span class="toc-number">3.2.</span> <span class="toc-text">ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xhr-status"><span class="toc-number">3.2.1.</span> <span class="toc-text">xhr.status</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%ABajax%E8%AF%B7%E6%B1%82%E4%B8%8E%E4%B8%80%E8%88%ACHTTP%E8%AF%B7%E6%B1%82"><span class="toc-number">3.2.2.</span> <span class="toc-text">区别ajax请求与一般HTTP请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84ajax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">封装一个简易的ajax异步请求函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">3.2.4.</span> <span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.5.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.6.</span> <span class="toc-text">JSONP原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.7.</span> <span class="toc-text">CORS原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.2.8.</span> <span class="toc-text">代理服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8axios%E5%8F%91%E9%80%81ajax%E8%AF%B7%E6%B1%82"><span class="toc-number">3.2.9.</span> <span class="toc-text">使用axios发送ajax请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85"><span class="toc-number">3.2.10.</span> <span class="toc-text">axios二次封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Restless-API-%E4%B8%8E-Restful-API"><span class="toc-number">3.2.11.</span> <span class="toc-text">Restless API 与 Restful API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">3.3.</span> <span class="toc-text">前台数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie"><span class="toc-number">3.3.2.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">3.3.3.</span> <span class="toc-text">cookie的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localStoarge%E4%B8%8EsessionStorage"><span class="toc-number">3.3.4.</span> <span class="toc-text">localStoarge与sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%ABcookie-%E4%B8%8E-localStorage%E5%92%8CsessionStorage"><span class="toc-number">3.3.5.</span> <span class="toc-text">区别cookie 与 localStorage和sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%ABcookie%E4%B8%8Esession"><span class="toc-number">3.3.6.</span> <span class="toc-text">区别cookie与session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%B8%B2%E6%9F%93%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.7.</span> <span class="toc-text">从输入url到渲染出页面的整个过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-number">3.4.</span> <span class="toc-text">手写代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84call-apply-bind"><span class="toc-number">3.4.1.</span> <span class="toc-text">函数的call() &#x2F; apply() &#x2F; bind()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%8A%82%E6%B5%81-throttle-%E4%B8%8E%E9%98%B2%E6%8A%96-debounce"><span class="toc-number">3.4.2.</span> <span class="toc-text">函数的节流(throttle)与防抖(debounce)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D-unique"><span class="toc-number">3.4.3.</span> <span class="toc-text">数组去重(unique)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96-flatten"><span class="toc-number">3.4.4.</span> <span class="toc-text">数组扁平化(flatten)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.4.5.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89new%E5%92%8Cinstanceof%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.6.</span> <span class="toc-text">自定义new和instanceof工具函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="toc-number">3.4.7.</span> <span class="toc-text">字符串处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1-%E9%80%89%E6%8B%A9-%E6%8F%92%E5%85%A5"><span class="toc-number">3.4.8.</span> <span class="toc-text">简单排序: 冒泡 &#x2F; 选择 &#x2F; 插入</span></a></li></ol></li></ol></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="Back To Top" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
    <div id="nexmoe-search-space">
	<div class="search-container">
		<div class="search-header">
			<div class="search-input-container">
				<input
					class="search-input"
					type="text"
					placeholder="搜索"
					oninput="sinput();"
				/>
			</div>
			<a class="search-close" onclick="sclose();">×</a>
		</div>
		<div class="search-body"></div>
	</div>
</div>

    
<script src="/lib/mdui_043tiny/mdui.js"></script>
<script src="/lib/fancybox/fancybox.umd.js"></script>


 

<script async src="/js/app.js?v=1760953161773"></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2058306854838448" crossorigin="anonymous"></script>

</body>

</html>
