[{"title":"Gin快速上手","path":"2025/09/28/Gin快速上手/","text":"Gin快速上手 从Express/Koa/NestJS到Go语言Web开发 前言如果你已经熟悉Express、Koa或NestJS等Node.js框架，学习Gin框架将会非常顺畅。Gin是Go语言中最流行的Web框架之一，以其高性能、简洁的API和丰富的中间件生态著称。 环境搭建1. Go语言环境安装12345678# 下载并安装Go (https://golang.org/dl/)# 验证安装$ go versiongo version go1.22.0 darwin/amd64# 设置GOPATH和GOROOT（现代Go版本通常不需要手动设置）$ go env GOPATH/Users/username/go 2. 创建项目12345678# 创建项目目录$ mkdir gin-demo &amp;&amp; cd gin-demo# 初始化Go模块$ go mod init gin-demo# 安装Gin框架（推荐使用Go Modules）$ go get github.com/gin-gonic/gin@latest 3. 开发工具推荐 VS Code + Go插件 GoLand (JetBrains IDE) Goland (社区版) Go语言基础（对比JavaScript/TypeScript）变量声明差异123456789101112131415// Go语言package mainimport &quot;fmt&quot;func main() &#123; // 变量声明（类型在后） var name string = &quot;Gin&quot; age := 25 // 类型推断 // 常量 const version = &quot;1.0.0&quot; fmt.Println(name, age, version)&#125; 123456// JavaScript对比const name = &quot;Gin&quot;;let age = 25;const version = &quot;1.0.0&quot;;console.log(name, age, version); 函数定义差异1234567891011121314151617181920// Go语言函数func add(a int, b int) int &#123; return a + b&#125;// 多返回值func divide(a, b float64) (float64, error) &#123; if b == 0 &#123; return 0, fmt.Errorf(&quot;除数不能为零&quot;) &#125; return a / b, nil&#125;// 匿名函数func main() &#123; square := func(x int) int &#123; return x * x &#125; fmt.Println(square(5))&#125; 12345678910111213141516// JavaScript函数对比function add(a, b) &#123; return a + b;&#125;// 现代JS（箭头函数）const divide = (a, b) =&gt; &#123; if (b === 0) &#123; throw new Error(&quot;除数不能为零&quot;); &#125; return a / b;&#125;;// 匿名函数const square = (x) =&gt; x * x;console.log(square(5)); 错误处理差异123456789101112131415161718// Go语言错误处理func readFile(filename string) error &#123; data, err := os.ReadFile(filename) if err != nil &#123; return fmt.Errorf(&quot;读取文件失败: %v&quot;, err) &#125; // 处理数据 fmt.Println(string(data)) return nil&#125;// 使用错误func main() &#123; if err := readFile(&quot;config.yaml&quot;); err != nil &#123; log.Fatal(err) &#125;&#125; 1234567891011121314// JavaScript错误处理（async/await）async function readFile(filename) &#123; try &#123; const data = await fs.promises.readFile(filename, &#x27;utf8&#x27;); console.log(data); &#125; catch (error) &#123; throw new Error(`读取文件失败: $&#123;error.message&#125;`); &#125;&#125;// 使用readFile(&#x27;config.yaml&#x27;).catch(error =&gt; &#123; console.error(error);&#125;); Gin框架基础1. 第一个Gin应用12345678910111213141516171819// main.gopackage mainimport &quot;github.com/gin-gonic/gin&quot;func main() &#123; // 创建Gin实例（类似Express的app = express()） r := gin.Default() // 定义路由（对比Express的app.get()） r.GET(&quot;/&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;Hello Gin!&quot;, &#125;) &#125;) // 启动服务器（默认端口8080） r.Run() // 相当于 app.listen(8080)&#125; 2. 路由定义对比123456789101112131415161718192021222324// Gin路由定义r.GET(&quot;/users&quot;, getUsers)r.POST(&quot;/users&quot;, createUser)r.PUT(&quot;/users/:id&quot;, updateUser)r.DELETE(&quot;/users/:id&quot;, deleteUser)// 路由组（类似Express的Router）api := r.Group(&quot;/api&quot;)&#123; api.GET(&quot;/users&quot;, getUsers) api.POST(&quot;/users&quot;, createUser)&#125;// 路径参数r.GET(&quot;/users/:id&quot;, func(c *gin.Context) &#123; id := c.Param(&quot;id&quot;) // 类似Express的req.params.id c.JSON(200, gin.H&#123;&quot;id&quot;: id&#125;)&#125;)// 查询参数r.GET(&quot;/search&quot;, func(c *gin.Context) &#123; query := c.Query(&quot;q&quot;) // 类似Express的req.query.q c.JSON(200, gin.H&#123;&quot;query&quot;: query&#125;)&#125;) 1234567891011121314151617181920212223// Express对比app.get(&#x27;/users&#x27;, getUsers);app.post(&#x27;/users&#x27;, createUser);app.put(&#x27;/users/:id&#x27;, updateUser);app.delete(&#x27;/users/:id&#x27;, deleteUser);// 路由组const apiRouter = express.Router();apiRouter.get(&#x27;/users&#x27;, getUsers);apiRouter.post(&#x27;/users&#x27;, createUser);app.use(&#x27;/api&#x27;, apiRouter);// 路径参数app.get(&#x27;/users/:id&#x27;, (req, res) =&gt; &#123; const id = req.params.id; res.json(&#123; id &#125;);&#125;);// 查询参数app.get(&#x27;/search&#x27;, (req, res) =&gt; &#123; const query = req.query.q; res.json(&#123; query &#125;);&#125;); 3. 请求和响应处理123456789101112131415161718192021222324252627282930313233343536373839404142434445// 请求体解析（JSON）type User struct &#123; Name string `json:&quot;name&quot; binding:&quot;required&quot;` Email string `json:&quot;email&quot; binding:&quot;required,email&quot;`&#125;r.POST(&quot;/users&quot;, func(c *gin.Context) &#123; var user User // 绑定JSON（类似Express的body-parser） if err := c.ShouldBindJSON(&amp;user); err != nil &#123; c.JSON(400, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; c.JSON(201, gin.H&#123;&quot;user&quot;: user&#125;)&#125;)// 文件上传r.POST(&quot;/upload&quot;, func(c *gin.Context) &#123; file, err := c.FormFile(&quot;file&quot;) if err != nil &#123; c.JSON(400, gin.H&#123;&quot;error&quot;: &quot;文件上传失败&quot;&#125;) return &#125; // 保存文件 c.SaveUploadedFile(file, &quot;./uploads/&quot;+file.Filename) c.JSON(200, gin.H&#123;&quot;message&quot;: &quot;文件上传成功&quot;&#125;)&#125;)// 响应类型r.GET(&quot;/response&quot;, func(c *gin.Context) &#123; // JSON响应 c.JSON(200, gin.H&#123;&quot;type&quot;: &quot;json&quot;&#125;) // 字符串响应 c.String(200, &quot;Hello World&quot;) // HTML响应 c.HTML(200, &quot;index.html&quot;, gin.H&#123;&quot;title&quot;: &quot;Gin&quot;&#125;) // 文件下载 c.File(&quot;./downloads/file.zip&quot;)&#125;) 中间件系统1. 内置中间件12345678910111213141516171819202122232425262728293031func main() &#123; r := gin.New() // 使用默认中间件（日志和恢复） r.Use(gin.Logger(), gin.Recovery()) // 静态文件服务（类似Express的express.static()） r.Static(&quot;/static&quot;, &quot;./public&quot;) // 单个路由中间件 r.GET(&quot;/admin&quot;, authMiddleware(), adminHandler) r.Run()&#125;// 自定义中间件（类似Express的(req, res, next)）func authMiddleware() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; token := c.GetHeader(&quot;Authorization&quot;) if token == &quot;&quot; &#123; c.JSON(401, gin.H&#123;&quot;error&quot;: &quot;未授权&quot;&#125;) c.Abort() // 类似Express的next()但用于终止 return &#125; // 验证token逻辑 c.Set(&quot;user&quot;, &quot;authenticated-user&quot;) // 类似Express的req.user c.Next() // 继续执行下一个中间件/处理器 &#125;&#125; 2. 中间件执行顺序1234567891011121314151617181920212223func main() &#123; r := gin.New() // 全局中间件（按添加顺序执行） r.Use(loggerMiddleware) r.Use(authMiddleware) // 路由组中间件 admin := r.Group(&quot;/admin&quot;) admin.Use(adminAuthMiddleware) &#123; admin.GET(&quot;/dashboard&quot;, dashboardHandler) &#125; r.Run()&#125;func loggerMiddleware(c *gin.Context) &#123; start := time.Now() c.Next() latency := time.Since(start) log.Printf(&quot;请求 %s 耗时 %v&quot;, c.Request.URL.Path, latency)&#125; 数据库操作1. 多数据库连接配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// config/database.gopackage configimport ( &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/driver/postgres&quot; &quot;gorm.io/driver/sqlite&quot; &quot;gorm.io/gorm&quot;)type DatabaseConfig struct &#123; Driver string `yaml:&quot;driver&quot;` Host string `yaml:&quot;host&quot;` Port string `yaml:&quot;port&quot;` Username string `yaml:&quot;username&quot;` Password string `yaml:&quot;password&quot;` Database string `yaml:&quot;database&quot;`&#125;func ConnectDB(config DatabaseConfig) (*gorm.DB, error) &#123; var dialector gorm.Dialector switch config.Driver &#123; case &quot;mysql&quot;: dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;, config.Username, config.Password, config.Host, config.Port, config.Database) dialector = mysql.Open(dsn) case &quot;postgres&quot;: dsn := fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=disable&quot;, config.Host, config.Username, config.Password, config.Database, config.Port) dialector = postgres.Open(dsn) case &quot;sqlite&quot;: dialector = sqlite.Open(config.Database) default: return nil, fmt.Errorf(&quot;不支持的数据库驱动: %s&quot;, config.Driver) &#125; return gorm.Open(dialector, &amp;gorm.Config&#123;&#125;)&#125;// 多数据库连接var ( PrimaryDB *gorm.DB ReadOnlyDB *gorm.DB AnalyticsDB *gorm.DB)func InitDatabases() error &#123; var err error // 主数据库（读写） PrimaryDB, err = ConnectDB(DatabaseConfig&#123; Driver: &quot;mysql&quot;, Host: &quot;localhost&quot;, Port: &quot;3306&quot;, Username: &quot;root&quot;, Password: &quot;password&quot;, Database: &quot;primary_db&quot;, &#125;) // 只读数据库副本 ReadOnlyDB, err = ConnectDB(DatabaseConfig&#123; Driver: &quot;mysql&quot;, Host: &quot;readonly-host&quot;, Port: &quot;3306&quot;, Username: &quot;readonly_user&quot;, Password: &quot;password&quot;, Database: &quot;primary_db&quot;, &#125;) // 分析数据库 AnalyticsDB, err = ConnectDB(DatabaseConfig&#123; Driver: &quot;postgres&quot;, Host: &quot;analytics-host&quot;, Port: &quot;5432&quot;, Username: &quot;analytics_user&quot;, Password: &quot;password&quot;, Database: &quot;analytics_db&quot;, &#125;) return err&#125; 2. 模型定义和CRUD操作1234567891011121314151617181920212223242526272829303132333435// models/user.gopackage modelsimport ( &quot;gorm.io/gorm&quot; &quot;time&quot;)type User struct &#123; ID uint `gorm:&quot;primaryKey&quot; json:&quot;id&quot;` Name string `gorm:&quot;size:100;not null&quot; json:&quot;name&quot;` Email string `gorm:&quot;size:255;uniqueIndex;not null&quot; json:&quot;email&quot;` Password string `gorm:&quot;size:255;not null&quot; json:&quot;-&quot;` // 不序列化到JSON Age int `gorm:&quot;default:0&quot; json:&quot;age&quot;` CreatedAt time.Time `json:&quot;created_at&quot;` UpdatedAt time.Time `json:&quot;updated_at&quot;` DeletedAt gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#125;// 用户表名func (User) TableName() string &#123; return &quot;users&quot;&#125;// 业务逻辑方法func (u *User) BeforeCreate(tx *gorm.DB) error &#123; u.CreatedAt = time.Now() u.UpdatedAt = time.Now() return nil&#125;func (u *User) BeforeUpdate(tx *gorm.DB) error &#123; u.UpdatedAt = time.Now() return nil&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// handlers/user.gopackage handlersimport ( &quot;gin-demo/models&quot; &quot;net/http&quot; &quot;strconv&quot; &quot;github.com/gin-gonic/gin&quot; &quot;gorm.io/gorm&quot;)type UserHandler struct &#123; DB *gorm.DB&#125;func NewUserHandler(db *gorm.DB) *UserHandler &#123; return &amp;UserHandler&#123;DB: db&#125;&#125;// 获取用户列表（GET /users）func (h *UserHandler) GetUsers(c *gin.Context) &#123; var users []models.User // 分页参数 page, _ := strconv.Atoi(c.DefaultQuery(&quot;page&quot;, &quot;1&quot;)) limit, _ := strconv.Atoi(c.DefaultQuery(&quot;limit&quot;, &quot;10&quot;)) offset := (page - 1) * limit // 查询 result := h.DB.Offset(offset).Limit(limit).Find(&amp;users) if result.Error != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: &quot;查询失败&quot;&#125;) return &#125; // 获取总数 var total int64 h.DB.Model(&amp;models.User&#123;&#125;).Count(&amp;total) c.JSON(http.StatusOK, gin.H&#123; &quot;users&quot;: users, &quot;pagination&quot;: gin.H&#123; &quot;page&quot;: page, &quot;limit&quot;: limit, &quot;total&quot;: total, &#125;, &#125;)&#125;// 获取单个用户（GET /users/:id）func (h *UserHandler) GetUser(c *gin.Context) &#123; id, err := strconv.Atoi(c.Param(&quot;id&quot;)) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: &quot;无效的用户ID&quot;&#125;) return &#125; var user models.User result := h.DB.First(&amp;user, id) if result.Error != nil &#123; if result.Error == gorm.ErrRecordNotFound &#123; c.JSON(http.StatusNotFound, gin.H&#123;&quot;error&quot;: &quot;用户不存在&quot;&#125;) &#125; else &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: &quot;查询失败&quot;&#125;) &#125; return &#125; c.JSON(http.StatusOK, gin.H&#123;&quot;user&quot;: user&#125;)&#125;// 创建用户（POST /users）func (h *UserHandler) CreateUser(c *gin.Context) &#123; var user models.User if err := c.ShouldBindJSON(&amp;user); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; // 密码加密（在实际项目中应该使用bcrypt） // user.Password = hashPassword(user.Password) result := h.DB.Create(&amp;user) if result.Error != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: &quot;创建用户失败&quot;&#125;) return &#125; c.JSON(http.StatusCreated, gin.H&#123;&quot;user&quot;: user&#125;)&#125;// 更新用户（PUT /users/:id）func (h *UserHandler) UpdateUser(c *gin.Context) &#123; id, err := strconv.Atoi(c.Param(&quot;id&quot;)) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: &quot;无效的用户ID&quot;&#125;) return &#125; var user models.User result := h.DB.First(&amp;user, id) if result.Error != nil &#123; c.JSON(http.StatusNotFound, gin.H&#123;&quot;error&quot;: &quot;用户不存在&quot;&#125;) return &#125; var updateData map[string]interface&#123;&#125; if err := c.ShouldBindJSON(&amp;updateData); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; // 更新用户 h.DB.Model(&amp;user).Updates(updateData) c.JSON(http.StatusOK, gin.H&#123;&quot;user&quot;: user&#125;)&#125;// 删除用户（DELETE /users/:id）func (h *UserHandler) DeleteUser(c *gin.Context) &#123; id, err := strconv.Atoi(c.Param(&quot;id&quot;)) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: &quot;无效的用户ID&quot;&#125;) return &#125; result := h.DB.Delete(&amp;models.User&#123;&#125;, id) if result.Error != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: &quot;删除失败&quot;&#125;) return &#125; if result.RowsAffected == 0 &#123; c.JSON(http.StatusNotFound, gin.H&#123;&quot;error&quot;: &quot;用户不存在&quot;&#125;) return &#125; c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;用户删除成功&quot;&#125;)&#125; JWT认证和加密1. JWT工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// utils/jwt.gopackage utilsimport ( &quot;time&quot; &quot;github.com/golang-jwt/jwt/v5&quot;)var jwtSecret = []byte(&quot;your-secret-key&quot;)type Claims struct &#123; UserID uint `json:&quot;user_id&quot;` jwt.RegisteredClaims&#125;// 生成JWT Tokenfunc GenerateToken(userID uint) (string, error) &#123; nowTime := time.Now() expireTime := nowTime.Add(24 * time.Hour) claims := Claims&#123; UserID: userID, RegisteredClaims: jwt.RegisteredClaims&#123; ExpiresAt: jwt.NewNumericDate(expireTime), IssuedAt: jwt.NewNumericDate(nowTime), Issuer: &quot;gin-demo&quot;, &#125;, &#125; tokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) token, err := tokenClaims.SignedString(jwtSecret) return token, err&#125;// 解析JWT Tokenfunc ParseToken(token string) (*Claims, error) &#123; tokenClaims, err := jwt.ParseWithClaims(token, &amp;Claims&#123;&#125;, func(token *jwt.Token) (interface&#123;&#125;, error) &#123; return jwtSecret, nil &#125;) if tokenClaims != nil &#123; if claims, ok := tokenClaims.Claims.(*Claims); ok &amp;&amp; tokenClaims.Valid &#123; return claims, nil &#125; &#125; return nil, err&#125;// 验证Tokenfunc ValidateToken(token string) bool &#123; claims, err := ParseToken(token) if err != nil &#123; return false &#125; // 检查token是否过期 return claims.ExpiresAt.Time.After(time.Now())&#125; 2. 密码加密工具123456789101112131415161718// utils/password.gopackage utilsimport ( &quot;golang.org/x/crypto/bcrypt&quot;)// 加密密码func HashPassword(password string) (string, error) &#123; bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost) return string(bytes), err&#125;// 验证密码func CheckPasswordHash(password, hash string) bool &#123; err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) return err == nil&#125; 3. 认证中间件123456789101112131415161718192021222324252627282930313233343536373839404142// middleware/auth.gopackage middlewareimport ( &quot;gin-demo/utils&quot; &quot;net/http&quot; &quot;strings&quot; &quot;github.com/gin-gonic/gin&quot;)func JWTAuth() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; // 从Header获取token authHeader := c.GetHeader(&quot;Authorization&quot;) if authHeader == &quot;&quot; &#123; c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;error&quot;: &quot;请提供认证token&quot;&#125;) c.Abort() return &#125; // 检查Bearer格式 parts := strings.SplitN(authHeader, &quot; &quot;, 2) if !(len(parts) == 2 &amp;&amp; parts[0] == &quot;Bearer&quot;) &#123; c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;error&quot;: &quot;token格式错误&quot;&#125;) c.Abort() return &#125; // 解析token claims, err := utils.ParseToken(parts[1]) if err != nil &#123; c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;error&quot;: &quot;无效的token&quot;&#125;) c.Abort() return &#125; // 将用户信息存入上下文 c.Set(&quot;userID&quot;, claims.UserID) c.Next() &#125;&#125; 4. 认证路由123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// handlers/auth.gopackage handlersimport ( &quot;gin-demo/models&quot; &quot;gin-demo/utils&quot; &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot; &quot;gorm.io/gorm&quot;)type AuthHandler struct &#123; DB *gorm.DB&#125;func NewAuthHandler(db *gorm.DB) *AuthHandler &#123; return &amp;AuthHandler&#123;DB: db&#125;&#125;// 注册func (h *AuthHandler) Register(c *gin.Context) &#123; var user models.User if err := c.ShouldBindJSON(&amp;user); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; // 检查邮箱是否已存在 var existingUser models.User if err := h.DB.Where(&quot;email = ?&quot;, user.Email).First(&amp;existingUser).Error; err == nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: &quot;邮箱已存在&quot;&#125;) return &#125; // 加密密码 hashedPassword, err := utils.HashPassword(user.Password) if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: &quot;密码加密失败&quot;&#125;) return &#125; user.Password = hashedPassword // 创建用户 if err := h.DB.Create(&amp;user).Error; err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: &quot;创建用户失败&quot;&#125;) return &#125; c.JSON(http.StatusCreated, gin.H&#123; &quot;message&quot;: &quot;注册成功&quot;, &quot;user&quot;: gin.H&#123; &quot;id&quot;: user.ID, &quot;name&quot;: user.Name, &quot;email&quot;: user.Email, &#125;, &#125;)&#125;// 登录func (h *AuthHandler) Login(c *gin.Context) &#123; var loginData struct &#123; Email string `json:&quot;email&quot; binding:&quot;required,email&quot;` Password string `json:&quot;password&quot; binding:&quot;required&quot;` &#125; if err := c.ShouldBindJSON(&amp;loginData); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;) return &#125; // 查找用户 var user models.User if err := h.DB.Where(&quot;email = ?&quot;, loginData.Email).First(&amp;user).Error; err != nil &#123; c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;error&quot;: &quot;邮箱或密码错误&quot;&#125;) return &#125; // 验证密码 if !utils.CheckPasswordHash(loginData.Password, user.Password) &#123; c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;error&quot;: &quot;邮箱或密码错误&quot;&#125;) return &#125; // 生成token token, err := utils.GenerateToken(user.ID) if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: &quot;token生成失败&quot;&#125;) return &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;message&quot;: &quot;登录成功&quot;, &quot;token&quot;: token, &quot;user&quot;: gin.H&#123; &quot;id&quot;: user.ID, &quot;name&quot;: user.Name, &quot;email&quot;: user.Email, &#125;, &#125;)&#125;// 获取当前用户信息func (h *AuthHandler) GetCurrentUser(c *gin.Context) &#123; userID, exists := c.Get(&quot;userID&quot;) if !exists &#123; c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;error&quot;: &quot;未认证&quot;&#125;) return &#125; var user models.User if err := h.DB.First(&amp;user, userID).Error; err != nil &#123; c.JSON(http.StatusNotFound, gin.H&#123;&quot;error&quot;: &quot;用户不存在&quot;&#125;) return &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;user&quot;: gin.H&#123; &quot;id&quot;: user.ID, &quot;name&quot;: user.Name, &quot;email&quot;: user.Email, &#125;, &#125;)&#125; 项目结构和配置1. 完整的项目结构123456789101112131415161718192021222324252627gin-demo/├── main.go # 应用入口├── go.mod # Go模块文件├── go.sum # 依赖校验├── config/│ ├── config.go # 配置文件│ └── database.go # 数据库配置├── models/│ ├── user.go # 用户模型│ └── product.go # 产品模型├── handlers/│ ├── user.go # 用户处理器│ ├── auth.go # 认证处理器│ └── product.go # 产品处理器├── middleware/│ ├── auth.go # 认证中间件│ ├── logger.go # 日志中间件│ └── cors.go # CORS中间件├── utils/│ ├── jwt.go # JWT工具│ ├── password.go # 密码工具│ └── response.go # 响应工具├── routes/│ └── routes.go # 路由定义└── tests/ ├── user_test.go # 用户测试 └── auth_test.go # 认证测试 2. 配置文件123456789101112131415161718192021222324252627282930313233343536373839// config/config.gopackage configimport ( &quot;log&quot; &quot;os&quot; &quot;strconv&quot; &quot;github.com/joho/godotenv&quot;)type Config struct &#123; AppPort string DatabaseURL string JWTSecret string DebugMode bool&#125;func LoadConfig() *Config &#123; // 加载.env文件（开发环境） if err := godotenv.Load(); err != nil &#123; log.Println(&quot;未找到.env文件，使用环境变量&quot;) &#125; debugMode, _ := strconv.ParseBool(getEnv(&quot;DEBUG&quot;, &quot;false&quot;)) return &amp;Config&#123; AppPort: getEnv(&quot;APP_PORT&quot;, &quot;8080&quot;), DatabaseURL: getEnv(&quot;DATABASE_URL&quot;, &quot;root:password@tcp(localhost:3306)/gin_demo&quot;), JWTSecret: getEnv(&quot;JWT_SECRET&quot;, &quot;your-secret-key&quot;), DebugMode: debugMode, &#125;&#125;func getEnv(key, defaultValue string) string &#123; if value := os.Getenv(key); value != &quot;&quot; &#123; return value &#125; return defaultValue&#125; 3. 路由定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// routes/routes.gopackage routesimport ( &quot;gin-demo/config&quot; &quot;gin-demo/handlers&quot; &quot;gin-demo/middleware&quot; &quot;github.com/gin-gonic/gin&quot; &quot;gorm.io/gorm&quot;)func SetupRoutes(router *gin.Engine, db *gorm.DB, cfg *config.Config) &#123; // 初始化处理器 userHandler := handlers.NewUserHandler(db) authHandler := handlers.NewAuthHandler(db) // 公共路由 public := router.Group(&quot;/api&quot;) &#123; // 认证路由 auth := public.Group(&quot;/auth&quot;) &#123; auth.POST(&quot;/register&quot;, authHandler.Register) auth.POST(&quot;/login&quot;, authHandler.Login) &#125; // 公开的用户路由 public.GET(&quot;/users&quot;, userHandler.GetUsers) public.GET(&quot;/users/:id&quot;, userHandler.GetUser) &#125; // 需要认证的路由 protected := public.Group(&quot;&quot;) protected.Use(middleware.JWTAuth()) &#123; // 用户管理 users := protected.Group(&quot;/users&quot;) &#123; users.POST(&quot;&quot;, userHandler.CreateUser) users.PUT(&quot;/:id&quot;, userHandler.UpdateUser) users.DELETE(&quot;/:id&quot;, userHandler.DeleteUser) &#125; // 获取当前用户 protected.GET(&quot;/me&quot;, authHandler.GetCurrentUser) &#125; // 健康检查 router.GET(&quot;/health&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123;&quot;status&quot;: &quot;ok&quot;&#125;) &#125;)&#125; 4. 主程序入口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// main.gopackage mainimport ( &quot;gin-demo/config&quot; &quot;gin-demo/models&quot; &quot;gin-demo/routes&quot; &quot;log&quot; &quot;github.com/gin-gonic/gin&quot; &quot;gorm.io/gorm&quot;)func main() &#123; // 加载配置 cfg := config.LoadConfig() // 设置Gin模式 if cfg.DebugMode &#123; gin.SetMode(gin.DebugMode) &#125; else &#123; gin.SetMode(gin.ReleaseMode) &#125; // 创建Gin实例 router := gin.Default() // 连接数据库 db, err := config.ConnectDB() if err != nil &#123; log.Fatal(&quot;数据库连接失败:&quot;, err) &#125; // 自动迁移（开发环境） if cfg.DebugMode &#123; err = db.AutoMigrate(&amp;models.User&#123;&#125;) if err != nil &#123; log.Fatal(&quot;数据库迁移失败:&quot;, err) &#125; &#125; // 设置路由 routes.SetupRoutes(router, db, cfg) // 启动服务器 log.Printf(&quot;服务器启动在端口 %s&quot;, cfg.AppPort) if err := router.Run(&quot;:&quot; + cfg.AppPort); err != nil &#123; log.Fatal(&quot;服务器启动失败:&quot;, err) &#125;&#125; 测试和部署1. 单元测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// tests/user_test.gopackage testsimport ( &quot;gin-demo/handlers&quot; &quot;gin-demo/models&quot; &quot;net/http&quot; &quot;net/http/httptest&quot; &quot;testing&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/stretchr/testify/assert&quot; &quot;gorm.io/driver/sqlite&quot; &quot;gorm.io/gorm&quot;)func setupTestDB() *gorm.DB &#123; db, err := gorm.Open(sqlite.Open(&quot;:memory:&quot;), &amp;gorm.Config&#123;&#125;) if err != nil &#123; panic(&quot;测试数据库连接失败&quot;) &#125; // 迁移表 db.AutoMigrate(&amp;models.User&#123;&#125;) return db&#125;func TestGetUsers(t *testing.T) &#123; // 设置测试数据库 db := setupTestDB() // 创建测试数据 db.Create(&amp;models.User&#123;Name: &quot;测试用户&quot;, Email: &quot;test@example.com&quot;&#125;) // 创建处理器 handler := handlers.NewUserHandler(db) // 创建Gin测试上下文 w := httptest.NewRecorder() c, _ := gin.CreateTestContext(w) // 执行处理器 handler.GetUsers(c) // 验证响应 assert.Equal(t, http.StatusOK, w.Code) assert.Contains(t, w.Body.String(), &quot;测试用户&quot;)&#125;func TestCreateUser(t *testing.T) &#123; db := setupTestDB() handler := handlers.NewUserHandler(db) w := httptest.NewRecorder() c, _ := gin.CreateTestContext(w) // 设置JSON请求体 c.Request = httptest.NewRequest(&quot;POST&quot;, &quot;/users&quot;, strings.NewReader(`&#123;&quot;name&quot;:&quot;新用户&quot;,&quot;email&quot;:&quot;new@example.com&quot;&#125;`)) c.Request.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;) handler.CreateUser(c) assert.Equal(t, http.StatusCreated, w.Code) assert.Contains(t, w.Body.String(), &quot;新用户&quot;)&#125; 2. 集成测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// tests/integration_test.gopackage testsimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;net/http&quot; &quot;net/http/httptest&quot; &quot;testing&quot; &quot;gin-demo/main&quot; &quot;github.com/stretchr/testify/assert&quot;)func TestUserCRUDIntegration(t *testing.T) &#123; // 启动测试服务器 router := main.SetupRouter() // 测试创建用户 userData := map[string]interface&#123;&#125;&#123; &quot;name&quot;: &quot;集成测试用户&quot;, &quot;email&quot;: &quot;integration@test.com&quot;, &#125; jsonData, _ := json.Marshal(userData) req, _ := http.NewRequest(&quot;POST&quot;, &quot;/api/users&quot;, bytes.NewBuffer(jsonData)) req.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;) w := httptest.NewRecorder() router.ServeHTTP(w, req) assert.Equal(t, http.StatusCreated, w.Code) // 解析响应获取用户ID var response map[string]interface&#123;&#125; json.Unmarshal(w.Body.Bytes(), &amp;response) user := response[&quot;user&quot;].(map[string]interface&#123;&#125;) userID := user[&quot;id&quot;].(float64) // 测试获取用户 req, _ = http.NewRequest(&quot;GET&quot;, fmt.Sprintf(&quot;/api/users/%.0f&quot;, userID), nil) w = httptest.NewRecorder() router.ServeHTTP(w, req) assert.Equal(t, http.StatusOK, w.Code) assert.Contains(t, w.Body.String(), &quot;集成测试用户&quot;)&#125; 3. Docker部署配置1234567891011121314151617181920212223242526272829303132333435363738# DockerfileFROM golang:1.22-alpine AS builder# 安装必要的工具RUN apk add --no-cache git# 设置工作目录WORKDIR /app# 复制依赖文件COPY go.mod go.sum ./# 下载依赖RUN go mod download# 复制源代码COPY . .# 构建应用RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .# 运行阶段FROM alpine:latestRUN apk --no-cache add ca-certificatesWORKDIR /root/# 从构建阶段复制二进制文件COPY --from=builder /app/main .# 复制配置文件COPY config/config.yaml ./# 暴露端口EXPOSE 8080# 运行应用CMD [&quot;./main&quot;] 12345678910111213141516171819202122232425262728# docker-compose.ymlversion: &#x27;3.8&#x27;services: app: build: . ports: - &quot;8080:8080&quot; environment: - DATABASE_URL=mysql://user:password@db:3306/gin_demo - JWT_SECRET=your-secret-key depends_on: - db db: image: mysql:8.0 environment: MYSQL_ROOT_PASSWORD: rootpassword MYSQL_DATABASE: gin_demo MYSQL_USER: user MYSQL_PASSWORD: password ports: - &quot;3306:3306&quot; volumes: - db_data:/var/lib/mysqlvolumes: db_data: 4. 环境配置1234567891011121314151617181920# config/config.yamlapp: port: &quot;8080&quot; env: &quot;production&quot; debug: falsedatabase: host: &quot;localhost&quot; port: &quot;3306&quot; username: &quot;user&quot; password: &quot;password&quot; name: &quot;gin_demo&quot;jwt: secret: &quot;your-production-secret-key&quot; expires_in: &quot;24h&quot;logging: level: &quot;info&quot; file: &quot;./logs/app.log&quot; 12345# .env.exampleAPP_PORT=8080DATABASE_URL=mysql://user:password@localhost:3306/gin_demoJWT_SECRET=your-secret-keyDEBUG=false 性能优化和最佳实践1. 连接池配置1234567891011121314151617181920212223242526272829303132// config/database.go (扩展)import &quot;gorm.io/gorm&quot;import &quot;gorm.io/driver/mysql&quot;func ConnectDBWithPool(config DatabaseConfig) (*gorm.DB, error) &#123; dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;, config.Username, config.Password, config.Host, config.Port, config.Database) db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123; // 禁用默认事务（提高性能） SkipDefaultTransaction: true, // 预编译SQL PrepareStmt: true, &#125;) if err != nil &#123; return nil, err &#125; // 获取底层sql.DB设置连接池 sqlDB, err := db.DB() if err != nil &#123; return nil, err &#125; // 设置连接池参数 sqlDB.SetMaxIdleConns(10) // 最大空闲连接数 sqlDB.SetMaxOpenConns(100) // 最大打开连接数 sqlDB.SetConnMaxLifetime(time.Hour) // 连接最大生命周期 return db, nil&#125; 2. 缓存策略12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// utils/cache.gopackage utilsimport ( &quot;context&quot; &quot;time&quot; &quot;github.com/go-redis/redis/v8&quot;)type Cache struct &#123; client *redis.Client ctx context.Context&#125;func NewCache(addr, password string, db int) *Cache &#123; client := redis.NewClient(&amp;redis.Options&#123; Addr: addr, Password: password, DB: db, &#125;) return &amp;Cache&#123; client: client, ctx: context.Background(), &#125;&#125;// 设置缓存func (c *Cache) Set(key string, value interface&#123;&#125;, expiration time.Duration) error &#123; return c.client.Set(c.ctx, key, value, expiration).Err()&#125;// 获取缓存func (c *Cache) Get(key string) (string, error) &#123; return c.client.Get(c.ctx, key).Result()&#125;// 删除缓存func (c *Cache) Delete(key string) error &#123; return c.client.Del(c.ctx, key).Err()&#125;// 缓存用户信息示例func CacheUser(user models.User, cache *Cache) error &#123; userJSON, err := json.Marshal(user) if err != nil &#123; return err &#125; return cache.Set(&quot;user:&quot;+strconv.FormatUint(uint64(user.ID), 10), userJSON, 30*time.Minute)&#125; 3. 性能监控123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// middleware/metrics.gopackage middlewareimport ( &quot;github.com/gin-gonic/gin&quot; &quot;github.com/prometheus/client_golang/prometheus&quot; &quot;github.com/prometheus/client_golang/prometheus/promhttp&quot; &quot;time&quot;)var ( requestDuration = prometheus.NewHistogramVec( prometheus.HistogramOpts&#123; Name: &quot;http_request_duration_seconds&quot;, Help: &quot;HTTP请求耗时&quot;, &#125;, []string&#123;&quot;method&quot;, &quot;endpoint&quot;&#125;, ) requestCount = prometheus.NewCounterVec( prometheus.CounterOpts&#123; Name: &quot;http_requests_total&quot;, Help: &quot;HTTP请求总数&quot;, &#125;, []string&#123;&quot;method&quot;, &quot;endpoint&quot;, &quot;status&quot;&#125;, ))func init() &#123; prometheus.MustRegister(requestDuration, requestCount)&#125;func MetricsMiddleware() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; start := time.Now() // 继续处理请求 c.Next() duration := time.Since(start).Seconds() status := c.Writer.Status() // 记录指标 requestDuration.WithLabelValues( c.Request.Method, c.FullPath(), ).Observe(duration) requestCount.WithLabelValues( c.Request.Method, c.FullPath(), strconv.Itoa(status), ).Inc() &#125;&#125;// 暴露指标端点func MetricsHandler() gin.HandlerFunc &#123; h := promhttp.Handler() return func(c *gin.Context) &#123; h.ServeHTTP(c.Writer, c.Request) &#125;&#125; 总结Gin框架优势 高性能: 基于Go语言的并发特性，性能远超Node.js框架 简洁API: 类似Express的直观API设计，学习成本低 丰富中间件: 内置常用中间件，生态完善 强类型: Go语言的类型安全减少运行时错误 从Node.js迁移建议 错误处理: Go使用显式错误返回，替代JS的try-catch 并发模型: 理解goroutine和channel，替代async/await 类型系统: 充分利用Go的强类型优势 依赖管理: 使用Go Modules替代npm 下一步学习 微服务架构: 学习gRPC和微服务通信 容器化部署: 掌握Docker和Kubernetes 监控告警: 集成Prometheus和Grafana CI/CD: 建立自动化部署流程 这份笔记涵盖了Gin框架的核心概念和实际应用，帮助你快速从Node.js开发转向Go语言Web开发。通过实际项目练习，你将能够熟练掌握Gin框架并构建高性能的Web应用。"},{"title":"Vue3基础复习","path":"2025/09/28/Vue3基础复习/","text":"Vue3基础复习Vue3介绍与描述（个人理解） Vue3相比Vue2有更好的性能，更小的打包体积 采用Composition API，提供更好的逻辑复用和代码组织 更好的TypeScript支持 使用Proxy替代Object.defineProperty，响应式系统更强大 支持Tree-shaking，按需引入减少打包体积 新的组件：Fragment、Teleport、Suspense Vue3基础语法创建Vue应用12345import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)app.mount(&#x27;#app&#x27;) 响应式系统ref和reactive1234567891011121314151617&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; state.name &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;// ref用于基本类型const count = ref(0)// reactive用于对象const state = reactive(&#123; name: &#x27;Vue3&#x27;, version: &#x27;3.0&#x27;&#125;)&lt;/script&gt; computed计算属性1234567891011&lt;script setup&gt;import &#123; ref, computed &#125; from &#x27;vue&#x27;const firstName = ref(&#x27;张&#x27;)const lastName = ref(&#x27;三&#x27;)// 计算属性const fullName = computed(() =&gt; &#123; return firstName.value + lastName.value&#125;)&lt;/script&gt; watch和watchEffect12345678910111213141516&lt;script setup&gt;import &#123; ref, watch, watchEffect &#125; from &#x27;vue&#x27;const count = ref(0)const message = ref(&#x27;&#x27;)// watch监听特定数据源watch(count, (newValue, oldValue) =&gt; &#123; console.log(&#x27;count变化:&#x27;, oldValue, &#x27;-&gt;&#x27;, newValue)&#125;)// watchEffect自动追踪依赖watchEffect(() =&gt; &#123; console.log(&#x27;count的值:&#x27;, count.value)&#125;)&lt;/script&gt; Composition API&lt;script setup&gt;语法糖123456789101112131415&lt;template&gt; &lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const title = ref(&#x27;Vue3 Composition API&#x27;)const count = ref(0)const increment = () =&gt; &#123; count.value++&#125;&lt;/script&gt; 生命周期钩子123456789101112131415&lt;script setup&gt;import &#123; onMounted, onUpdated, onUnmounted &#125; from &#x27;vue&#x27;onMounted(() =&gt; &#123; console.log(&#x27;组件挂载完成&#x27;)&#125;)onUpdated(() =&gt; &#123; console.log(&#x27;组件更新完成&#x27;)&#125;)onUnmounted(() =&gt; &#123; console.log(&#x27;组件卸载完成&#x27;)&#125;)&lt;/script&gt; 自定义Hooks1234567891011121314151617// useCounter.jsimport &#123; ref &#125; from &#x27;vue&#x27;export function useCounter(initialValue = 0) &#123; const count = ref(initialValue) const increment = () =&gt; count.value++ const decrement = () =&gt; count.value-- const reset = () =&gt; count.value = initialValue return &#123; count, increment, decrement, reset &#125;&#125; 123456789101112&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;reset&quot;&gt;重置&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useCounter &#125; from &#x27;./useCounter&#x27;const &#123; count, increment, decrement, reset &#125; = useCounter(0)&lt;/script&gt; 组件通信Props（父传子）123456789101112131415161718192021222324252627282930&lt;!-- 子组件 Child.vue --&gt;&lt;template&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; defineProps &#125; from &#x27;vue&#x27;const props = defineProps(&#123; message: String, count: Number&#125;)console.log(props.message)console.log(props.count)&lt;/script&gt;&lt;!-- 父组件 Parent.vue --&gt;&lt;template&gt; &lt;Child :message=&quot;msg&quot; :count=&quot;num&quot; /&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import Child from &#x27;./Child.vue&#x27;const msg = ref(&#x27;Hello Vue3&#x27;)const num = ref(100)&lt;/script&gt; Emits（子传父）123456789101112131415161718192021222324252627&lt;!-- 子组件 Child.vue --&gt;&lt;template&gt; &lt;button @click=&quot;sendMessage&quot;&gt;发送消息&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; defineEmits &#125; from &#x27;vue&#x27;const emit = defineEmits([&#x27;message&#x27;])const sendMessage = () =&gt; &#123; emit(&#x27;message&#x27;, &#x27;来自子组件的消息&#x27;)&#125;&lt;/script&gt;&lt;!-- 父组件 Parent.vue --&gt;&lt;template&gt; &lt;Child @message=&quot;handleMessage&quot; /&gt;&lt;/template&gt;&lt;script setup&gt;import Child from &#x27;./Child.vue&#x27;const handleMessage = (msg) =&gt; &#123; console.log(&#x27;收到消息:&#x27;, msg)&#125;&lt;/script&gt; provide/inject（跨层级通信）1234567891011&lt;!-- 祖先组件 --&gt;&lt;script setup&gt;import &#123; provide, ref &#125; from &#x27;vue&#x27;const theme = ref(&#x27;dark&#x27;)const user = ref(&#123; name: &#x27;张三&#x27;, age: 25 &#125;)// 提供数据provide(&#x27;theme&#x27;, theme)provide(&#x27;user&#x27;, user)&lt;/script&gt; 1234567891011&lt;!-- 后代组件 --&gt;&lt;script setup&gt;import &#123; inject &#125; from &#x27;vue&#x27;// 注入数据const theme = inject(&#x27;theme&#x27;)const user = inject(&#x27;user&#x27;)console.log(theme.value)console.log(user.value.name)&lt;/script&gt; 插槽1234567891011121314151617181920212223242526272829&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;默认头部&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;默认内容&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;默认底部&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;ChildComponent&gt; &lt;template #header&gt; &lt;h1&gt;自定义头部&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;这是主要内容&lt;/p&gt; &lt;template #footer&gt; &lt;footer&gt;自定义底部&lt;/footer&gt; &lt;/template&gt; &lt;/ChildComponent&gt;&lt;/template&gt; 新组件特性Fragment（片段）Vue3支持多个根元素： 12345&lt;template&gt; &lt;header&gt;头部&lt;/header&gt; &lt;main&gt;主体&lt;/main&gt; &lt;footer&gt;底部&lt;/footer&gt;&lt;/template&gt; Teleport（传送）12345678910111213141516&lt;template&gt; &lt;button @click=&quot;showModal = true&quot;&gt;打开模态框&lt;/button&gt; &lt;Teleport to=&quot;body&quot;&gt; &lt;div v-if=&quot;showModal&quot; class=&quot;modal&quot;&gt; &lt;h2&gt;模态框标题&lt;/h2&gt; &lt;button @click=&quot;showModal = false&quot;&gt;关闭&lt;/button&gt; &lt;/div&gt; &lt;/Teleport&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const showModal = ref(false)&lt;/script&gt; Suspense（异步组件）123456789101112131415161718&lt;template&gt; &lt;Suspense&gt; &lt;template #default&gt; &lt;AsyncComponent /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div&gt;加载中...&lt;/div&gt; &lt;/template&gt; &lt;/Suspense&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComponent = defineAsyncComponent(() =&gt; import(&#x27;./AsyncComponent.vue&#x27;))&lt;/script&gt; 路由：Vue Router 4基本配置123456789101112131415161718192021222324// router/index.jsimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;import Home from &#x27;../views/Home.vue&#x27;import About from &#x27;../views/About.vue&#x27;const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: About &#125;]const router = createRouter(&#123; history: createWebHistory(), routes&#125;)export default router 12345678// main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;const app = createApp(App)app.use(router)app.mount(&#x27;#app&#x27;) 路由使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;template&gt; &lt;nav&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt; &lt;router-link to=&quot;/dynamic&quot;&gt;动态路由&lt;/router-link&gt; &lt;/nav&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;const router = useRouter()const route = useRoute()const goToAbout = () =&gt; &#123; router.push(&#x27;/about&#x27;)&#125;// 动态添加路由const addDynamicRoute = () =&gt; &#123; router.addRoute(&#123; path: &#x27;/dynamic&#x27;, name: &#x27;Dynamic&#x27;, component: () =&gt; import(&#x27;../views/Dynamic.vue&#x27;) &#125;) // 跳转到新添加的路由 router.push(&#x27;/dynamic&#x27;)&#125;// 获取当前路由信息console.log(&#x27;当前路由:&#x27;, route.path)console.log(&#x27;路由参数:&#x27;, route.params)console.log(&#x27;查询参数:&#x27;, route.query)// 路由导航方法const navigate = &#123; // 编程式导航 goToHome: () =&gt; router.push(&#x27;/&#x27;), goToAbout: () =&gt; router.push(&#x27;/about&#x27;), // 带参数导航 goToUser: (id) =&gt; router.push(&#123; name: &#x27;User&#x27;, params: &#123; id &#125; &#125;), // 带查询参数 goToSearch: (keyword) =&gt; router.push(&#123; path: &#x27;/search&#x27;, query: &#123; q: keyword &#125; &#125;), // 替换当前路由（不记录历史） replaceHome: () =&gt; router.replace(&#x27;/&#x27;), // 前进后退 goBack: () =&gt; router.go(-1), goForward: () =&gt; router.go(1), // 检查路由是否存在 hasRoute: (name) =&gt; router.hasRoute(name), // 获取路由列表 getRoutes: () =&gt; router.getRoutes()&#125;// 动态路由操作const dynamicRoutes = &#123; // 添加嵌套路由 addNestedRoute: () =&gt; &#123; router.addRoute(&#x27;Home&#x27;, &#123; path: &#x27;settings&#x27;, component: () =&gt; import(&#x27;../views/Settings.vue&#x27;) &#125;) &#125;, // 删除路由 removeRoute: (name) =&gt; &#123; router.removeRoute(name) &#125;, // 添加路由守卫 addGuard: () =&gt; &#123; router.beforeEach((to, from, next) =&gt; &#123; console.log(`路由守卫: $&#123;from.path&#125; -&gt; $&#123;to.path&#125;`) next() &#125;) &#125;&#125;&lt;/script&gt; 路由守卫12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 全局前置守卫router.beforeEach((to, from, next) =&gt; &#123; // 检查用户是否登录 if (to.meta.requiresAuth &amp;&amp; !isLoggedIn()) &#123; next(&#x27;/login&#x27;) &#125; else &#123; next() &#125;&#125;)// 全局后置守卫router.afterEach((to, from) =&gt; &#123; // 页面访问统计 console.log(`从 $&#123;from.path&#125; 跳转到 $&#123;to.path&#125;`)&#125;)// 路由独享守卫const routes = [ &#123; path: &#x27;/admin&#x27;, component: Admin, beforeEnter: (to, from, next) =&gt; &#123; // 检查管理员权限 if (hasAdminPermission()) &#123; next() &#125; else &#123; next(&#x27;/unauthorized&#x27;) &#125; &#125; &#125;]// 组件内守卫const UserProfile = &#123; template: `...`, beforeRouteEnter(to, from, next) &#123; // 在渲染该组件的对应路由被验证前调用 next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 console.log(vm.user) &#125;) &#125;, beforeRouteUpdate(to, from) &#123; // 在当前路由改变，但是该组件被复用时调用 this.userData = fetchUser(to.params.id) &#125;, beforeRouteLeave(to, from) &#123; // 在导航离开该组件的对应路由时调用 const answer = window.confirm(&#x27;确定要离开吗？&#x27;) if (!answer) return false &#125;&#125; 状态管理：Pinia安装和配置1npm install pinia 12345678910// main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)const pinia = createPinia()app.use(pinia)app.mount(&#x27;#app&#x27;) 定义StoreOptions API写法1234567891011121314151617181920212223242526272829303132// stores/counter.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123; state: () =&gt; (&#123; count: 0, name: &#x27;计数器&#x27; &#125;), getters: &#123; doubleCount: (state) =&gt; state.count * 2, doubleCountPlusOne() &#123; return this.doubleCount + 1 &#125; &#125;, actions: &#123; increment() &#123; this.count++ &#125;, async incrementAsync() &#123; // 支持异步操作 await new Promise(resolve =&gt; setTimeout(resolve, 1000)) this.count++ &#125;, reset() &#123; this.count = 0 &#125; &#125;&#125;) Composition API写法12345678910111213141516171819202122232425262728293031323334// stores/counter.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; ref, computed &#125; from &#x27;vue&#x27;export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123; const count = ref(0) const name = ref(&#x27;计数器&#x27;) const doubleCount = computed(() =&gt; count.value * 2) const doubleCountPlusOne = computed(() =&gt; doubleCount.value + 1) function increment() &#123; count.value++ &#125; async function incrementAsync() &#123; await new Promise(resolve =&gt; setTimeout(resolve, 1000)) count.value++ &#125; function reset() &#123; count.value = 0 &#125; return &#123; count, name, doubleCount, doubleCountPlusOne, increment, incrementAsync, reset &#125;&#125;) 使用Store12345678910111213141516&lt;template&gt; &lt;div&gt;&#123;&#123; counterStore.count &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; counterStore.doubleCount &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;counterStore.increment()&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;counterStore.reset()&quot;&gt;重置&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useCounterStore &#125; from &#x27;../stores/counter&#x27;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;const counterStore = useCounterStore()// 响应式解构（保持响应性）const &#123; count, doubleCount &#125; = storeToRefs(counterStore)&lt;/script&gt; Store组合使用12345678910111213141516171819202122// stores/user.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const useUserStore = defineStore(&#x27;user&#x27;, &#123; state: () =&gt; (&#123; user: null, isLoggedIn: false &#125;), actions: &#123; async login(credentials) &#123; // 登录逻辑 this.user = &#123; name: &#x27;用户&#x27;, id: 1 &#125; this.isLoggedIn = true &#125;, logout() &#123; this.user = null this.isLoggedIn = false &#125; &#125;&#125;) 12345678910111213141516// 在另一个store中使用import &#123; useUserStore &#125; from &#x27;./user&#x27;export const useCartStore = defineStore(&#x27;cart&#x27;, &#123; actions: &#123; async checkout() &#123; const userStore = useUserStore() if (!userStore.isLoggedIn) &#123; throw new Error(&#x27;请先登录&#x27;) &#125; // 结账逻辑 &#125; &#125;&#125;) Pinia持久化插件 (pinia-plugin-persistedstate)安装和配置1npm install pinia-plugin-persistedstate 123456789101112131415161718192021222324// main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import &#123; createPersistedState &#125; from &#x27;pinia-plugin-persistedstate&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)const pinia = createPinia()// 使用持久化插件pinia.use(createPersistedState(&#123; // 全局配置 storage: localStorage, // 默认使用localStorage key: id =&gt; `__persisted__$&#123;id&#125;`, // 存储键名格式 beforeRestore: (context) =&gt; &#123; console.log(&#x27;开始恢复状态:&#x27;, context.store.$id) &#125;, afterRestore: (context) =&gt; &#123; console.log(&#x27;状态恢复完成:&#x27;, context.store.$id) &#125;&#125;))app.use(pinia)app.mount(&#x27;#app&#x27;) Store级别的持久化配置12345678910111213141516171819202122232425262728293031323334353637383940414243// stores/user.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const useUserStore = defineStore(&#x27;user&#x27;, &#123; state: () =&gt; (&#123; user: null, isLoggedIn: false, preferences: &#123; theme: &#x27;light&#x27;, language: &#x27;zh-CN&#x27; &#125; &#125;), persist: &#123; // 启用持久化 enabled: true, // 自定义存储策略 strategies: [ &#123; key: &#x27;user-store&#x27;, // 自定义存储键名 storage: localStorage, // 存储介质 paths: [&#x27;user&#x27;, &#x27;isLoggedIn&#x27;, &#x27;preferences&#x27;], // 指定要持久化的字段 &#125; ] &#125;, actions: &#123; async login(credentials) &#123; this.user = &#123; name: &#x27;用户&#x27;, id: 1 &#125; this.isLoggedIn = true &#125;, logout() &#123; this.user = null this.isLoggedIn = false &#125;, updatePreferences(newPrefs) &#123; this.preferences = &#123; ...this.preferences, ...newPrefs &#125; &#125; &#125;&#125;) 组合式Store的持久化1234567891011121314151617181920212223242526272829303132333435// stores/settings.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; ref, computed &#125; from &#x27;vue&#x27;export const useSettingsStore = defineStore(&#x27;settings&#x27;, () =&gt; &#123; const theme = ref(&#x27;light&#x27;) const language = ref(&#x27;zh-CN&#x27;) const fontSize = ref(14) const isDark = computed(() =&gt; theme.value === &#x27;dark&#x27;) function toggleTheme() &#123; theme.value = theme.value === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27; &#125; function setLanguage(lang) &#123; language.value = lang &#125; return &#123; theme, language, fontSize, isDark, toggleTheme, setLanguage &#125;&#125;, &#123; // 持久化配置 persist: &#123; key: &#x27;app-settings&#x27;, storage: localStorage, paths: [&#x27;theme&#x27;, &#x27;language&#x27;, &#x27;fontSize&#x27;] &#125;&#125;) 多种存储策略1234567891011121314151617181920212223242526272829303132333435363738394041// stores/cart.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const useCartStore = defineStore(&#x27;cart&#x27;, &#123; state: () =&gt; (&#123; items: [], total: 0, lastUpdated: null &#125;), persist: &#123; strategies: [ &#123; // 购物车数据使用sessionStorage，关闭浏览器后清除 key: &#x27;cart-session&#x27;, storage: sessionStorage, paths: [&#x27;items&#x27;, &#x27;total&#x27;] &#125;, &#123; // 最后更新时间使用localStorage长期保存 key: &#x27;cart-last-updated&#x27;, storage: localStorage, paths: [&#x27;lastUpdated&#x27;] &#125; ] &#125;, actions: &#123; addItem(item) &#123; this.items.push(item) this.total += item.price this.lastUpdated = new Date().toISOString() &#125;, clearCart() &#123; this.items = [] this.total = 0 this.lastUpdated = new Date().toISOString() &#125; &#125;&#125;) 自定义序列化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// stores/complex.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const useComplexStore = defineStore(&#x27;complex&#x27;, &#123; state: () =&gt; (&#123; // 包含Date对象和Set对象的复杂状态 createdAt: new Date(), tags: new Set([&#x27;vue&#x27;, &#x27;pinia&#x27;]), metadata: new Map([[&#x27;version&#x27;, &#x27;1.0.0&#x27;]]) &#125;), persist: &#123; serializer: &#123; // 自定义序列化 serialize: (value) =&gt; &#123; return JSON.stringify(value, (key, value) =&gt; &#123; if (value instanceof Date) &#123; return &#123; __type: &#x27;Date&#x27;, value: value.toISOString() &#125; &#125; if (value instanceof Set) &#123; return &#123; __type: &#x27;Set&#x27;, value: Array.from(value) &#125; &#125; if (value instanceof Map) &#123; return &#123; __type: &#x27;Map&#x27;, value: Array.from(value.entries()) &#125; &#125; return value &#125;) &#125;, // 自定义反序列化 deserialize: (value) =&gt; &#123; return JSON.parse(value, (key, value) =&gt; &#123; if (value &amp;&amp; value.__type === &#x27;Date&#x27;) &#123; return new Date(value.value) &#125; if (value &amp;&amp; value.__type === &#x27;Set&#x27;) &#123; return new Set(value.value) &#125; if (value &amp;&amp; value.__type === &#x27;Map&#x27;) &#123; return new Map(value.value) &#125; return value &#125;) &#125; &#125; &#125;&#125;) 条件持久化123456789101112131415161718192021222324252627// stores/conditional.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const useConditionalStore = defineStore(&#x27;conditional&#x27;, &#123; state: () =&gt; (&#123; publicData: &#x27;所有人都能看到&#x27;, privateData: &#x27;敏感信息&#x27;, shouldPersist: true &#125;), persist: &#123; enabled: true, // 条件持久化 filter: (persistedState) =&gt; &#123; // 只持久化publicData，过滤掉privateData const &#123; privateData, ...publicState &#125; = persistedState return publicState &#125;, // 运行时条件 condition: (store) =&gt; &#123; // 只有当shouldPersist为true时才持久化 return store.shouldPersist &#125; &#125;&#125;) 指令和修饰符自定义指令123456789101112131415161718192021222324252627&lt;template&gt; &lt;input v-focus /&gt; &lt;div v-color=&quot;&#x27;red&#x27;&quot;&gt;红色文字&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; directive &#125; from &#x27;vue&#x27;export default &#123; directives: &#123; focus: &#123; mounted(el) &#123; el.focus() &#125; &#125;, color: &#123; mounted(el, binding) &#123; el.style.color = binding.value &#125;, updated(el, binding) &#123; el.style.color = binding.value &#125; &#125; &#125;&#125;&lt;/script&gt; 全局指令123456// main.jsapp.directive(&#x27;focus&#x27;, &#123; mounted(el) &#123; el.focus() &#125;&#125;) 工具函数响应式工具123456import &#123; isRef, unref, toRef, toRefs &#125; from &#x27;vue&#x27;// isRef: 检查是否为ref对象// unref: 如果是ref返回其值，否则返回参数本身// toRef: 为响应式对象的属性创建ref// toRefs: 将响应式对象转换为普通对象，其中每个属性都是ref 生命周期工具12345import &#123; onMounted, onUpdated, onUnmounted, nextTick &#125; from &#x27;vue&#x27;// nextTick: DOM更新后执行回调await nextTick()// DOM已经更新 性能优化响应式优化12345import &#123; shallowRef, shallowReactive, markRaw &#125; from &#x27;vue&#x27;// shallowRef: 浅层ref，不深度响应// shallowReactive: 浅层reactive，只响应根级属性// markRaw: 标记对象永远不会被转为响应式代理 组件优化123456789101112131415161718192021&lt;template&gt; &lt;HeavyComponent v-if=&quot;show&quot; /&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;// 异步组件const HeavyComponent = defineAsyncComponent(() =&gt; import(&#x27;./HeavyComponent.vue&#x27;))export default &#123; components: &#123; HeavyComponent &#125;, setup() &#123; const show = ref(false) return &#123; show &#125; &#125;&#125;&lt;/script&gt; TypeScript支持组件类型定义123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent, ref &#125; from &#x27;vue&#x27;export default defineComponent(&#123; name: &#x27;MyComponent&#x27;, props: &#123; initialCount: &#123; type: Number, default: 0 &#125;, title: &#123; type: String, required: true &#125; &#125;, setup(props) &#123; const count = ref(props.initialCount) const increment = () =&gt; &#123; count.value++ &#125; return &#123; count, increment &#125; &#125;&#125;)&lt;/script&gt; Store类型定义1234567891011121314151617181920212223242526// stores/counter.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;interface CounterState &#123; count: number name: string&#125;export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123; state: (): CounterState =&gt; (&#123; count: 0, name: &#x27;计数器&#x27; &#125;), getters: &#123; doubleCount(state): number &#123; return state.count * 2 &#125; &#125;, actions: &#123; increment(): void &#123; this.count++ &#125; &#125;&#125;) 总结Vue3带来了许多改进和新特性： 更好的性能：更快的渲染速度，更小的打包体积 Composition API：更好的逻辑复用和代码组织 更好的TypeScript支持：完整的类型推断 新的响应式系统：基于Proxy，更强大 新的内置组件：Fragment、Teleport、Suspense 改进的工具链：Vite构建工具，开发体验更好 Vue3的学习曲线相对平缓，特别是对于有Vue2经验的开发者。建议从Composition API开始学习，逐步掌握新的特性和最佳实践。"},{"title":"TS获取函数组件类型","path":"2025/09/26/TS获取函数组件类型/","text":"TS获取函数组件类型 获取函数参数的类型 获取函数返回值的类型 获取组件的 props 类型 可以使用内置的 工具类型 和 类型推导机制。下面是具体方法： ✅ 1. 获取函数参数的类型：Parameters&lt;T&gt;123456function greet(name: string, age: number): string &#123; return `Hello $&#123;name&#125;, age $&#123;age&#125;`;&#125;type Params = Parameters&lt;typeof greet&gt;;// type Params = [string, number] ✅ 2. 获取函数返回值的类型：ReturnType&lt;T&gt;123456function greet(name: string, age: number): string &#123; return `Hello $&#123;name&#125;, age $&#123;age&#125;`;&#125;type Return = ReturnType&lt;typeof greet&gt;;// type Return = string ✅ 3. 获取组件的 props 类型（React 场景）对于函数组件： 12345678910111213import React from &#x27;react&#x27;;interface MyProps &#123; title: string; count?: number;&#125;const MyComponent: React.FC&lt;MyProps&gt; = (&#123; title, count &#125;) =&gt; &#123; return &lt;div&gt;&#123;title&#125; - &#123;count&#125;&lt;/div&gt;;&#125;;type Props = React.ComponentProps&lt;typeof MyComponent&gt;;// type Props = MyProps 对于类组件： 12345678class MyClassComponent extends React.Component&lt;MyProps&gt; &#123; render() &#123; return &lt;div&gt;&#123;this.props.title&#125;&lt;/div&gt;; &#125;&#125;type Props = React.ComponentProps&lt;typeof MyClassComponent&gt;;// type Props = MyProps ✅ 4. 获取组件的 props 类型（Vue 场景）组件内部 123456789&lt;!-- MyButton.vue --&gt;&lt;script setup lang=&quot;ts&quot;&gt;interface Props &#123; // 1. 先写接口 type: &#x27;primary&#x27; | &#x27;ghost&#x27; size?: &#x27;sm&#x27; | &#x27;lg&#x27; disabled?: boolean&#125;const props = defineProps&lt;Props&gt;() // 2. 直接泛型推导&lt;/script&gt; 外部使用 1234import MyButton from &#x27;./MyButton.vue&#x27;type BtnProps = InstanceType&lt;typeof MyButton&gt;[&#x27;$props&#x27;]// BtnProps ≡ &#123; type: &#x27;primary&#x27;|&#x27;ghost&#x27;; size?: &#x27;sm&#x27;|&#x27;lg&#x27;; disabled?: boolean &#125; ✅ 总结工具类型速查表： 目的 工具类型 获取函数参数类型 Parameters&lt;typeof fn&gt; 获取函数返回值类型 ReturnType&lt;typeof fn&gt; 获取组件 props 类型（React） React.ComponentProps&lt;typeof C&gt; 获取组件 props 类型（Vue） InstanceType&lt;typeof MyButton&gt;[&#39;$props&#39;] 如果你有具体的函数或组件代码，我可以帮你直接推导出类型。"},{"title":"Vue2打包优化方案","path":"2025/09/15/Vue2打包优化方案/","text":"Vue2打包优化方案 记录一些Vue2打包优化方案，方便后续复用 当前优化方案会整理到一个demo中方便复用 demo使用到的版本 node 16.20.2 @vue/cli 5.0.9 &#119;&#x65;&#x62;&#112;&#97;&#x63;&#107;&#64;&#x35;&#x2e;&#49;&#x30;&#49;&#46;&#51; npm 8.19.4 镜像taobao ——- https://registry.npmmirror.com/ 生产环境关闭source-map 代码错误定位的功能，如果关闭了就没法定位到错误的代码位置，不方便调试 建议只在生产环境中关闭，或者生产环境运行一段时间后关闭 代码vue.config.js 1234567891011const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)const isProd = process.env.NODE_ENV === &#x27;production&#x27;module.exports = defineConfig(&#123; /** 兼容低版本 */ transpileDependencies: true, /** 生产环境使用路径 */ publicPath: &#x27;/&#x27;, /** 生产环境不生成错误定位 */ productionSourceMap: isProd,&#125;) CDN加速 CDN（Content Delivery Network，内容分发网络）是一组地理位置分散的 Web 服务器，通过智能调度把用户请求导向最近/最优节点 缩短物理传输距离 → 降低 RTT 避开公网拥塞 → 提高吞吐量 边缘缓存静态资源 → 减少回源流量 隐藏源站真实 IP → 抗 DDoS 最直接的就是：公共的CND多个网站共用一个，共用一个缓存；就近服务器请求。 通常前端只处理使用的库：vue、vuex、vue-router、axios、element-ui等 优化前后对比 vue2demo：vue、vuex、vue-router、axios、element-u，不包含其他的库了 直接打包：5mb左右 使用cdn后：500kb不到 代码vue.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)const isProd = process.env.NODE_ENV === &#x27;production&#x27;const cdnModules = &#123; vue: &#x27;Vue&#x27;, &#x27;vue-router&#x27;: &#x27;VueRouter&#x27;, vuex: &#x27;Vuex&#x27;, axios: &#x27;axios&#x27;, &#x27;element-ui&#x27;: &#x27;ELEMENT&#x27;&#125;// 对应 CDN 链接（版本写死，可自己升级）const cdn = &#123; css: [ &#x27;https://unpkg.com/element-ui@2.15.14/lib/theme-chalk/index.css&#x27; ], js: [ &#x27;https://unpkg.com/vue@2.7.16/dist/vue.js&#x27;, &#x27;https://unpkg.com/vue-router@3.6.5/dist/vue-router.js&#x27;, &#x27;https://unpkg.com/vuex@3.6.2/dist/vuex.js&#x27;, &#x27;https://unpkg.com/axios@1.12.2/dist/axios.min.js&#x27;, &#x27;https://unpkg.com/element-ui@2.15.14/lib/index.js&#x27; ]&#125;module.exports = defineConfig(&#123; /** 兼容低版本 */ transpileDependencies: true, /** 生产环境使用路径 */ publicPath: &#x27;/&#x27;, /** 生产环境不生成错误定位 */ productionSourceMap: isProd, devServer: &#123; historyApiFallback: true, /** 代理请求 */ // proxy: &#123; // &#x27;/api&#x27;: &#123; // target: &#x27;http://localhost:8081&#x27;, // changeOrigin: true // &#125; // &#125; &#125;, // webpack 层面 externals configureWebpack: config =&gt; &#123; if (isProd) &#123; config.externals = cdnModules // 等价于 webpack 的 externals &#125; &#125;, // 通过 html-webpack-plugin 钩子自动插标签 chainWebpack: config =&gt; &#123; config.plugin(&#x27;html&#x27;).tap(args =&gt; &#123; args[0].cdn = isProd ? cdn : &#123; css: [], js: [] &#125; // 开发时不注入 return args &#125;) &#125;&#125;) index.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot; /&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;!-- CDN 样式 --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn.css) &#123; %&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; /&gt; &lt;% &#125; %&gt; &lt;!-- CDN 脚本（放前面可提前加载） --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn.js) &#123; %&gt; &lt;script src=&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;&gt;&lt;/script&gt; &lt;% &#125; %&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong &gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong &gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 注意：如果不使用cdn，index.html中CDN脚本代码需要删除，webpack识别不了注释，不删除打包会报错 公共cdn 服务商 节点数 HTTP/2 Brotli 国内备案 备注 jsDelivr 750+ (Cloudflare + 网宿) ✅ ✅ 免 被墙概率低 unpkg Cloudflare 单栈 ✅ ✅ 免 回源 npm，更新快 cdnjs Cloudflare ✅ ✅ 免 库最全 启用 Gzip 传输体积再降 60% 左右，会生成一些.gz的文件，需要服务器配置 90%的项目前端可以无脑加上Gzip压缩，如果服务器或用户的浏览器不支持也会走默认的文件不会出现错误 安装1npm i compression-webpack-plugin -D vue.config.js 123456789101112131415// 引入compression-webpack-pluginconst CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)// 在configureWebpack中加入// 生产环境开启 gzip 压缩config.plugins.push( new CompressionPlugin(&#123; filename: &#x27;[path][base].gz&#x27;, algorithm: &#x27;gzip&#x27;, test: /\\.(js|css|html|svg|json)(\\?.*)?$/i, threshold: 10240, minRatio: 0.8, deleteOriginalAssets: false &#125;)) 懒加载 通常最常见的就是路由懒加载，还可以给引入的组件加上懒加载，以及对图片进行懒加载 懒加载主要是减少首屏加载，避免浏览器第一时间加载一些没有使用到的请求 路由懒加载和组件懒加载路由懒加载和组件懒加载只需要引入使用下面这种即可，一般路由懒加载可以考虑加上webpackChunkName，打包后的名称就会带有home作为名称的一部分 1const Home = () =&gt; import(/* webpackChunkName: &quot;home&quot; */ &#x27;@/views/Home.vue&#x27;) 图片懒加载 图片没有进入视口不进行加载，直接加上loading=”lazy”，热门浏览器支持 1&lt;img src=&quot;placeholder.jpg&quot; loading=&quot;lazy&quot; alt=&quot;示例&quot; /&gt; vue-lazyload 兼容低版本浏览器或其他非热门浏览器则可以使用一些开源的组件库 安装1npm i vue-lazyload@^1.3.3 -S 全局注册12345678910111213141516171819import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueLazyload from &#x27;vue-lazyload&#x27;/* 任意 1×1 透明 gif，也可换成自己的 loading 图 */import loading from &#x27;@/assets/loading.gif&#x27;import error from &#x27;@/assets/error.png&#x27;Vue.use(VueLazyload, &#123; preLoad: 1.3, // 提前 1.3 屏开始加载 error, // 失败占位 loading, // 加载中占位 attempt: 1, // 重试次数 listenEvents: [&#x27;scroll&#x27;, &#x27;wheel&#x27;, &#x27;mousewheel&#x27;, &#x27;resize&#x27;, &#x27;animationend&#x27;, &#x27;transitionend&#x27;]&#125;)new Vue(&#123; render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h3&gt;vue-lazyload 演示（Vue2）&lt;/h3&gt; &lt;!-- 普通图片，不使用默认的src --&gt; &lt;img v-lazy=&quot;img.src&quot; :key=&quot;img.src&quot; class=&quot;u-img&quot; v-for=&quot;img in list&quot; :alt=&quot;img.alt&quot; /&gt; &lt;!-- 背景图 --&gt; &lt;div v-lazy:background-image=&quot;bg&quot; :key=&quot;bg&quot; class=&quot;u-bg&quot; &gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; bg: &#x27;https://picsum.photos/800/400?random=0&#x27;, list: Array.from(&#123; length: 30 &#125;, (_, i) =&gt; (&#123; src: `https://picsum.photos/400/300?random=$&#123;i + 1&#125;`, alt: `pic-$&#123;i + 1&#125;` &#125;)) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.demo &#123; max-width: 800px; margin: 0 auto;&#125;.u-img &#123; display: block; width: 100%; height: 300px; object-fit: cover; margin-bottom: 20px; background: #f5f5f5;&#125;.u-bg &#123; width: 100%; height: 300px; background-size: cover; background-position: center;&#125;&lt;/style&gt; 代码分割（拆包） 可以将一些大文件分割成一些小一点的文件，加快请求速度，但是不要分割太细了，分割太细了反而增加了请求数量得不偿失 浏览器有6-8个请求通道，如果因为一个大一点的文件影响了请求就可以考虑代码分割了，具体大小需要根据实际的服务器带宽、用户的网络等多种因素决定 代码分割不是万能的，有些文件就是拆不了的，不要太执着 代码vue.config.js 12345678910// configureWebpack中加入// 代码分割配置config.optimization = &#123; ...config.optimization, splitChunks: &#123; chunks: &#x27;all&#x27;, minSize: 20 * 1024, // 小于多少不再分割 maxSize: 200 * 1024, // 大于多少进行分割 &#125;&#125; 图片压缩 将图片进行压缩，使用一些第三方的库可以压缩图片，但是很多库下载都缺少各种文件，而且很多还下载不下来，最终压缩的大小也一般，大图考虑在设计那边下载小一点的图片，或者使用在线的压缩网站手动压缩，小图转base64直接加载 转base64是为了加快请求速度，但是base64对应稍微大点的图片反而会增加大小，建议不要超过10kb 迅捷：https://yasuo.xunjiepdf.com/img/ 代码vue.config.js 123456789101112// chainWebpack中加入...// 小图转base64config.module .rule(&quot;images&quot;) .test(/\\.(png|jpe?g|gif|ico)$/i) .type(&quot;asset&quot;) .parser(&#123; dataUrlCondition: &#123; maxSize: 4 * 1024, // 4kb &#125;,&#125;); 删除打印 通常打印只是开发阶段使用，生产阶段不需要，或者是说稳定运行的版本不需要 代码vue.config.js 1234567891011121314151617// 引入terser-webpack-plugin，脚手架以及有这个了不需要单独安装const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;)// configureWebpack中加入/** 删除console.* 函数调用 */config.optimization.minimizer = [new TerserPlugin(&#123; terserOptions: &#123; compress: &#123; // drop_console: true, // 删除所有的 console 语句 pure_funcs: [&#x27;console.log&#x27;, &#x27;console.error&#x27;], // 移除指定的函数调用 drop_debugger: true, &#125; &#125; &#125;)] 其他方案 服务器设置静态资源缓存，cdn加速等 HTTP/2 + Server Push 多文件 并行加载 字体抽离，例如某些字体只使用了几个字，可以找一些工具进行抽离 或者安装一些工具查看体积，按需优化 webpack：webpack-bundle-analyzer vite：rollup-plugin-visualizer 如果都折腾完了还不行就花点钱升级服务器吧"},{"title":"免费云服务器和域名","path":"2025/09/10/免费云服务器和域名/","text":"免费云服务器和域名ClawCloud免费云服务器（每个月5美元的额度）：https://run.claw.cloud/ digitalplat域名（2个域名）：https://domain.digitalplat.org/ 免费域名申请大致步骤 前往官网注册账号 绑定GitHub，并点上星标 注册域名看官网提示 创建的时候ns随便填后面改就好 前往cloudflare添加连接域 选择免费的一直无脑下一步即可 复制两个ns回到digitalplat中找到我的域名更新复制的ns即可 免费云服务器大致步骤 注册账号（使用GitHub&gt;180天的账号） 尽量使用美国的，日本和新加坡虽然更近更快但是人数太多了每次更新很慢 可以通过docker安装自己开发的项目、也可以去商店获取官网弄好的项目 创建项目 在端口那里打开公开 复制生成的地址到cloudflare中自己的域名中添加NDS记录 选择类型为CNAME，名称用二级域名，例如：www 内容为复制项目生成的公开地址 代理模式先关掉 保存可能要等一会才能在项目绑定那成功 到项目创建成功后，回到cloudflare打开DNS中的代理加快访问速度"},{"title":"知识碎片","path":"2025/05/12/知识碎片/","text":"知识碎片背面隐藏 backface-visibility: hidden; 保持宽高比 宽度设置百分比，设置aspect-ratio:16/9;(宽/高) 宽高都使用vw/vh Css小手指 cursor: pointer; 设置光标的类型 1234567cursor: pointer; /* 小手指 */cursor: help; /* 鼠标带？ */cursor: wait; /* 鼠标变加载 */cursor: crosshair; /* 鼠标变+ */cursor: not-allowed; /* 鼠标变禁止 */cursor: zoom-in; /* 鼠标变放大镜 */cursor: grab; /* 鼠标变拖拽小手 */ 查看更多 Css图片模糊 filter: blur(npx); 123filter: blur(10px); /* blur()是一个函数，里面数值越大，图片越模糊 单位px*/filter: brightness(); /* brightness() 函数将线性乘法器应用于输入图像，使其看起来或多或少地变得明亮。单位%*/filter: contrast(); /* contrast() 函数可调整输入图像的对比度。单位%*/ 查看更多 Css滚动动画 scroll-behavior: smooth; 当用户手动导航或者 CSSOM scrolling API 触发滚动操作时，CSS 属性 scroll-behavior 为一个滚动框指定滚动行为，其他任何的滚动，例如那些由于用户行为而产生的滚动，不受这个属性的影响。在根元素中指定这个属性时，它反而适用于视窗。 1scroll-behavior: smooth; 查看更多 魔法注释 JsDoc、魔法注释 12345678910111213141516171819202122232425@param 参数注释/*** @param &#123;String&#125; wording 需要说的句子*/@return 返回值注释/** @return &#123;Number&#125; 返回值描述*/@example 示例注释/** @example* multiply(3, 2);*/@author 代码的作者信息/** * @author Jane Smith &lt;change@change.com&gt; */@version当前代码的版本/** @version 1.2.3*/@file对当前代码文件的描述/** * @file Manages the configuration settings for the widget. */ 查看更多 多重条件判断优化 最简单就是if else if 或switch 优化实用对象+??（空值合并） 12345678910111213141516171819// 优化前let permissions = &#x27;&#x27;const value = &quot;admin&quot;if(value==&quot;admin&quot;)&#123; permissions = &quot;普通管理员&quot;&#125;else if(value==&quot;xadmin&quot;)&#123; permissions = &quot;超级管理员&quot;&#125;else&#123; permissions = &quot;非管理员用户&quot;&#125;// 优化后let permissions = &#x27;&#x27;const value = &quot;admin&quot;const values = &#123; admin:&quot;普通管理员&quot;, xadmin:&quot;超级管理员&quot;&#125;permissions = values[value]??&quot;非管理员用户&quot; 关于第三方图片资源403问题为什么文章列表数据中的好多图片资源请求失败返回 403？ 这是因为我们项目的接口数据是后端通过爬虫抓取的第三方平台内容，而第三方平台对图片资源做了防盗链保护处理。 第三方平台怎么处理图片资源保护的？ 服务端一般使用 Referer 请求头识别访问来源，然后处理资源访问。 关于Referer：http://www.ruanyifeng.com/blog/2019/06/http-referer.html Referer 是 HTTP 请求头的一部分，当浏览器向 Web 服务器发送请求的时候，一般会带上 Referer，它包含了当前请求资源的来源页面的地址。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。 怎么解决？ 不要发送 referrer ，对方服务端就不知道你从哪来的了，姑且认为是你是自己人吧。 如何设置不发送 referrer？ 用 &lt;a&gt;、&lt;area&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;script&gt; 或者 &lt;link&gt; 元素上的 referrerpolicy 属性为其设置独立的请求策略，例如： &lt;img src=&quot;http://……&quot; referrerPolicy=&quot;no-referrer&quot;&gt; 或者直接在 HTMl 页面头中通过 meta 属性全局配置： &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 滚动条样式用png格式背景图片，切图的时候调整留白然后修改滚动条滑块样式 1234567891011121314151617181920/* 滚动条 */.scrollbar &#123; width: 98%; overflow-y: scroll; overflow-x: hidden; max-height: 6.5rem; padding-right: .4rem; box-sizing: border-box;&#125;.scrollbar::-webkit-scrollbar &#123; width: 0.2rem; background: url(../images/scrollbar_bg.png) no-repeat center / 150% 100%;&#125;.scrollbar::-webkit-scrollbar-thumb &#123; /* background: url(../images/scrollbar_thumb_bg.png) no-repeat center / 100% 100%; */ border-radius: .1rem; background: linear-gradient(0deg, #9a2aea, #c868fe);&#125; 页面内容使用JS动态获取12345&lt;div&gt; &lt;script&gt; document.write((new Date()).getFullYear()) &lt;/script&gt;&lt;/div&gt; 下载命名 默认文件名称改为英文或数字，可以使用a标签的download属性指定名称 移动端文字 在模拟器中设置的文字大小调整时没有什么变化，但是到了手机中大小就有明显的变化了，在编写代码的时候不能依靠模拟器 文字溢出‘…’123456/*1. 先强制一行内显示文本，默认 normal 自动换行*/ white-space: nowrap; /*2. 超出的部分隐藏*/ overflow: hidden; /*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; 12345678910/*1. 超出的部分隐藏 */overflow: hidden;/*2. 文字用省略号替代超出的部分 */text-overflow: ellipsis;/* 3. 弹性伸缩盒子模型显示 */display: -webkit-box;/* 4. 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 2;/* 5. 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical; 视频封面在video上面加上poster属性，指定封面图片 1234&lt;video src=&quot;https://ideal.chinaceotv.com/2023/20230321/dianqiyiliao.mp4&quot; poster=&quot;images/video_1.png&quot; controls width=&quot;100%&quot;height=&quot;100%&quot; preload=&quot;preload&quot; x5-video-player-type=&quot;h5&quot; x5-video-player-fullscreen=&quot;true&quot;webkit-playsinline=&quot;true&quot; playsinline=&quot;true&quot; x5-video-orientation=&quot;portrait&quot;style=&quot;object-fit: cover;&quot;&gt;&lt;/video&gt; 图片裁剪拉伸object-fit：用于 img 和 video 标签，一般可以对这些元素进行保留原始比例的剪切、缩放或者直接进行拉伸等。 fill 默认，不保证保持原有的比例，内容拉伸填充整个内容容器。 contain 保持原有尺寸比例。内容被缩放。 cover 保持原有尺寸比例。但部分内容可能被剪切。 none 保留原有元素内容的长度和宽度，也就是说内容不会被重置。 scale-down 保持原有尺寸比例。内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。 initial 设置为默认值，关于initial inherit 从该元素的父元素继承属性。 关于inherit 谷歌浏览器网页截图打开控制台：ctrl + shift + p输入：cfz 判断是移动端还是PC端 通过js判断 1234567if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) &#123; // 移动端 // window.location.href=&quot;http://campus.51job.com/whlkg/&quot;;&#125; else &#123; // PC // window.location.href=&quot;http://campus.51job.com/whlkg/&quot;;&#125; hover后加上边框元素偏移 默认加上边框，颜色设置透明 Flex布局的间距 其他的属性照常设置，增加gap属性 1gap：10px 点击穿透 给需要穿透的dom设置 1pointer-events:none 小程序视频地址填坑 在小程序里面，如果视频的地址包含中文会出现在模拟器可以播放，但是真机不能播放使用这个函数将需要转换的部分取出来进行转换 12345678910// 用于编码URL参数 encodeUrlParam(param) &#123; // 对参数进行encodeURIComponent编码 return encodeURIComponent(param);&#125;,// 用于解码URL参数decodeUrlParam(param) &#123; // 对参数进行decodeURIComponent解码 return decodeURIComponent(param);&#125; 网页可编辑1document.designMode = &quot;on&quot;;"},{"title":"项目常用（前程无忧）","path":"2025/05/12/项目常用内容/","text":"项目常用（前程无忧）个人公共样式1234567891011121314151617181920212223242526272829303132333435363738394041424344:root &#123; --color: #fff;&#125;img &#123; max-width: 100%; max-height: 100%;&#125;img.title &#123; display: block; margin: 0 auto;&#125;img.center &#123; display: block; margin: 0 auto;&#125;.text_2em &#123; line-height: 2em;&#125;.text_2em_in &#123; text-indent: 2em; line-height: 2em;&#125;.text_ju &#123; text-align: justify; word-wrap: break-word;&#125;.text_center &#123; text-align: center;&#125;.title &#123; font-weight: 900;&#125;.color &#123; color: var(--color);&#125; 滚动条样式用png格式背景图片，切图的时候调整留白 然后修改滚动条滑块样式 1234567891011121314151617181920/* 滚动条 */.scrollbar &#123; width: 98%; overflow-y: scroll; overflow-x: hidden; max-height: 6.5rem; padding-right: .4rem; box-sizing: border-box;&#125;.scrollbar::-webkit-scrollbar &#123; width: 0.2rem; background: url(../images/scrollbar_bg.png) no-repeat center / 150% 100%;&#125;.scrollbar::-webkit-scrollbar-thumb &#123; /* background: url(../images/scrollbar_thumb_bg.png) no-repeat center / 100% 100%; */ border-radius: .1rem; background: linear-gradient(0deg, #9a2aea, #c868fe);&#125; 锚点链接1234567html &#123; // 动画 scroll-behavior: smooth;&#125;#xxx:target &#123; // 跳转后的地点 padding-top: 125px;&#125; 第三方网站跳转12345678910111213141516&lt;script&gt; document .querySelector(&#x27;第三方跳转的标签选择器&#x27;) .addEventListener(&#x27;click&#x27;, function (e) &#123; e.preventDefault(); if ( window.confirm( &#x27;您即将离开前程无忧官方招聘网站，前往第三方页面。是否确认前往？&#x27; ) ) &#123; window.location.href = &#x27;&#x27;; &#125; else &#123; return false; &#125; &#125;);&lt;/script&gt; 页面内容使用JS动态获取12345&lt;div&gt; &lt;script&gt; document.write((new Date()).getFullYear()) &lt;/script&gt;&lt;/div&gt; 确保内容最小满屏使用css计算主体最小高度 1min-height: calc(100vh - 625px - 50px - 40px); /*屏幕高度 - 导航 - banner - 外边距 - 版权*/ 具体看实际情况 文字两端对齐文字两端对齐 + 强制换行 12text-align: justify;/* 文字两端对齐 */word-wrap: break-word;/* 强制换行 */ 下载命名PC：默认文件名称改为英文或数字，然后使用download属性指定名称；结尾要带上后缀H5：不要使用download 移动端文字在模拟器中设置的文字大小调整时没有什么变化，但是到了手机中大小就有明显的变化了，在编写代码的时候不能依靠模拟器 文字溢出‘…’123456/*1. 先强制一行内显示文本*/ white-space: nowrap; （ 默认 normal 自动换行） /*2. 超出的部分隐藏*/ overflow: hidden; /*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; 12345678910/*1. 超出的部分隐藏 */overflow: hidden;/*2. 文字用省略号替代超出的部分 */text-overflow: ellipsis;/* 3. 弹性伸缩盒子模型显示 */display: -webkit-box;/* 4. 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 2;/* 5. 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical; 文字内容替换部分数据要注意中英文符号，别人给到的不一定是一样的，要么手动替换，要么js多写一种替换 1string = string.replace(/职位描述：/g, &#x27;&lt;span&gt;职位描述：&lt;/span&gt;&#x27;) 视频封面在video上面加上poster属性，指定封面图片 1234&lt;video src=&quot;xxx.mp4&quot; poster=&quot;images/video.png&quot; controls width=&quot;100%&quot;height=&quot;100%&quot; preload=&quot;preload&quot; x5-video-player-type=&quot;h5&quot; x5-video-player-fullscreen=&quot;true&quot;webkit-playsinline=&quot;true&quot; playsinline=&quot;true&quot; x5-video-orientation=&quot;portrait&quot;style=&quot;object-fit: cover;&quot;&gt;&lt;/video&gt; 微信分享使用已经封装好的的库，图片丢失 在文件中的名称好像是固定的，并且要使用hppts开头的 图片裁剪拉伸object-fit：用于 img 和 video 标签，一般可以对这些元素进行保留原始比例的剪切、缩放或者直接进行拉伸等。 fill 默认，不保证保持原有的比例，内容拉伸填充整个内容容器。 contain 保持原有尺寸比例。内容被缩放。 cover 保持原有尺寸比例。但部分内容可能被剪切。 none 保留原有元素内容的长度和宽度，也就是说内容不会被重置。 scale-down 保持原有尺寸比例。内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。 initial 设置为默认值，关于initial inherit 从该元素的父元素继承属性。 关于inherit 谷歌网页截图打开控制台：ctrl + shift + p 输入：cfz 回车 判断是移动端还是PC端1234567if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) &#123; // 移动端 // window.location.href=&quot;http://campus.51job.com/whlkg/&quot;;&#125; else &#123; // PC // window.location.href=&quot;http://campus.51job.com/whlkg/&quot;;&#125; hover后加上边带有框元素偏移默认加上边框，颜色设置透明 或者 使用盒模型"},{"title":"微信小程序","path":"2025/05/12/微信小程序/","text":"微信小程序 小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用 提高小程序的速度小程序启动加载性能： 控制代码包的大小 分包加载 首屏体验（预请求，利用缓存，避免白屏，及时反馈 小程序渲染性能： 避免不当的使用setData 使用自定义组件 封装请求 使用Promise封装 12345678910111213141516171819202122232425262728293031// const BASE_URL = &quot;http://localhost:3000&quot;const BASE_URL = &quot;http://123.207.32.32:9002&quot;class API &#123; request(url, method = &quot;GET&quot;, data) &#123; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: BASE_URL + url, method, data, success: (res) =&gt; &#123; resolve(res.data) &#125;, fail: (err) =&gt; &#123; reject(err) &#125; &#125;) &#125;) &#125; get(url, data) &#123; return this.request(url, &quot;GET&quot;, data) &#125; post(url, data) &#123; return this.request(url, &quot;POST&quot;, data) &#125;&#125;const axios = new API()export default axios 后续创建对应模块的文件管理接口 1234567export function get(形参) &#123; return axios.get(路径, &#123;实参&#125;)&#125;export function post(形参) &#123; return axios.post(路径, &#123;实参&#125;)&#125; 使用第三方包打开调试器的终端，在根目录下执行，并生成文件 1npm init -y 老版本在本地设置中需要勾选npm 安装第三方包，例如 1npm i @vant/weapp 点击工具构建npm，等待执行结束 在需要使用的位置引入即可，例如 1234// app.json 全局&quot;usingComponents&quot;: &#123; &quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;&#125; 1234// index.json 局部&quot;usingComponents&quot;: &#123; &quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;&#125; WXS.wxs 为后缀名的文件 类似于JS，不支持es6以上，导出得使用module.exports 12345678var foo = &quot;&#x27;hello world&#x27; from tools.wxs&quot;;var bar = function (d) &#123; return d;&#125;module.exports = &#123; FOO: foo, bar: bar,&#125;; 引入/使用方法123&lt;wxs src=&quot;../../utils/format.wxs&quot; module=&quot;format&quot;&gt;&lt;/wxs&gt;&lt;view class=&quot;count&quot;&gt;&#123;&#123;format.formatCount(item.playCount)&#125;&#125;&lt;/view&gt;&lt;view class=&quot;duration&quot;&gt;&#123;&#123;format.formatDuration(item.mv.videos[0].duration)&#125;&#125;&lt;/view&gt; 案例1234567891011121314151617181920212223242526272829303132333435/** * 数字格式化 * @param count */function formatCount(count) &#123; var counter = parseInt(count) if (counter &gt; 100000000) &#123; return (counter / 100000000).toFixed(1) + &quot;亿&quot; &#125; else if (counter &gt; 10000) &#123; return (counter / 10000).toFixed(1) + &quot;万&quot; &#125; else &#123; return counter + &quot;&quot; &#125;&#125;/** * 左边补0 * @param time 时间（分/秒） */function padLeftZero(time) &#123; time = time + &quot;&quot; return (&quot;00&quot; + time).slice(time.length)&#125;function formatDuration(duration) &#123; duration = duration / 1000 var minute = (duration / 60) | 0 var second = (duration | 0) % 60 return padLeftZero(minute) + &quot;:&quot; + padLeftZero(second)&#125;module.exports = &#123; formatCount: formatCount, formatDuration: formatDuration&#125; 12345678910111213&lt;wxs src=&quot;../../utils/format.wxs&quot; module=&quot;format&quot;&gt;&lt;/wxs&gt;&lt;view class=&quot;item&quot;&gt; &lt;view class=&quot;album&quot;&gt; &lt;image class=&quot;image&quot; src=&quot;&#123;&#123;item.cover&#125;&#125;&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt; &lt;view class=&quot;info&quot;&gt; &lt;view class=&quot;count&quot;&gt;&#123;&#123;format.formatCount(item.playCount)&#125;&#125;&lt;/view&gt; &lt;view class=&quot;duration&quot;&gt;&#123;&#123;format.formatDuration(item.mv.videos[0].duration)&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;content&quot;&gt; &#123;&#123;item.name&#125;&#125; - &#123;&#123;item.artistName&#125;&#125; &lt;/view&gt;&lt;/view&gt; 小程序slot在小程序中没有办法实在在slot标签中实现默认值的 通过css的伪类：empty配合兄弟元素选择器来实现 empty判断子元素的内容是否为空 实现方法：把默认内容隐藏，当子元素为空是修改兄弟元素的样式，将默认内容显示 1234567.header .slot:empty+.default &#123; display: flex;&#125;.header .default &#123; display: none;&#125;"},{"title":"小程序封装抽离","path":"2025/05/12/小程序封装抽离/","text":"小程序封装抽离 来源于uniapp项目 请求封装单一路径 原生请求 只针对一个根路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103export const BASE_URL = &quot;https://www.brrfid-pm.cn/WXAPI&quot; // 接口前缀export const IMAGE_BASE_URL = &quot;https://www.brrfid-pm.cn/WXAPI/image/&quot; // 图片前缀export const downLoadUrl = &quot;https://www.brrfid-pm.cn/api/download/v2/&quot; // 下载地址class API &#123; /** * 封装的请求 * @param &#123;*&#125; url 请求地址 * @param &#123;*&#125; method 请求类型 * @param &#123;*&#125; data 请求数据 * @param &#123;*&#125; header 请求头 * @param &#123;*&#125; animation * @returns */ request(url, method, data, header = &#123;&#125;, showLoading = true) &#123; return new Promise((resolve, reject) =&gt; &#123; const token = uni.getStorageSync(&quot;token&quot;); if (token) &#123; header.token = token &#125; console.log(&#x27;请求前数据 :&gt;&gt;&#x27;, data); // 请求加载动画 showLoading &amp;&amp; uni.showLoading(&#123; title: &#x27;加载中&#x27; &#125;); uni.request(&#123; url: BASE_URL + url, method, header, data, success: (res) =&gt; &#123; console.log(&#x27;请求后数据 :&gt;&gt; &#x27;, res.data); if (res.data.code == 401) &#123; uni.navigateTo(&#123; url: &#x27;/pages/managerial/login/login&#x27;, &#125;); &#125; resolve(res.data) &#125;, fail: (err) =&gt; &#123; reject(err) &#125;, complete: () =&gt; &#123; showLoading &amp;&amp; uni.hideLoading(); &#125; &#125;) &#125;) &#125; /** * get请求 * @param &#123;*&#125; url 请求地址 * @param &#123;*&#125; data 请求参数 * @param &#123;*&#125; header 请求头 * @param &#123;*&#125; showLoading 是否执行加载动画 * @returns Promise */ get(url, data, header, showLoading) &#123; return this.request(url, &quot;GET&quot;, data, header, showLoading) &#125; /** * post请求 * @param &#123;*&#125; url 请求地址 * @param &#123;*&#125; data 请求参数 * @param &#123;*&#125; header 请求头 * @param &#123;*&#125; showLoading 是否执行加载动画 * @returns Promise */ post(url, data, header, showLoading) &#123; return this.request(url, &quot;POST&quot;, data, header, showLoading) &#125; /** * put请求 * @param &#123;*&#125; url 请求地址 * @param &#123;*&#125; data 请求参数 * @param &#123;*&#125; header 请求头 * @param &#123;*&#125; showLoading 是否执行加载动画 * @returns Promise */ put(url, data, header, showLoading) &#123; return this.request(url, &quot;PUT&quot;, data, header, showLoading) &#125; /** * delete请求 * @param &#123;*&#125; url 请求地址 * @param &#123;*&#125; data 请求参数 * @param &#123;*&#125; header 请求头 * @param &#123;*&#125; showLoading 是否执行加载动画 * @returns Promise */ delete(url, data, header, showLoading) &#123; return this.request(url, &quot;DELETE&quot;, data, header, showLoading) &#125;&#125;const request = new API()export default request 多个路径 在class中加一个 12345678910111213141516171819202122232425262728293031class API &#123; /** * 构造函数中添加了baseUrl参数，允许在创建API实例时设置基础URL。 * @param &#123;string&#125; [baseUrl=&#x27;https://www.brrfid-pm.cn/WXAPI&#x27;] - API的基础URL。 */ constructor(baseUrl = &#x27;https://www.brrfid-pm.cn/WXAPI&#x27;) &#123; this.baseUrl = baseUrl &#125; // ... 其他原有方法不变 ... /** * 封装的请求 * 新增baseUrlKey参数，用于动态选择基础URL * @param &#123;*&#125; url 请求地址（相对路径） * @param &#123;*&#125; method 请求类型 * @param &#123;*&#125; data 请求数据 * @param &#123;*&#125; header 请求头 * @param &#123;*&#125; showLoading 是否显示加载动画 * @returns */ request(url, method, data, header = &#123;&#125;, showLoading = true) &#123; const fullUrl = this.baseUrl + url; // ... 其余代码逻辑保持不变 ... &#125; // ... 其他请求方法（get, post, put, delete）保持不变&#125;const request = new API() // 默认路径const customApi = new API(&#x27;https://xxx.xxx.xxx&#x27;) // 其他路径 公共函数/过滤器 在根路径创建global文件夹用于存放全局的函数、变量、过滤器等 所有的文件需要再main.js中引入 例如：import ‘./global/filter.js’; 全局过滤器 filter.js 用于存放全局的过滤器 12345678910111213141516171819202122232425262728293031323334353637383940import Vue from &#x27;vue&#x27;// 字符串有/n时替换为&lt;br/&gt;，并且在前面补一段话Vue.filter(&#x27;replaceNewlineWithBr&#x27;, function (value) &#123; let str = &quot;产品描述：&quot;; str += value?.replace(/\\n/g, &quot;&lt;br/&gt;&quot;); return str;&#125;)// 价格小数位补0Vue.filter(&#x27;formatPrice&#x27;, function (price) &#123; if (!price) &#123; return &#125; // 将价格转换为字符串，便于操作 let priceStr = price.toString(); // 使用正则表达式检查小数点及之后的数字 let match = priceStr.match(/(\\.\\d*)?$/); // 如果没有小数点或者小数点后不足两位 if (!match || match[0].length &lt; 3) &#123; // 补足到小数点后两位 return price.toFixed(2); &#125; else &#123; // 如果小数点后已经两位或以上，直接返回原价 return priceStr; &#125;&#125;)// 订单状态Vue.filter(&#x27;fnStatus&#x27;, function (value) &#123; const typesObj = &#123; 1: &quot;未支付&quot;, 2: &quot;已支付&quot;, 3: &quot;生产中&quot;, 4: &quot;已完成&quot;, 5: &quot;已取消&quot;, &#125;; return typesObj[value];&#125;) 全局函数以及变量等 mixin.js 用于存放全局的变量已经函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// main.js 或者你的入口文件import Vue from &#x27;vue&#x27;;import &#123; BASE_URL, downLoadUrl &#125; from &#x27;@/api/request&#x27;;Vue.mixin(&#123; data() &#123; return &#123; navBarHeight: uni.getStorageSync(&quot;navBarHeight&quot;) || 90, // 顶部高度 tabBarHeight: uni.getStorageSync(&quot;tabBarHeight&quot;) || 80, // 底部高度 imgurl: this.imgurl, // 图片前缀 BASE_URL: BASE_URL, // 请求前缀 downLoadUrl: downLoadUrl, // 下载文件前缀 &#125; &#125;, methods: &#123; // 复制 copy(text) &#123; uni.setClipboardData(&#123; data: text, success: (res) =&gt; &#123; this.$u.toast(&quot;复制成功&quot;); &#125;, fail: (err) =&gt; &#123; this.$u.toast(&quot;复制失败&quot;); &#125;, &#125;); &#125;, // 计算表单高度 getNavBarHeight(className) &#123; return new Promise((resolve, reject) =&gt; &#123; const query = uni.createSelectorQuery().in(this); query .select(className) .boundingClientRect((data) =&gt; &#123; console.log(&quot;data.height :&gt;&gt; &quot;, data.height); resolve(data.height); &#125;) .exec(); &#125;); &#125;, // 跳转页面 goPage(url) &#123; if (!url) &#123; return; &#125; uni.navigateTo(&#123; url: url, &#125;); &#125;, // 图片上传 uploadFilePromise(url) &#123; return new Promise((resolve, reject) =&gt; &#123; uni.uploadFile(&#123; url: this.BASE_URL + &quot;/uploadImage&quot;, // 仅为示例，非真实的接口地址 filePath: url, header: &#123; token: uni.getStorageSync(&#x27;token&#x27;) || &#x27;&#x27; &#125;, name: &quot;file&quot;, success: (res) =&gt; &#123; console.log(&#x27;res :&gt;&gt; &#x27;, res); let data = JSON.parse(res.data).url setTimeout(() =&gt; &#123; resolve(data); &#125;, 1000); &#125;, &#125;); &#125;); &#125;, // 文件下载 downloadFilePromise(url) &#123; console.log(&#x27;url :&gt;&gt; &#x27;, url); console.log(&#x27;this.downLoadUrl + url :&gt;&gt; &#x27;, this.downLoadUrl + url); return new Promise((resolve, reject) =&gt; &#123; const downloadTask = uni.downloadFile(&#123; url: this.downLoadUrl + url, // 文件下载地址 success: (res) =&gt; &#123; if (res.statusCode === 200) &#123; // 下载成功处理 console.log(&#x27;下载成功&#x27;); // 保存到本地文件系统 uni.saveFile(&#123; tempFilePath: res.tempFilePath, //临时文件路径 filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/$&#123;url&#125;`, // 指定保存路径和文件名 success: (saveRes) =&gt; &#123; console.log(&#x27;文件保存成功&#x27;, saveRes.savedFilePath); resolve(saveRes.savedFilePath) &#125;, fail: (err) =&gt; &#123; console.log(&#x27;保存文件失败&#x27;, err); &#125; &#125;); &#125; else &#123; console.log(&#x27;下载失败&#x27;, res.statusCode); &#125; &#125;, fail: (err) =&gt; &#123; console.log(&#x27;下载过程中出错&#x27;, err); &#125; &#125;); downloadTask.onProgressUpdate((res) =&gt; &#123; uni.showLoading(&#123; title: `下载进度 $&#123;res.progress&#125;%`, mask: true, &#125;); if (res.progress == 100) &#123; uni.hideLoading(); uni.showToast(&#123; title: &quot;下载成功&quot;, icon: &quot;success&quot;, duration: 1500, &#125;); &#125; &#125;); &#125;) &#125; &#125;&#125;); 路由/分包/组件路由路由使用HBuilderX创建基本上没有问题 个人不习惯嵌套多个文件夹 分包按照官方的要求创建分包，后面创建页面会自动识别是哪一个分包，如果能够确保自己设置的没有问题，但是创建的时候没有识别，就重启HBuilderX 1234567891011121314151617&quot;subPackages&quot;: [ &#123; &quot;root&quot;: &quot;products&quot;, &quot;pages&quot;: [ &#123; &quot;path&quot;: &quot;detail/detail&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;产品详情&quot;, &quot;enablePullDownRefresh&quot;: false, &quot;navigationStyle&quot;: &quot;custom&quot; &#125; &#125; ] &#125;, ] ····省略其他内容··· &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot; 组件 只要组件安装在项目的 components 目录下，并符合 components/组件名称/组件名称.vue 目录结构。就可以不用引用、注册，直接在页面中使用。 官方说明：https://uniapp.dcloud.net.cn/tutorial/vue-components.html#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C"},{"title":"大屏适配方案","path":"2025/05/12/大屏适配方案/","text":"大屏适配方案 通过js计算比例进行缩放 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 屏幕适配 mixin 函数，设置ref为appRef// * 默认缩放值const scale = &#123; width: &#x27;1&#x27;, height: &#x27;1&#x27;,&#125;// * 设计稿尺寸（px）const baseWidth = 1920const baseHeight = 1080// * 需保持的比例（默认1.77778）const baseProportion = parseFloat((baseWidth / baseHeight).toFixed(5))export default &#123; data() &#123; return &#123; // * 定时函数 drawTiming: null &#125; &#125;, mounted () &#123; // 确保在浏览器重绘后再执行 this.$nextTick(() =&gt; &#123; requestAnimationFrame(() =&gt; &#123; requestAnimationFrame(() =&gt; &#123; this.calcRate(); &#125;); &#125;); &#125;); window.addEventListener(&#x27;resize&#x27;, this.resize) &#125;, beforeDestroy () &#123; window.removeEventListener(&#x27;resize&#x27;, this.resize) &#125;, methods: &#123; calcRate () &#123; const appRef = this.$refs[&quot;appRef&quot;] if (!appRef) return // 当前宽高比 const currentRate = parseFloat((window.innerWidth / window.innerHeight).toFixed(5)) if (appRef) &#123; if (currentRate &gt; baseProportion) &#123; // 表示更宽 scale.width = ((window.innerHeight * baseProportion) / baseWidth).toFixed(5) scale.height = (window.innerHeight / baseHeight).toFixed(5) appRef.style.transform = `scale($&#123;scale.width&#125;, $&#123;scale.height&#125;) translate(-50%, -50%)` &#125; else &#123; // 表示更高 scale.height = ((window.innerWidth / baseProportion) / baseHeight).toFixed(5) scale.width = (window.innerWidth / baseWidth).toFixed(5) appRef.style.transform = `scale($&#123;scale.width&#125;, $&#123;scale.height&#125;) translate(-50%, -50%)` &#125; &#125; &#125;, resize () &#123; clearTimeout(this.drawTiming) this.drawTiming = setTimeout(() =&gt; &#123; this.calcRate() &#125;, 200) &#125; &#125;,&#125;"},{"title":"发布自己的npm包","path":"2025/05/12/发布自己的npm包/","text":"发布自己的npm包 在npm注册账号 创建项目项目 在项目目录中执行登录 npm login 发布 npm publish 更新包 npm version patch 更新版本号 npm publish 上传 安装使用 发布的包（获取目录树）：https://www.npmjs.com/package/@hsk766187397/get-tree 1npm i @hsk766187397/get-tree -g"},{"title":"关于vue.config.js","path":"2025/05/12/关于vue.config.js/","text":"关于vue.config.jsvue.config.js中常用的配置在配置中绝大多数都是（可选项） 导出模块常规操作还是用到了commjs语法 123module.exports = &#123;&#125; publicPath 部署应用包的基本Url部署应用包的基本Url，默认/, 可以设置为相对路径./,这样打出来的包，可以部署到任意路径上 12345let developmentPath=&#x27;./&#x27;;//开发环境-npm run serve时引用文件路径let productionPath=&#x27;./&#x27;;//生产环境-npm run build打包后引用文件路径module.exports = &#123; publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? productionPath: developmentPath, // 基本路径-引用文件的路&#125; outputDir 输出文件目录输出文件目录（打包后生成的目录，默认dist） 1234module.exports = &#123; outputDir: __dirname + &#x27;/server/dist&#x27;, //build之后静态文件输出路径 //outputDir: &#x27;dist&#x27;,&#125; assetsDir 打包后生成的静态资源目录打包后生成的静态资源目录，默认“ ” ，也就是我们打包后的css，js等存放的位置 123module.exports = &#123; assetsDir: &#x27;static&#x27;,&#125; lintOnSave是否在保存的时候检查 123module.exports = &#123; lintOnSave: process.env.NODE_ENV !== &#x27;production&#x27;,// eslint-loader &#125; productionSourceMap 生产环境的 source map生产环境的 source map，可以将其设置为 false 以加速生产环境构建，默认值是true 123module.exports = &#123; productionSourceMap: false,&#125; devServer可通过 devServer.proxy解决前后端跨域问题（反向代理） 1234567891011121314151617181920212223module.exports = &#123;// 反向代理 devServer: &#123; index: &#x27;/login.html&#x27;, //默认打开文件 open: true, //自动打开浏览器 host: &#x27;localhost&#x27;, //默认打开域名 port: 8080, //默认打开端口号 https: false, //开启关闭https请求 hotOnly: false, //热更 proxy: &#123; // 配置跨域 &#x27;/api&#x27;: &#123; target: &#x27;http://dev.aabb.cn:8082/&#x27;, //代理地址，这里设置的地址会代替axios中设置的baseURL ws: true, //// proxy websockets changeOrigin: true,// 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; //pathRewrite方法重写url &#x27;^/api&#x27;: &#x27;/&#x27;, &#125;, &#125;, &#125;, &#125;,&#125; 扩展： hot 和 hotOnly 的区别是在某些模块不支持热更新的情况下，前者会自动刷新页面，后者不会刷新页面，而是在控制台输出热更新失败 打包时去除打印信息上面已经提到过去掉打印的操作（console、debug）这里详细讲解一下 首先下载相关插件 uglifyjs-webpack-plugin npm i -D uglifyjs-webpack-plugin 在vue.config.js文件中引入，并在configureWebpack的optimization中添加如下代码 123456789101112131415161718192021222324252627282930const UglifyPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)module.exports = &#123; configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; // 为生产环境修改配置... config.mode = &#x27;production&#x27; // 将每个依赖包打包成单独的js文件 let optimization = &#123; /*以下代码适用于uglifyjs-webpack-plugin 2.1.1及以前的版本*/ minimizer: [new UglifyPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_console: true, // console drop_debugger: false, pure_funcs: [&#x27;console.log&#x27;] // 移除console &#125; &#125; &#125;)] &#125; Object.assign(config, &#123; optimization &#125;) &#125; &#125;&#125; 新版uglifyjs-webpack-plugin需写成以下方式 12345678910minimizer: [new UglifyPlugin(&#123; uglifyOptions: &#123; warnings: false, compress: &#123; drop_console: false, // console drop_debugger: false, pure_funcs: [&#x27;console.log&#x27;] // 移除console &#125; &#125;&#125;)] 移动端.px2rem 响应样式安装 npm i -S lib-flexible postcss-px2rem 引入 lib-flexible 在项目入口中main.js 中引入lib-flexible 123import &#x27;lib-flexible&#x27; # 注意事项: 由于flexible会动态给页面header中添加&lt;meta name=&#x27;viewport&#x27; &gt;标签，所以务必请把目录 public/index.html 中的这个标签删除！！ 配置postcss-px2rem 项目中vue.config.js中进行如下的配置 1234567891011module.exports = &#123; css: &#123; loaderOptions: &#123; css: &#123;&#125;, postcss: &#123; plugins: [ require(&#x27;postcss-px2rem&#x27;)(&#123; remUnit: 37.5 &#125;) ] &#125; &#125; &#125; &#125; 设置页面动态标题下载 vue-wechat-title npm i -S vue-wechat-title main.js中全局引入 12import VueWechatTitle from &#x27;vue-wechat-title&#x27;Vue.use(VueWechatTitle) App.vue中设置 123456&lt;template&gt;&lt;!-- 动态设置title --&gt; &lt;div id=&quot;app&quot; v-wechat-title=&#x27;$route.meta.title&#x27;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 开启gzip压缩gzip压缩是一种http请求优化方式，通过减少文件体积来提高加载速度。html、js、css文件甚至json数据都可以用它压缩，可以减小60%以上的体积。webpack在打包时可以借助 compression webpack plugin 实现gzip压缩。 下载 compression webpack plugin npm i -D compression-webpack-plugin vue.config.js配置 1234567891011121314151617181920212223242526const CompressionPlugin = require(&quot;compression-webpack-plugin&quot;);module.exports = &#123; configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; // 为生产环境修改配置... config.mode = &#x27;production&#x27;; if(openGzip)&#123; config.plugins = [ ...config.plugins, new CompressionPlugin(&#123; test:/\\.js$|\\.html$|.\\css/, //匹配文件名 threshold: 10240,//对超过10k的数据压缩 deleteOriginalAssets: false //不删除源文件 &#125;) ] &#125; &#125; else &#123; // 为开发环境修改配置... config.mode = &#x27;development&#x27;; &#125; &#125;&#125; package.js 配置 123456&#123; &quot;name&quot;: &quot;demo-cli3&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;openGizp&quot;: false, ...&#125; 优化打包chunk-vendors.js当运行项目并且打包的时候，会发现chunk-vendors.js这个文件非常大，那是因为webpack将所有的依赖全都压缩到了这个文件里面，这时我们可以将其拆分，将所有的依赖都打包成单独的js; 12345678910111213141516171819202122232425262728293031323334/*利用splitChunks将每个依赖包单独打包，在生产环境下配置，代码如下*/configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; // 为生产环境修改配置... config.mode = &#x27;production&#x27; // 将每个依赖包打包成单独的js文件 let optimization = &#123; runtimeChunk: &#x27;single&#x27;, splitChunks: &#123; chunks: &#x27;all&#x27;, maxInitialRequests: Infinity, minSize: 20000, // 依赖包超过20000bit将被单独打包 cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name (module) &#123; // get the name. E.g. node_modules/packageName/not/this/part.js // or node_modules/packageName const packageName = module.context.match(/[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/)[1] // npm package names are URL-safe, but some servers don&#x27;t like @ symbols return `npm.$&#123;packageName.replace(&#x27;@&#x27;, &#x27;&#x27;)&#125;` &#125; &#125; &#125; &#125; &#125; Object.assign(config, &#123; optimization &#125;) &#125; &#125; vue.config.js完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195// 打包多入口文件基本配置let developmentPath = &#x27;./&#x27;;//开发环境-npm run serve时引用文件路径let productionPath = &#x27;./&#x27;;//生产环境-npm run build打包后引用文件路径const UglifyJsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)//生产环境取消打印const CompressionWebpackPlugin = require(&#x27;compression-webpack-plugin&#x27;)//gzip压缩const productionGzipExtensions = [&#x27;js&#x27;, &#x27;css&#x27;]const Version = &#x27;V6.1&#x27;const Timestamp = new Date().getTime()function getPagesInfo() &#123; let pages = &#123;&#125; const glob = require(&#x27;glob&#x27;) // 引入glob模块,用于扫描全部src/pages/**/main.js（返回的是一个数组） glob.sync(&#x27;src/pages/**/main.js&#x27;).forEach((entry, i) =&gt; &#123; let name = entry.slice(10, -8) pages[name] = &#123; entry: entry, template: &#x27;public.index.html&#x27;, filename: name + &#x27;.html&#x27;, title: &#x27;&#x27;, chunks: [&quot;chunk-vendors&quot;, &quot;chunk-common&quot;, name] &#125; &#125;) return pages&#125;// 打包相关module.exports = &#123; pages: getPagesInfo(),//多页面应用配置 publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? productionPath : developmentPath, // 基本路径-引用文件的路 __dirname + &#x27;/server/dist&#x27;, //build之后静态文件输出路径 assetsDir: &#x27;static&#x27;,//静态资源大包位置 outputDir: __dirname + &#x27;/server/dist&#x27;, //build之后静态文件输出路径 lintOnSave: process.env.NODE_ENV !== &#x27;production&#x27;,// 打包的时候eslint-loader检查 productionSourceMap: false,//source map 检查 // 启动服务器 devServer: &#123; index: &#x27;/login.html&#x27;, //默认打开文件 open: true, //自动打开浏览器 host: &#x27;localhost&#x27;, //默认打开域名 port: 8080, //默认打开端口号 https: false, //开启关闭https请求 hotOnly: false, //热更 // 反向代理 proxy: &#123; // 配置跨域 &#x27;/api&#x27;: &#123; target: &#x27;http://dev.aabb.cn:8082/&#x27;, //代理地址，这里设置的地址会代替axios中设置的baseURL ws: true, //// proxy websockets changeOrigin: true,// 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123; //pathRewrite方法重写url &#x27;^/api&#x27;: &#x27;/&#x27;, &#125;, &#125;, &#125;, &#125;, // webpack配置 链式 chainWebpack: (config) =&gt; &#123; // 1、取消预加载增加加载速度 config.plugins.delete(&#x27;preload&#x27;) config.plugins.delete(&#x27;prefetch&#x27;) // 2、vue中使用SVG图标，并且想批量导入，然后需要使用的时候直接添加就可以 config.module .rule(&#x27;svg&#x27;) .exclude.add(resolve(&#x27;src/assets/icons&#x27;)) .end() config.module .rule(&#x27;icons&#x27;) .test(/\\.svg$/) .include.add(resolve(&#x27;src/assets/icons&#x27;)) .end() .use(&#x27;svg-sprite-loader&#x27;) .loader(&#x27;svg-sprite-loader&#x27;) .options(&#123; symbolId: &#x27;icon-[name]&#x27;, &#125;) .end() // 3、图片处理 const imagesRule = config.module.rule(&#x27;images&#x27;) imagesRule.uses.clear() //清除原本的images loader配置 imagesRule .test(/\\.(jpg|gif|png|svg)$/) .exclude.add(path.join(__dirname, &#x27;../node_modules&#x27;)) //不对node_modules里的图片转base64 .end() .use(&#x27;url-loader&#x27;) .loader(&#x27;url-loader&#x27;) .options(&#123; name: &#x27;img/[name].[hash:8].[ext]&#x27;, limit: 6000000 &#125;) config.optimization.splitChunks(&#123; cacheGroups: &#123; vendors: &#123; name: &#x27;chunk-vendors&#x27;, minChunks: pageNum, test: /node_modules/, priority: -10, chunks: &#x27;initial&#x27;, &#125;, elementUI: &#123; name: &#x27;chunk-elementUI&#x27;, // split elementUI into a single package priority: 20, // the weight needs to be larger than libs and app or it will be packaged into libs or app test: /[\\\\/]node_modules[\\\\/]_?element-ui(.*)/, // in order to adapt to cnpm &#125;, commons: &#123; name: &#x27;chunk-commons&#x27;, test: resolve(&#x27;src/components&#x27;), // can customize your rules minChunks: 3, // minimum common number priority: 5, reuseExistingChunk: true, &#125;, &#125;, &#125;) &#125;, // webpack配置 configureWebpack: (config) =&gt; &#123; // 为生产环境修改配置 if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; config.plugins.push( // 1、取消打印 new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; drop_debugger: true,//生产环境自动删除debugger drop_console: true, //生产环境自动删除console &#125;, warnings: false, &#125;, sourceMap: false, //关掉sourcemap 会生成对于调试的完整的.map文件，但同时也会减慢打包速度 parallel: true, //使用多进程并行运行来提高构建速度。默认并发运行数：os.cpus().length - 1。 &#125;), // 2、gzip压缩 new CompressionWebpackPlugin(&#123; filename: &#x27;[path].gz[query]&#x27;, algorithm: &#x27;gzip&#x27;, test: new RegExp(&#x27;\\\\.(&#x27; + productionGzipExtensions.join(&#x27;|&#x27;) + &#x27;)$&#x27;), threshold: 10240, minRatio: 0.8, &#125;) ) &#125; // 在这里配置后，减少了压缩的包内容，需要在public/index.html通过cdn方式再引入,注意对应的版本 config.externals = &#123; vue: &#x27;Vue&#x27;, &#x27;vue-router&#x27;: &#x27;VueRouter&#x27;, vuex: &#x27;Vuex&#x27;, axios: &#x27;axios&#x27;, jquery: &#x27;$&#x27;, moment: &#x27;moment&#x27;, &#x27;mint-ui&#x27;: &#x27;MINT&#x27; &#125;, // 别名配置 Object.assign(config, &#123; // 开发生产共同配置 resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;), &#x27;@c&#x27;: path.resolve(__dirname, &#x27;./src/components&#x27;), &#x27;@p&#x27;: path.resolve(__dirname, &#x27;./src/pages&#x27;) &#125; &#125; &#125;), config.output.filename = `[name].$&#123;Version&#125;.$&#123;Timestamp&#125;.js` //打包生成的文件 config.output.chunkFilename = `[name].$&#123;Version&#125;.$&#123;Timestamp&#125;.js` &#125;, // css相关 css: &#123; loaderOptions: &#123; // 配置全局sass scss: &#123; additionalData: `@import &quot;@/assets/css/reset.scss&quot;;@import &quot;@/assets/css/globle.scss&quot;;` //注意配置的键名 &#125;, // lib-flexible postcss: &#123; plugins: [ //remUnit这个配置项的数值是多少呢？？？ 通常我们是根据设计图来定这个值，原因很简单，便于开发。 //假如设计图给的宽度是750，我们通常就会把remUnit设置为75，这样我们写样式时，可以直接按照设计图标注的宽高来1:1还原开发。 require(&#x27;postcss-px2rem&#x27;)(&#123; remUnit: 37.5 &#125;) ] &#125; &#125; &#125;, parallel: require(&#x27;os&#x27;).cpus().length &gt; 1, // 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。 pwa: &#123;&#125;, // PWA 插件相关配置 pluginOptions: &#123;&#125;, // 第三方插件配置&#125;;"},{"title":"生成博客到部署","path":"2025/05/12/生成博客到部署/","text":"生成博客到部署 大体思路：开通Gitee Pages，自己写一个静态网站或者使用Jekyll、Hugo、Hexo来生成 Gitee Pages首先开通Gitee Pages： 需要注册登录到Gitee上，并且创建仓库，仓库名称最好和自己的个性地址一样,然后开源这个仓库，在服务中点击Gitee Pages，首次使用需要实名注册 生成ssh添加到Gitee仓库，详细的百度查一下，方便后续快速部署 更多访问https://gitee.com/help/articles/4136#article-header0 如果是想要自己手写的话就打包好上传到这个仓库即可 使用Hexohexo可以使用Markdown文档生成，相对于手写更加方便。 使用他上传首先需要安装Git、node，版本要求最后是看官网；一般来讲只要不是很老的都行。 安装Hexo 1npm install -g hexo-cli 准备一个文件夹，在文件夹地址中输入cmd回车，打开命令提示符，在文件夹中创建网站，并安装依赖 12hexo initnpm i 安装完成后输入 1hexo s 可以在 localhost:4000查看生成的网站 在根目录中找到_config.yml来配置 详细查看官网：https://hexo.io/zh-cn/docs/configuration 下面列举几个，每一个:后面都有一个空格 1234567891011title: 网站标题author: 作者language: 语言timezone: 时间url: Gitee Page、GitHub Pages等，github是：用户名.github.io，Gitee：用户名.gitee.iodeploy: type: git repo: 这里直接复制Gitee生成仓库时的地址，大致就是https://gitee.com/个性地址/仓库地址.git branch: master 安装依赖 1npm install hexo-deployer-git --save 然后进行部署 123hexo cleanhexo generatehexo deploy hexo clean 清除了你之前生成的东西。 hexo generate 生成静态文章，可以用 hexo g 缩写 hexo deploy 部署文章，可以用hexo d缩写 更多命令查看官网：https://hexo.io/zh-cn/docs/commands 如果没有配置ssh一般需要输入用户名和密码 配置主题hexo有很多主题，例如我使用的：Kira-Hexo 在你的 Hexo 项目根目录下运行 1npm i hexo-theme-kira 在 _config.yml 中，将 theme 的值修改为 kira（使用其他的就是其他的主题名称） 为了让 Kira-Hexo 正常工作，你还需要在 Hexo 项目的根目录下新建一个名为 _config.kira.yml 的文件，并在文件中填入下方的配置信息。（最好访问官网去看，可能会更新） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121avatar: https://raw.githubusercontent.com/ch1ny/PictureCDN/master/others/116359b4ccf19917.jpg # 网站 Logobackground: # 既是博客的背景，又是文章默认头图 path: https://raw.githubusercontent.com/ch1ny/PictureCDN/master/others/f0d5cc34c6e5aa7.jpg width: 1280 height: 720favicon: href: https://raw.githubusercontent.com/ch1ny/PictureCDN/master/others/116359b4ccf19917.jpg # 网站图标 type: image/png # 图标类型，可能的值有(image/png, image/vnd.microsoft.icon, image/x-icon, image/gif)# 附加图标库 使用说明：https://hexo.kira.host/config/iconiconlib: //at.alicdn.com/t/c/font_3299330_2a7ov96q7e3.csscdn: # 这里可以修改站点使用的库的CDN gitalk: css: https://unpkg.com/gitalk@latest/dist/gitalk.css js: https://unpkg.com/gitalk@latest/dist/gitalk.min.jsbeian: 赣ICP备******号 # 备案号（选填，此乃中国特色，不得不尝）menu: 回到首页: - / - icon-home 文章归档: # 使用说明：https://docs.kira.com/article/archive - /archive.html - icon-container 关于本人: - /about.html - icon-user 我的朋友: - /friends.html # 使用说明：https://docs.kira.com/article/py - icon-teamwidgets: - social - category - tagcloudmaxTagcloud: 0 # 标签云组件显示的标签数量，0 表示不限制social: QQ: - tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1056317718&amp;website=www.oicqzone.com - icon-QQ - rgb(49, 174, 255) - rgba(49, 174, 255, .1) 哔哩哔哩: - https://space.bilibili.com/27905679 - icon-bilibili - rgb(231, 106, 141) - rgba(231, 106, 141, .15) GitHub: - https://github.com/ch1ny/ - icon-github - rgb(25, 23, 23) - rgba(25, 23, 23, .15) Gitee: - https://gitee.com/ch1ny/ - icon-gitee - rgb(165, 15, 15) - rgba(165, 15, 15, .15)color: # 配色方案，从first到seventh为优先级为1-7的颜色，默认为彩虹配色 first: # 同时作为主题色 r: 49 g: 174 b: 255 second: r: 255 g: 78 b: 106 third: r: 255 g: 185 b: 0 fourth: r: 51 g: 213 b: 122 fifth: r: 0 g: 219 b: 255 sixth: r: 255 g: 69 b: 0 seventh: r: 144 g: 144 b: 255# 评论区gitalk: active: true # 是否启用 gitalk admin: -your github username- # 拥有对该repo进行操作的 GitHub username owner: -your github username- # 持有该 repo 的 GitHub username repo: -issue repo name- # 存放评论的 issue 所在的 repo clientID: -id- # GitHub Client ID clientSecret: -key- # GitHub Client Secret title: &#x27;&#x27; # Gitalk Issue Titlecopyright: &#x27;&lt;strong&gt;版权声明：&lt;/strong&gt;本文采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 3.0 CN&lt;/a&gt; 协议进行许可&#x27;copyTip: &quot;著作权归作者所有。\\n商业转载请联系作者获得授权，非商业转载请注明出处。\\n来源：%url&quot; # 自定义复制版权文案,使用 %url 代替当前页面URL, 修改为false禁用# achive widget behaviorwidgetAchive: #文章归档组件 archive_type: &#x27;year&#x27; #按月展示还是按年展示 show_count: true #是否展示数量widgetLink: #链接组件 - title: &lt;title&gt; img: &lt;img_path&gt; link: &lt;url&gt; - title: &lt;title&gt; img: &lt;img_path&gt; link: &lt;url&gt;# 自定义侧边栏尾部内容sidebar: &#x27;&#x27; 最后在命名行输入 123hexo cleanhexo ghexo d 等待部署完成后去Gitee的仓库找到 Gitee Pages服务，点击更新。 更新博客如果有新的博客内容要更新，找到根目录的source/_posts文件夹，在里面写Markdown文档的内容，然后再命令行输入 123hexo chexo ghexo d 部署完成后去Gitee的仓库找到 Gitee Pages服务，点击更新。 当然在本地查看效果再去部署最好。"},{"title":"npm和yarn常用命令","path":"2025/05/12/npm和yarn常用命令/","text":"npm和yarn常用命令NPM NPM命令 操作 npm init 初始化Node项目，生成package.json文件 npm root 查看本地安装目录 npm install 安装本地依赖包 npm install --save 安装运行依赖包，并且将其保存至package.json文件中 npm install --save-dev 安装开发依赖包，并且将其保存至package.json文件中 npm update 更新本地依赖包 npm ls 查看本地依赖包 npm uninstall 卸载本地依赖包 npm root -g 查看全局安装目录 npm install -g 安装全局依赖包 npm update -g 更新全局依赖包 npm ls -g 查看全局依赖包 npm uninstall -g 卸载全局依赖包 npm info 查看依赖包信息 npm run 执行scripts配置的命令 npm help NPM帮助命令 YARN YARN命令 操作 yarn init 初始化Node项目 yarn 安装本地依赖包 yarn add 安装运行依赖包，并且保存至package.json文件中 yarn add --dev 安装开发依赖包，并且保存至package.json文件中 yarn upgrade 更新本地依赖包 yarn remove 卸载本地依赖包 yarn global add 安装全局依赖包 yarn global upgrade 更新全局依赖包 yarn global list 查看全局依赖包 yarn global remove 卸载全局依赖包"},{"title":"nvm管理node版本nrm管理npm镜像","path":"2025/05/12/nvm管理node版本nrm管理npm镜像/","text":"nvm使用教程1.nvm是什么：nvm全名nodejs version manage,是一个nodejs的版本管理工具。 2.nvm有什么作用：nvm可以控制多个nodejs版本，没有安装nvm之前一个电脑上面只能有一个nodejs版本，开发中，新项目一般使用较新的nodejs版本，老项目使用老版本的nodejs,来回删除安装nodejs就很麻烦，于是有了nvm的诞生，他可以控制多个nodejs版本，对于前端开发人员来说是很方便的一个实用工具。 3.安装nvm需要注意事项： 安装nvm之前一定要把电脑上面的nodejs删干净，避免后面安装失败； 下载安装包，安装时路径不能有中文和空格，避免后面安装失败； 安装路径时nodejs路径不能为C:\\后面需要有一个文件夹套着 ,避免后面安装成功却使用不了nodejs; 一定要使用管理员身份打开终端或者PowerShell执行命令行操作,避免后面切换nodejs失败； 4.nvm下载地址：https://github.com/coreybutler/nvm-windows/releases 5.下载安装包：从githuab上面可以下载最新版本，这里讲的是windows系统安装nvm,从网址中往下划拉会看到如图所示的各种nvm版本： 点击nvm-setup.zip安装包，解压之后直接安装 6.配置settings.txt在安装好的nvm的目录下找到settings.text文件，添加下面两行代码设置淘宝镜像 12nvm node_mirror https://npm.taobao.org/mirrors/node/nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 7.检查nvm是否安装成功打开终端输入nvm -v查看版本是否安装成功，成功的效果如图所示： 8.管理nodejs1、查看本地安装的所有版本 12nvm list 查看电脑上已安装的nodejs版本号nvm list available 显示所有可下载的nodejs版本号 2、安装需要使用的node版本号 1nvm install 10.16.0 3、使用该版本号 1nvm use 10.16.0 4.卸载nodejs版本号 1nvm uninstall 10.16.0 9.nvm命令行提示12345678910111213nvm arch 显示node是运行在32位还是64位nvm version 显示nvm版本号nvm install 版本号 安装该版本号的nodejsnvm uninstall 版本号 卸载该版本的nodejsnvm use 版本号 使用该版本的nodejsnvm list 查看已安装的nodejs版本nvm list available 显示可下载的nodejs版本号nvm on 开启nodejs版本管理nvm off 关闭nodejs版本管理nvm proxy [url] 设置下载代理,不添加url，显示当前代理，将url设置为none时则移除代理nvm node_mirror [url] 设置node镜像，默认url是https://nodejs.org/dist/,设置url后可在安装nvm的目录下settings.txt文件查看,也可操作nvm npm_mirror [url] 设置npm 镜像，默认url是https://github.com/npm/cli/archive,设置url后可在nvm目录下settings.txt文件查看，也可操作nvm root [path] 设置存储不同版本的nodejs目录，如未设置，默认使用当前目录 10.安装后没有效果检查是否在安装NVM之前安装了node，如果安装过，先卸载node，确保C:\\Program Files文件夹中没有node或nodejs文件夹 nrm使用教程Github地址：https://github.com/Pana/nrm 1.nrm是什么nrm（npm registry manager）是一个可以方便地管理和切换多个 npm 镜像源的工具。 2.安装nrm1npm install -g nrm 3.查看可以使用的镜像1nrm ls 4.使用镜像使用淘宝镜像taobao 1nrm use taobao 5.添加镜像添加淘宝镜像（默认有此处仅为演示） 1nrm add taobao https://registry.npmmirror.com 6.查看镜像源1npm config get registry 通常都是没有问题，也可以使用 nrm ls 查看哪一个前面有*来确认 7.清除缓存1npm cache clean --force 切换镜像后可能需要清除缓存，有时候不清楚会出现问题"},{"title":"uniapp","path":"2025/05/12/uniapp/","text":"uniappHBuilderX创建在点击工具栏里的文件 -&gt; 新建 -&gt; 项目（快捷键Ctrl+N），选择uni-app类型，输入工程名，选择模板，点击创建，即可成功创建。 uni-app自带的模板有 默认的空项目模板、Hello uni-app 官方组件和API示例，还有一个重要模板是 uni ui项目模板，日常开发推荐使用该模板，已内置大量常用组件。 vue-cli创建 使用这个一般就是要用到TS，因为HBuilderX对TS的支持目前没有达到需求，存在一些问题不能识别，所以使用vscode 用命令的形式创建，这一部分的详细安装看官方，主要是还得安装几个插件 全局安装 vue-cli 1npm install -g @vue/cli 创建uni-app 使用正式版（对应HBuilderX最新正式版） 1vue create -p dcloudio/uni-preset-vue my-project 复制代码 使用alpha版（对应HBuilderX最新alpha版） 1vue create -p dcloudio/uni-preset-vue#alpha my-alpha-project 复制代码 使用Vue3/Vite版 创建以 javascript 开发的工程（如命令行创建失败，请直接访问gitee下载模板） 1npx degit dcloudio/uni-preset-vue#vite my-vue3-project 复制代码 1npx degit dcloudio/uni-preset-vue#vite-alpha my-vue3-project 复制代码 创建以 typescript 开发的工程（如命令行创建失败，请直接访问gitee下载模板） 1npx degit dcloudio/uni-preset-vue#vite-ts my-vue3-project 复制代码 此时，会提示选择项目模板（使用Vue3/Vite版不会提示，目前只支持创建默认模板），初次体验建议选择 hello uni-app 项目模板，如下所示： 注意 Vue3/Vite版要求 node 版本^14.18.0 || &gt;=16.0.0 如果使用 HBuilderX（3.6.7以下版本）运行 Vue3/Vite 创建的最新的 cli 工程，需要在 HBuilderX 运行配置最底部设置 node路径 为自己本机高版本 node 路径（注意需要重启 HBuilderX 才可以生效） HBuilderX Mac 版本菜单栏左上角 HBuilderX-&gt;偏好设置-&gt;运行配置-&gt;node路径 HBuilderX Windows 版本菜单栏 工具-&gt;设置-&gt;运行配置-&gt;node路径 命令式的运行发布：https://uniapp.dcloud.net.cn/quickstart-cli.html#%E8%BF%90%E8%A1%8C%E3%80%81%E5%8F%91%E5%B8%83uni-app 安装插件 uni-create-view：快速创建视图与组件 uni-helper：代码提示 uniapp小程序扩展：鼠标悬停查看文档 安装TS1pnpm i D @types/wechat-miniprogram @uni-helper/uni-app-types 配置tsconfig.json 123456789101112&#123; &quot;compilerOptions&quot;:&#123; &quot;types&quot;:[ &quot;@dcloudio/types&quot;, &quot;@types/wechat-miniprogram&quot;, &quot;@uni-helper/uni-app-types&quot; ] &#125;, &quot;vueCompilerOptions&quot;:&#123; &quot;experimentalRuntimeMode&quot;:&quot;runtime-uni-app&quot; &#125;&#125; 设置文件关联打开设置，搜索文件关联 设置”项”为 manifest.json “值” 为 jsonc 这个可以写注释 设置”项”为 pages.json “值” 为 jsonc 这个不能写注释 uni-uiHBuilderX：直接在官网导入即可 npm： vue.config.js 文件 ，增加 @dcloudio/uni-ui 包的编译即可正常 123module.exports = &#123; transpileDependencies:[&#x27;@dcloudio/uni-ui&#x27;]&#125; 准备 sass 12npm i sass -D 或 yarn add sass -D npm i sass-loader@10.1.1 -D 或 yarn add sass-loader@10.1.1 -D 安装 uni-ui 1npm i @dcloudio/uni-ui 或 yarn add @dcloudio/uni-ui 配置easycom 123456789101112131415// pages.json&#123; &quot;easycom&quot;: &#123; &quot;autoscan&quot;: true, &quot;custom&quot;: &#123; // uni-ui 规则如下配置 &quot;^uni-(.*)&quot;: &quot;@dcloudio/uni-ui/lib/uni-$1/uni-$1.vue&quot; &#125; &#125;, // 其他内容 pages:[ // ... ]&#125; 安装uni-ui的TS支持 @uni-helper/uni-ui-types npm地址：https://www.npmjs.com/package/@uni-helper/uni-ui-types 安装 1npm i -D @uni-helper/uni-ui-types 配置 tsconfig.json，确保 compilerOptions.types 中含有 @dcloudio/types 和 @uni-helper/uni-ui-types 且 include 包含了对应的 vue 文件 123456789101112&#123; &quot;compilerOptions&quot;:&#123; &quot;types&quot;:[ ··· &quot;@dcloudio/types&quot;, &quot;@uni-helper/uni-ui-types&quot; ] &#125;, &quot;vueCompilerOptions&quot;:&#123; &quot;experimentalRuntimeMode&quot;:&quot;runtime-uni-app&quot; &#125;&#125; 封装拦截器Promise封装1234567891011121314151617181920212223242526272829class API &#123; request(url, method = &quot;GET&quot;, data) &#123; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url:url, method, data, success: (res) =&gt; &#123; resolve(res.data) &#125;, fail: (err) =&gt; &#123; reject(err) &#125; &#125;) &#125;) &#125; get(url, data) &#123; return this.request(url, &quot;GET&quot;, data) &#125; post(url, data) &#123; return this.request(url, &quot;POST&quot;, data) &#125;&#125;const axios = new API()export default axios uni.addInterceptor封装拦截器12345678910111213141516171819202122232425262728293031323334353637383940414243const BASE_URL = &quot;http://localhost:3000&quot;const httpInterceptor = &#123; // 拦截前触发 invoke(options)&#123; // 非http开头的地址添加基础地址 if(!options.url.startsWith(&#x27;http&#x27;))&#123; options.url = options.url + BASE_URL &#125; // 超时时间 options.timeout = 10000 // 添加标识 options.header = &#123; ...options.header, &#x27;source-client&#x27;:&quot;minapp&quot; &#125; // 添加token if(user.token)&#123; options.header.Authorization = `Bearer $&#123;user.token&#125;` &#125; &#125;, // 成功触发回调 success(args)&#123; args.data.code = 1 &#125;, // 失败回调 fail(err) &#123; console.log(&#x27;interceptor-fail&#x27;,err) &#125;, &#125;// 处理返回值uni.addInterceptor(&#123; returnValue(args) &#123; // 只返回 data 字段 return args.data &#125;&#125;)// 网络请求uni.addInterceptor(&#x27;request&#x27;,httpInterceptor)// 文件上传uni.addInterceptor(&#x27;uploadFile&#x27;,httpInterceptor) 自定义导航修改样式、关闭默认导航 12&quot;navigationStyle&quot;:&quot;custom&quot;,&quot;navigationBarTextStyle&quot;:&quot;white&quot; 由于不同的机型手机头部到安全区域的距离有一些差距，需要借助uniapp提供的方法来获取 123const &#123;safeAreaInsets&#125; = uni.getSystemInfoSync()```&lt;view :style=&quot;&#123; paddingTop:safeAreaInsets?.top + &#x27;px&#x27;&#125;&quot;&gt;&lt;/view&gt; 注意：Vue3版本使用Vue - Official（当前2.2.10有误）时需要关掉建议或使用老版本，否则会提示没有必要的报错，小程序的组件他没法识别"},{"title":"Vue项目开发常用功能","path":"2025/05/12/Vue项目开发常用功能/","text":"Vue项目开发常用功能vscode@配置在根目录创建jsconfig.json（如果没有默认生成） 123456789&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125; &#125;, &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;]&#125; 默认启动浏览器修改package.json 12// &quot;serve&quot;: &quot;vue-cli-service serve&quot;,&quot;serve&quot;: &quot;vue-cli-service serve --open&quot;, 在vue.confog.js中添加 12345devServer: &#123; open: true, // 默认打开浏览器 host: &#x27;localhost&#x27;, // 路径 port: 8080, // 端口&#125; 重置默认样式1npm install --save normalize.css main.js引入（在自己的样式之前） 1import &quot;normalize.css&quot; 或者在index.css中引入 1@import &quot;normalize.css&quot;; axios封装 创建axios.config.js管理不同环境的参数 创建axios.js/index.js管理请求拦截和响应拦截内容 根据对应的模块创建对应的文件/文件夹管理请求的接口 安装 1npm i axios 案例： axios.config.js 123456789101112131415// 根据process.env.NODE_ENV// - 开发环境：development// - 生产环境：production// - 测试环境：testlet BASE_UEL = &#x27;&#x27;let TIME_OUT = 10000if (process.env.NODE_ENV === &#x27;development&#x27;) &#123; BASE_UEL = &quot;&quot;&#125; else if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; BASE_UEL = &quot;&quot;&#125; else &#123; BASE_UEL = &quot;&quot;&#125;export &#123; BASE_UEL, TIME_OUT &#125; axios.js 1234567891011121314151617181920212223242526272829303132import axios from &#x27;axios&#x27;;import &#123; BASE_UEL, TIME_OUT &#125; from &#x27;./axios.config&#x27;;const request = axios.create(&#123; baseURL: BASE_UEL, timeout: TIME_OUT&#125;);// 添加请求拦截器request.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 const user = store.state.user; // 获取token， if (user) &#123; config.headers.Authorization = `Bearer $&#123;user.token&#125;`;// 设置token 也有可能是自定义的请求头 &#125; return config;&#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error);&#125;);// 添加响应拦截器request.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response.data;&#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error);&#125;);export &#123; request&#125; 模块接口 123456789101112131415161718192021222324252627import &#123; request &#125; from &#x27;./axios&#x27;;/** * * @param &#123;Object&#125; params get请求参数 * @returns */export const get = (params) =&gt; &#123; return request(&#123; method: &#x27;get&#x27;, url: &#x27;/***&#x27;, params &#125;)&#125;/** * * @param &#123;Object&#125; data post请求参数 * @returns */export const post = (data) =&gt; &#123; return request(&#123; method: &#x27;post&#x27;, url: &#x27;/***&#x27;, data &#125;)&#125; 无感刷新Token概述：服务器生成token的过程中，会有两个时间，一个是token失效时间，一个是token刷新时间，刷新时间肯定比失效时间长，当用户的 token 过期时，你可以拿着过期的token去换取新的token，来保持用户的登陆状态，当然你这个过期token的过期时间必须在刷新时间之内，如果超出了刷新时间，那么返回的依旧是 401。 处理流程： 在axios的拦截器中加入token刷新逻辑 当用户token过期时，去向服务器请求新的 token 把旧的token替换为新的token 然后继续用户当前的请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * 封装 axios 请求模块 */import axios from &quot;axios&quot;;import jsonBig from &quot;json-bigint&quot;;import store from &quot;@/store&quot;;import router from &quot;@/router&quot;;// axios.create 方法：创建一个axios实例const request = axios.create(&#123; baseURL: &quot;http://ttapi.research.itcast.cn/&quot; // 基础路径&#125;);/** * 配置处理后端返回数据中超出 js 安全整数范围问题 */request.defaults.transformResponse = [ function(data) &#123; try &#123; return jsonBig.parse(data); &#125; catch (err) &#123; return &#123;data&#125;; &#125; &#125;];// 请求拦截器request.interceptors.request.use( function(config) &#123; const user = store.state.user; if (user) &#123; config.headers.Authorization = `Bearer $&#123;user.token&#125;`; &#125; // Do something before request is sent return config; &#125;, function(error) &#123; // Do something with request error return Promise.reject(error); &#125;);// 响应拦截器request.interceptors.response.use( // 响应成功进入第1个函数 // 该函数的参数是响应对象 function(response) &#123; // Any status code that lie within the range of 2xx cause this function to trigger // Do something with response data return response; &#125;, // 响应失败进入第2个函数，该函数的参数是错误对象 async function(error) &#123; // Any status codes that falls outside the range of 2xx cause this function to trigger // Do something with response error // 如果响应码是 401 ，则请求获取新的 token // 响应拦截器中的 error 就是那个响应的错误对象 console.dir(error); if (error.response &amp;&amp; error.response.status === 401) &#123; // 校验是否有 refresh_token const user = store.state.user; if (!user || !user.refresh_token) &#123; router.push(&quot;/login&quot;); // 代码不要往后执行了 return; &#125; // 如果有refresh_token，则请求获取新的 token try &#123; const res = await axios(&#123; method: &quot;PUT&quot;, url: &quot;http://ttapi.research.itcast.cn/app/v1_0/authorizations&quot;, headers: &#123; Authorization: `Bearer $&#123;user.refresh_token&#125;` &#125; &#125;); // 如果获取成功，则把新的 token 更新到容器中 console.log(&quot;刷新 token 成功&quot;, res); store.commit(&quot;setUser&quot;, &#123; token: res.data.data.token, // 最新获取的可用 token refresh_token: user.refresh_token // 还是原来的 refresh_token &#125;); // 把之前失败的用户请求继续发出去 // config 是一个对象，其中包含本次失败请求相关的那些配置信息，例如 url、method 都有 // return 把 request 的请求结果继续返回给发请求的具体位置 return request(error.config); // 重新请求 &#125; catch (err) &#123; // 如果获取失败，直接跳转 登录页 console.log(&quot;请求刷线 token 失败&quot;, err); router.push(&quot;/login&quot;); &#125; &#125; return Promise.reject(error); &#125;);export default request; 跨域配置1234567891011121314devServer: &#123; proxy: &#123; // 前缀 &#x27;/api&#x27;: &#123; // target 转发后的目标地址 target: &#x27;http://localhost:8080/&#x27;, // pathRewrite 重写路径 调用真正的接口时替换掉请求前缀 // pathRewrite 发送请求时，请求路径重写 /api/xxx -&gt; /xxx （去掉/api） pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;, ws: true,//用于支持websocket changeOrigin: true,//欺骗后端 代理服务器此时会根据请求的 target 地址修改 Host &#125; &#125;,&#125;, 按需引入官网的小问题 官方网站描述的内容没有及时更新 12345678910111213141516// babel.config.jsmodule.exports = &#123; presets: [ &#x27;@vue/cli-plugin-babel/preset&#x27;, [&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false &#125;] ], &quot;plugins&quot;: [ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125; 移动端 rem 适配 postcss-pxtorem 是一款 postcss 插件，用于将单位转化为 rem lib-flexible 用于设置 rem 基准值 一、使用 lib-flexible 动态设置 REM 基准值（html 标签的字体大小）1、安装 12# yarn add amfe-flexiblenpm i amfe-flexible 2、然后在 main.js 中加载执行该模块 1import &#x27;amfe-flexible&#x27; 最后测试：在浏览器中切换不同的手机设备尺寸，观察 html 标签 font-size 的变化。 二、使用 postcss-pxtorem将 px 转为 rem1、安装 123# yarn add -D postcss-pxtorem# -D 是 --save-dev 的简写npm install postcss-pxtorem -D 2、然后在项目根目录中创建 postcss.config.js 文件 1234567891011121314151617181920module.exports = &#123; plugins: &#123; // VueCLI 默认配置了 // &#x27;autoprefixer&#x27;: &#123; // browsers: [&#x27;Android &gt;= 4.0&#x27;, &#x27;iOS &gt;= 8&#x27;] // &#125;, &#x27;postcss-pxtorem&#x27;: &#123; // 设置设计稿宽度的1/10（插件将一行分为10分） // rootValue可以接收两种类型：数字/函数 // 375的设计稿就直接使用数字，如果有不同的就使用函数进行判断，postcss-pxtorem会对每一个css进行判断 // rootValue: 37.5, rootValue(&#123; file &#125;) &#123; // vant案例 // 如果使用别的可以打印查看，然后根据路径来判断 // 此处vant是375的设计稿，项目使用的是750的设计稿 return file.indexOf(&#x27;vant&#x27;) !== -1 ? 37.5 : 75; &#125;, propList: [&#x27;*&#x27;] &#125; &#125;&#125; 3、配置完毕，重新启动服务 最后测试：刷新浏览器页面，审查元素的样式查看是否已将 px 转换为 rem。 注意行内样式是不能转换 Vuex持久化管理 持久化- 前端持久化-后端持久化-都是通过缓存来做 localStorage-自己写也行，也可以用插件 原理-刷新页面-所有的东西都销毁重来，Vuex 都会重来， 要保证重新初始化的时候能够读取到之前存储的数据-从缓存中读取数据 初始化的时候从缓存中读取 修改的状态的时候存入缓存 登录逻辑 点击登录后 可以选择性的添加（人机判断） 判断用户名/密码的前端验证 判断是否符合规则否则按钮无法点击 请求接口登录 成功则跳转页面保存对应的用户数据 失败则弹出对应的错误提示 验证成功后将对应的Token保存 分别保存到浏览器和vuex 保存到浏览器是防止刷新数据丢失 保存到vuex是为了更好的性能 选择性的在封装的axios的请求拦截中携带Token 通过保存的Token判断用户的权限 获取用户权限对应的路由权限 获取用户权限对应的按钮权限 …… 通过路由和按钮的权限进行菜单和按钮渲染 菜单组件 如果确定了几层就可以直接写几层 如果不确定多少层就可以使用递归 按钮组件 也可以不封装 通过v-if，直接不渲染 通过disabled使按钮无法点击 账号密码登录 表单验证 显示提示文字 登录是否可以点击 同意协议 可选 调用账号密码登录的API 成功：跳转页面 + 消息提示 失败：消息提示 短信验证登录 表单验证 显示提示文字 验证码是否可以发送 验证码的倒计时 同意协议 可选 调用验证验证码的API 成功：跳转页面 + 消息提示 失败：消息提示 QQ登录使用QQ登录的前提 有一个已经备案的网站 进入QQ互联，登录注册 创建应用，提供域名、备案号、回调地址 审核通过后获取到应用的id和key 登录逻辑 点击QQ登录 打开登录弹窗 用户登录 登录成功返回页面 是否注册过 注册过、已经绑定：跳转首页 注册过、没有绑定：进行手机号/邮箱绑定 未注册：进行信息的完善、跳转首页 使用QQ登录按钮 引用JS SDK的JavaScript文件 ``` 1234567891011 - 填入APPID和回调地址2. 在webpack中配置 ```javascript configureWebpack:&#123; externals:&#123; qc:&#x27;QC&#x27; // 包名称：全局变量名称 &#125; &#125; 在使用的地方导入 放置QQ登录按钮 123456&lt;span id=&quot;qqLoginBtn&quot;&gt;&lt;/span&gt;&lt;script type=&quot;text/javascript&quot;&gt; QC.Login(&#123; btnId:&quot;qqLoginBtn&quot; //插入按钮的节点id&#125;);&lt;/script&gt; 默认是小窗口 通过审查元素复制小窗口地址 手动写a标签和img标签、填入地址 可以选择性的删除qc和span的代码 但是webpack的qc还是有用的，后续获取QQ信息要使用 登录 判断是否登录成功 调用获取openId的方法 请求登录的API 1234567891011121314151617181920212223 // 确保QQ已经登录if (QC.Login.check()) &#123; // 第三方唯一标识QQ唯一标识 QC.Login.getMe((openId) =&gt; &#123; unionId.value = openId // 请求后台，做QQ登录 userQQLogin(openId).then(data =&gt; &#123; // 登录成功：data.result 用户信息 // 1. 存储用户信息 const &#123; id, account, avatar, mobile, nickname, token &#125; = data.result store.commit(&#x27;user/setUser&#x27;, &#123; id, account, avatar, mobile, nickname, token &#125;) store.dispatch(&#x27;cart/mergeCart&#x27;).then(() =&gt; &#123; // 2. 跳转到来源页或者首页 router.push(store.state.user.redirectUrl) // 3. 成功提示 Message(&#123; type: &#x27;success&#x27;, text: &#x27;QQ登录成功&#x27; &#125;) &#125;) &#125;).catch(e =&gt; &#123; // 登录失败：没有绑定 isBind.value = false &#125;) &#125;)&#125; 成功：获取用户信息等后续业务 失败：没有绑定平台 有账号未绑定 获取QQ的头像昵称等信息 1234QC.api(&#x27;get_user_info&#x27;).success(res =&gt; &#123; avatar.value = res.data.figureurl_qq_1 nickname.value = res.data.nickname&#125;) 表单校验手机号/发送验证码 绑定账号，跳转页面 没有账号没有绑定 需要进行对应的表单验证 判断用户是否存在/两次密码是否一致 绑定账号 退出登录 清除Token的信息 删除本地的用户信息 跳转到登录页面 支付逻辑 点击去支付 判断是否选择商品 选择收货地址 电商类 订单页面（内容的选择和确认订单）外卖等 选择支付的方式 发送请求 获取url，展示二维码 弹出二维码/或跳转预支付页面 短轮询（最简单粗暴就是定时器反复请求接口） 判断用户是否支付 判断是否支付成功或者超时 成功 停止定时器 删除购物车对应的数据 超时 停止定时器 提示用户支付超时 返回购物车/跳转超时页面 前端发送信息（不要包含金额等信息，前端是不安全的，交个后端处理） 后台服务的标准地址+支付页面地址+订单信息+回跳地址 通过后端处理后返回支付宝/微信的二维码 同步支付结果到后台、防止支付过程中断（如果支付出现异常可以进场对账） 权限 路由权限和按钮权限 路由权限 创建路由时区分好需要权限的路由，不要一次性添加，后面匹配对应的权限筛选后添加 创建路由时可以考虑使用要加一个属性用于配合后端判断权限等级 创建路由时保存好静态路由，用于退出登录后切换账号清空路由；也可以手动刷新 1234567891011const createRouter = () =&gt; new VueRouter(&#123; mode: &#x27;hash&#x27;,// hash带# history不带# routes&#125;)// 初次创建的路由，在最后有导出const router = createRouter()//写一个重置路由的方法，切换用户后，或者退出时清除动态加载的路由export function resetRouter() &#123; const newRouter = createRouter() router.matcher = newRouter.matcher // 最开始的路由赋值给最新的路由&#125; 创建路由守卫对需要权限的路由进行拦截 12345678910router.beforeEach((to, from, next) =&gt; &#123; // 进入的路由对象 通常判断不是login就要判断权限 if (to.path !== &#x27;/login&#x27;) &#123; const token = localStorage.getItem(&#x27;token&#x27;) !token ? next(&#123; path: &#x27;/home&#x27; &#125;) : next() &#125; else &#123; next() &#125;&#125;) 登录后请求后端返回对应账号可使用的路由，持久化保存后进行筛选 筛选好对应账号权限的路由，遍历使用this.$router.addRoute(&quot;Router&quot;, item)添加 最后添加404路由 按钮权限 获取后端传递的权限等级，根据对应的规则判断权限 使用v-if/自定义属性/disabled等方法来设置需要权限的按钮 打印1.使用步骤安装 1npm install vue-print-nb --save 在main.js中引入 12import Print from &#x27;vue-print-nb&#x27;Vue.use(Print) 在组件的打印区域标签上加 id=”printArea” 1&lt;div id=&quot;printArea&quot;&gt; 打印区域 &lt;div&gt; 在组件的打印按钮标签上使用指令 v-print=”print”,print是配置对象 1&lt;el-button v-print=&quot;print&quot; type=&quot;primary&quot;&gt;打印&lt;/el-button&gt; 在组件的data中定义print配置对象 1234567891011121314151617print: &#123; id: &#x27;printArea&#x27;, popTitle: &#x27;打印&#x27;, // 打印配置页上方标题 extraHead: &#x27;&#x27;, //最上方的头部文字，附加在head标签上的额外标签,使用逗号分隔 preview: &#x27;&#x27;, // 是否启动预览模式，默认是false（开启预览模式，可以先预览后打印） previewTitle: &#x27;&#x27;, // 打印预览的标题（开启预览模式后出现）, previewPrintBtnLabel: &#x27;&#x27;, // 打印预览的标题的下方按钮文本，点击可进入打印（开启预览模式后出现） zIndex: &#x27;&#x27;, // 预览的窗口的z-index，默认是 20002（此值要高一些，这涉及到预览模式是否显示在最上面） previewBeforeOpenCallback() &#123;&#125;, //预览窗口打开之前的callback（开启预览模式调用） previewOpenCallback() &#123;&#125;, // 预览窗口打开之后的callback（开启预览模式调用） beforeOpenCallback() &#123;&#125;, // 开启打印前的回调事件 openCallback() &#123;&#125;, // 调用打印之后的回调事件 closeCallback() &#123;&#125;, //关闭打印的回调事件（无法确定点击的是确认还是取消） url: &#x27;&#x27;, standard: &#x27;&#x27;, extraCss: &#x27;&#x27;, &#125;, 2. 打印过滤（隐藏打印区域不需要打印的内容）只需要在组件的打印区域里，给需要隐藏的内容的标签上添加 1class=&quot;noprint&quot; 3. 配置打印的样式在全局样式中，新增标签，里面是打印时才生效的样式 123456789101112&lt;style media=&quot;print&quot;&gt;@page &#123; size: auto; margin: 3mm;&#125;html &#123; background-color: #ffffff; height: auto; margin: 0px;&#125;&lt;/style&gt; 4.处理常见的打印bug1. 全局打印生效 解决打印出现空白页的问题 解决el-table表格内容过多，打印不全问题 解决作用域污染问题导致el-table序号错位 1234567891011121314151617181920212223242526272829303132&lt;style media=&quot;print&quot; lang=&quot;scss&quot;&gt;@page &#123; size: auto; margin: 3mm;&#125;@media print &#123; html &#123; background-color: #ffffff; height: auto; margin: 0px; &#125; body &#123; border: solid 1px #ffffff; margin: 10mm 15mm 10mm 15mm; &#125; table &#123; table-layout: auto !important; &#125; .el-table__header-wrapper .el-table__header &#123; width: 100% !important; border: solid 1px #f2f2f2; &#125; .el-table__body-wrapper .el-table__body &#123; width: 100% !important; &#125; #pagetable table &#123; table-layout: fixed !important; &#125;&#125;&lt;/style&gt; 2. 局部打印，局限在当前组件里 在组件标签 1234567891011121314151617181920212223242526272829303132&lt;style media=&quot;print&quot; lang=&quot;scss&quot;&gt;@page &#123; size: auto; margin: 3mm;&#125;@media print &#123; html &#123; background-color: #ffffff; height: auto; margin: 0px; &#125; body &#123; border: solid 1px #ffffff; margin: 10mm 15mm 10mm 15mm; &#125; #printArea table &#123; table-layout: auto !important; &#125; #printArea .el-table__header-wrapper .el-table__header &#123; width: 100% !important; border: solid 1px #f2f2f2; &#125; #printArea .el-table__body-wrapper .el-table__body &#123; width: 100% !important; &#125; #printArea #pagetable table &#123; table-layout: fixed !important; &#125;&#125;&lt;/style&gt; 注意 启动打印后可以通过调整设置的缩放来调整显示比例 可以通过设置背景图形来控制页面是否使用彩色背景"},{"title":"Vue基础复习","path":"2025/05/12/Vue基础复习/","text":"Vue基础复习vue介绍与描述（个人理解） 编码简洁，体积小，运行效率高 采用组件化模式，提高代码复用率、且让代码更好维护 声明式编码，让编码人员无需直接操作DOM，提高开发效率 使用虚拟DOM 和 Diff算法，尽量复用DOM节点 vue还有大量的周边来配合使用，方便开始开发 Vue基础语法插值表达式 用于解析标签体内容 &#123;&#123;xxx&#125;&#125;，xxx 是 js 表达式，可以直接读取到 data 中的所有区域 指令语法 用于解析标签（包括：标签属性、标签体内容、绑定事件…） 举例：或简写为，xxx 同样要写 js 表达式，可以直接读取到 data 中的所有属性 数据绑定：v-bind/v-model Vue中有2种数据绑定的方式 单向绑定v-bind：数据只能从 data 流向页面 双向绑定v-model：数据不仅能从 data 流向页面，还可以从页面流向 data 计算属性：computed 要用的属性不存在，需要通过已有属性计算得来；底层借助了Objcet.defineProperty()方法提供的getter和setter get函数什么时候执行？ 初次读取时会执行一次 当依赖的数据发生改变时会被再次调用 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便 计算属性最终会出现在vm上，直接读取使用即可如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变如果计算属性确定不考虑修改，可以使用计算属性的简写形式写法如下： 123456789101112131415161718192021computed: &#123; // 完整写法 fullName: &#123; get() &#123; console.log(&#x27;get被调用了&#x27;) return this.firstName + &#x27;-&#x27; + this.lastName &#125;, set(value) &#123; console.log(&#x27;set&#x27;, value) const arr = value.split(&#x27;-&#x27;) this.firstName = arr[0] this.lastName = arr[1] &#125; &#125; // 简写 fullName() &#123; console.log(&#x27;get被调用了&#x27;) return this.firstName + &#x27;-&#x27; + this.lastName &#125; &#125; 侦听属性：watch 当被监视的属性变化时，回调函数自动调用，进行相关操作 监视的属性必须存在，才能进行监视，既可以监视data，也可以监视计算属性配置项属性immediate:false，改为 true，则初始化时调用一次 handler(newValue,oldValue)写法如下： 1234567891011121314151617// isHot必须在data或者computed中存在// 简写watch:&#123; isHot(newValue,oldValue)&#123; console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue) &#125;&#125;// 完整写法watch:&#123; isHot:&#123; deep: true,// 深度监听 immediate:true,// 初始化立即调用 handler(newValue,oldValue)&#123; console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue) &#125; &#125;&#125; 样式绑定：:class/:style :class=”xxx”/:style=”xxx”，xxx 可以是字符串、数组、对象 字符串写法常用于：条件判断切换类名，或动态获取样式数组写法常用于：动态获取多个样式类名对象写法常用于：动态获取多个样式（通常是内联样式） 条件渲染：v-if/v-show v-if 切换频率较低的场景，因为不展示的DOM元素直接被移除 写法： v-if=”表达式” v-else-if=”表达式” v-else v-show 切换频率较高的场景，不展示的DOM元素未被移除，仅仅是使用样式隐藏掉display: none 写法： v-show=”表达式” 注意点：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到 列表渲染：v-for v-for指令 用于展示列表数据 写法： &lt;li v-for=&quot;(item, index) of items&quot; :key=&quot;index&quot;&gt;，这里key可以是index，更好的是遍历对象的唯一标识 可遍历：数组、对象、字符串、指定次数 过滤器：filter 对要显示的数据进行特定格式化后再显示 使用过滤器：&#123;&#123; xxx | 过滤器名&#125;&#125; 或 v-bind:属性 = &quot;xxx | 过滤器名&quot; 12345678910// 全局过滤器Vue.filter(&#x27;mySlice&#x27;,function(value)&#123; return value.slice(0,11)&#125;)// 局部过滤器filters:&#123; timeFormater(value, str=&quot;YYYY年MM月DD日 HH:mm:ss&quot;)&#123; return dayjs(value).format(str) &#125;&#125; 内置指令 v-bind：单向绑定解析表达式，可简写为: v-model：双向数据绑定 v-for：遍历数组 / 对象 / 字符串 v-on：绑定事件监听，可简写为@ v-show：条件渲染 v-if：条件渲染 v-else-if：条件渲染 v-else：条件渲染 v-text：向其所在的节点中渲染文本内容 v-html：向指定节点中渲染包含html结构的内容 v-cloak：本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性 通常会配合样式使用 123[v-cloak] &#123; display:none; &#125; v-once：所在节点在初次动态渲染后，就视为静态内容了，以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能 v-pre：可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译 自定义指令 对普通 DOM 元素进行底层操作 局部自定义指令 123456directives:&#123; 指令名:配置对象 &#125;directives:&#123; 指令名:回调函数 &#125; 全局自定义指令 12Vue.directive(指令名, 配置对象)Vue.directive(指令名, 回调函数) 钩子函数的参数： el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 案例：默认聚焦状态（回调函数） 1234567891011121314151617181920// 局部directives: &#123; focus: &#123; inserted: function (el) &#123; el.focus() &#125; &#125;&#125;// 全局Vue.directive(&#x27;focus&#x27;, &#123; bind(element, binding) &#123; element.value = binding.value &#125;, inserted(element, binding) &#123; element.focus() &#125;, update(element, binding) &#123; element.value = binding.value &#125;&#125;) 案例：默认聚焦状态（配置对象） 1234567891011121314151617181920212223242526272829303132333435// 局部directives: &#123; focus: &#123; // 指令与元素成功绑定时 bind(element, binding) &#123; element.value = binding.value &#125;, // 指令所在元素被插入页面时 inserted(element, binding) &#123; element.focus() &#125;, // 指令所在的模板被重新解析时 update(element, binding) &#123; element.value = binding.value &#125; &#125;&#125;// 全局Vue.directive(&#x27;focus&#x27;, &#123; focus: &#123; // 指令与元素成功绑定时 bind(element, binding) &#123; element.value = binding.value &#125;, // 指令所在元素被插入页面时 inserted(element, binding) &#123; element.focus() &#125;, // 指令所在的模板被重新解析时 update(element, binding) &#123; element.value = binding.value &#125; &#125;&#125;) 修饰符 触发特殊的事件/行为，从而达到一定的效果，并且可以连用 表单修饰符 修饰符名称 效果 .lazy 默认是数据发生改变的时候同步，使用.lazy则是焦点发生改变时同步 .number 默认的数据是字符串，使用.number可以转换为数字 .trim 自动过滤用户输入的首尾空白字符 事件修饰符 名称 可用版本 可用事件 说明 .stop 所有 任意 当事件触发时，阻止事件冒泡 .prevent 所有 任意 当事件触发时，阻止元素默认行为 .capture 所有 任意 当事件触发时，阻止事件捕获 .self 所有 任意 限制事件仅作用于节点自身 .once 2.1.4以上 任意 事件被触发一次后即解除监听 .passive 2.3.0以上 滚动 移动端，限制事件用不调用preventDefault()方法 例如@submit.prevent=&quot;submit&quot; 按键修饰符@keyup 别名修饰符 键值修饰符 对应按键 .delete .8/.46 回格 / 删除 .tab .9 制表 .enter .13 回车 .esc .27 退出 .space .32 空格 .left .37 左 .up .38 上 .right .39 右 .down .40 下 例如： @keyup.13=&quot;console.log($event)&quot;或者@keyup.enter=&quot;&quot; 鼠标修饰符 修饰符 可用版本 对应按键 .left 2.2.0 以上 左键 .right 2.2.0 以上 右键 .middle 2.2.0 以上 中键 组合修饰符 修饰符 可用版本 对应按键 .ctrl 2.1.0 以上 Ctrl键 .alt 2.1.0 以上 Alt键 .shift 2.1.0 以上 Shift键 .meta 2.1.0 以上 meta键（Windows系统键盘上为田键） 生命周期 Vue在关键时刻帮我们调用的一些特殊名称的函数 生命周期函数中的 this 指向是vm或组件实例对象 mounted发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作 beforeDestroy清除定时器、解绑自定义事件、取消订阅消息等收尾工作 组件 组件是可复用的 Vue 实例 定义组件名使用 kebab-case1Vue.component(&#x27;my-component-name&#x27;, &#123; /* ... */ &#125;) 使用 PascalCase1Vue.component(&#x27;MyComponentName&#x27;, &#123; /* ... */ &#125;) 组件注册123456789// 全局注册Vue.component(&#x27;my-component-name&#x27;, &#123; // ... 选项 ...&#125;)// 局部注册components: &#123; &#x27;component-a&#x27;: ComponentA, &#x27;component-b&#x27;: ComponentB&#125; 组件传值prop（父传子）prop大小写prop的大小写是不敏感的，及时在定义时使用驼峰命名，在使用时必须换成短横线分割命名 Prop 类型123456789props: &#123; title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object, callback: Function, contactsPromise: Promise // or any other constructor&#125; prop传值 列举的都需要在对应的组件定义，为了方便此处省略 字符串：直接传 1&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt; 数字：使用v-bind 1&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt; 布尔：使用v-bind 1&lt;blog-post v-bind:is-published=&quot;false&quot;&gt;&lt;/blog-post&gt; 数组：使用v-bind 1&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt; 对象：使用v-bind 123456&lt;blog-post v-bind:author=&quot;&#123; name: &#x27;Veronica&#x27;, company: &#x27;Veridian Dynamics&#x27; &#125;&quot;&gt;&lt;/blog-post&gt; property 123456789101112// data中的数据post: &#123; id: 1, title: &#x27;My Journey with Vue&#x27;&#125;&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;等价于&lt;blog-post v-bind:id=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt; 单选数据流 防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。如果直接操作浏览器会在控制台警告！ 如果我们需要改变子组件接收的数据，就在data或computed中保存 123456props: [&#x27;initialCounter&#x27;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; Prop 验证 对接收的数据指定验证要求 12345678910111213141516171819202122232425262728293031props: &#123; // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: &#x27;hello&#x27; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].includes(value) &#125; &#125; &#125; 自定义事件（子传父）123456// 子组件创建对应的事件sendSchoolName()&#123; this.$emit(&#x27;childEvent&#x27;,this.name)// 自定义事件的名称，传递的值&#125;，// 父组件接收&lt;CustomSchool @childEvent=&quot;getSchoolName&quot;/&gt; 插槽：slot 让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 ===&gt; 子组件 分类：默认插槽、具名插槽、作用域插槽 使用方式： 默认插槽 1234567891011父组件中： &lt;Category&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/Category&gt;子组件中：Category &lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 具名插槽：父组件指明放入子组件的哪个插槽slot=”footer”，如果是template可以写成v-slot:footer 123456789101112131415161718父组件中： &lt;Category&gt; &lt;template slot=&quot;center&quot;&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt;html结构2&lt;/div&gt; &lt;/template&gt; &lt;/Category&gt;子组件中： &lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 作用域插槽：scope用于父组件往子组件插槽放的html结构接收子组件的数据 数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定） 1234567891011121314151617181920212223242526272829303132333435父组件中： &lt;Category&gt; &lt;template scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是ul列表 --&gt; &lt;ul&gt; &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/Category&gt; &lt;Category&gt; &lt;template slot-scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是h4标题 --&gt; &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt; &lt;/template&gt; &lt;/Category&gt;子组件中： &lt;template&gt; &lt;div&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;], //数据在子组件自身 data() &#123; return &#123; games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;] &#125; &#125;, &#125; &lt;/script&gt; 全局事件总线 一种可以在任意组件间通信的方式 这个对象必须能够使用$on$emit$off方法去绑定、触发和解绑事件 定义全局事件总线 123456789101112import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App), beforeCreate() &#123; Vue.prototype.$bus = this // 安装全局事件总线 &#125;&#125;) 接收和销毁 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;school&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123; name &#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;School&quot;, data() &#123; return &#123; name: &quot;小黑&quot;, address: &quot;武汉&quot;, &#125;; &#125;, mounted() &#123; this.$bus.$on(&quot;hello&quot;, (data) =&gt; &#123; console.log(&quot;我是School组件，收到了数据&quot;, data); &#125;); &#125;, beforeDestroy() &#123; // 销毁事件 this.$bus.$off(&quot;hello&quot;); &#125;, &#125;;&lt;/script&gt; 发送 123456789101112131415161718192021222324&lt;template&gt; &lt;div class=&quot;student&quot;&gt; &lt;h2&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123; sex &#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Student&#x27;, data() &#123; return &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27; &#125; &#125;, methods: &#123; sendStudentName()&#123; this.$bus.$emit(&#x27;demo&#x27;, this.name) &#125; &#125; &#125;&lt;/script&gt; ref、mixin、插件、scopedref 应用在html标签上获取的是真实DOM元素，应用在组件标签上获取的是组件实例对象vc 打标识：或 获取：this.$refs.xxx mixin 混入 可以把多个组件共用的配置提取成一个混入对象（个人不建议使用，容易把简单事情复杂化） 12345678910111213141516171819202122var mixin = &#123; data: function () &#123; return &#123; message: &#x27;hello&#x27;, foo: &#x27;abc&#x27; &#125; &#125;&#125;new Vue(&#123; mixins: [mixin], data () &#123; return &#123; message: &#x27;goodbye&#x27;, bar: &#x27;def&#x27; &#125; &#125;, created () &#123; console.log(this.$data) // =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125; &#125;&#125;) 插件 用于增强Vue 1Vue.use(名称,值) 例如VueRouter 123import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;Vue.use(VueRouter) scoped样式 让样式在局部生效，防止冲突 1&lt;style scoped&gt; $nextTick this.$nextTick(回调函数)在下一次DOM更新结束后执行其指定的回调 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行 过渡与动画 vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 通常配合一些css或js的动画库：Animate.css、 Velocity.js等 过渡的类名 在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为 my-transition-enter。 案例 123456&lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456789101112131415161718// css.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 路由：vue-router基本写法1234567891011121314151617181920import VueRouter from &#x27;vue-router&#x27; // 引入VueRouterimport About from &#x27;../components/About&#x27; // 路由组件import Home from &#x27;../components/Home&#x27; // 路由组件// 创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123; routes:[ &#123; path:&#x27;/about&#x27;, component:About &#125;, &#123; path:&#x27;/home&#x27;, component:Home &#125; ]&#125;)//暴露routerexport default router 多级路由1234567891011121314151617181920routes:[ &#123; path:&#x27;/about&#x27;, component:About, &#125;, &#123; path:&#x27;/home&#x27;, component:Home, children:[ // 通过children配置子级路由 &#123; path:&#x27;news&#x27;, // 此处一定不要带斜杠，写成 /news component:News &#125;, &#123; path:&#x27;message&#x27;, // 此处一定不要写成 /message component:Message &#125; ] &#125;] 路由跳转 跳转方式 router-link标签 this.$reuter.push()/replace() 无痕浏览/forward()前进/back()后退/go(n)指定n 携带参数 params /xxx/:xxx/:xxx 有？是可选 {name:””,params:{xxx:’abc’,xxx:123}} query /xxx/xxx 在路径后面跟着 {path:””,query:{xxx:’abc’,xxx:123}} props（在组件内需要使用props接收） props:true 需要映射，所有params参数 props:{a:1,b:2}只能映射非params/query参数 props:route=&gt;({name:route.params.name,age:route.query.age,xxx:123}) 指定任何方式 meta 路由重复跳转 1234567Vue.use(Router)//获取原型对象上的push函数const originalPush = Router.prototype.push//修改原型对象中的push方法Router.prototype.push = function push(location) &#123; return originalPush.call(this, location).catch(err =&gt; err)&#125; 路由守卫 router.beforeEach全局前置守卫 to: 即将要进入的目标 from: 当前导航正要离开的路由 next：错误来源 router.afterEach 全局后置钩子 to: 即将要进入的目标 from: 当前导航正要离开的路由 / 路由独享的守卫 你可以直接在路由配置上定义 beforeEnter 守卫 组件内部使用 123456789101112131415beforeRouteEnter(to, from) &#123; // 在渲染该组件的对应路由被验证前调用 // 不能获取组件实例 `this` ！ // 因为当守卫执行时，组件实例还没被创建！ &#125;, beforeRouteUpdate(to, from) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候， // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this` &#125;, beforeRouteLeave(to, from) &#123; // 在导航离开渲染该组件的对应路由时调用 // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this` &#125;, history与hash路由的区别 区别 history没有#，刷新携带路由，默认404，需要配置返回首页 开发环境：脚手架默认配置好了 123devServer:&#123; historyApiFallback:true&#125; 生产环境 配置Nginx 123location/&#123; try_files $uri $uri / /index.html;&#125; hash：路由携带#，刷新不会携带路径，请求总是根路径，返回首页，没有404 原理 history：使用history对象的pushState()和replaceState() H5新增 hash：使用location对象的hash 路由跳转滚动条回到顶部12345new VueRouter(&#123; scrollBehavior(to,from,savedPosition)&#123; return &#123;x:0,y:0&#125; &#125;&#125;) 缓存路由组件作用：让不展示的路由组件保持挂载，不被销毁 123456789// 缓存一个路由组件&lt;keep-alive include=&quot;News&quot;&gt; // include中写想要缓存的组件名，不写表示全部缓存 &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;// 缓存多个路由组件&lt;keep-alive :include=&quot;[&#x27;News&#x27;,&#x27;Message&#x27;]&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; Vuex 用于共享数据 安装1npm install vuex --save 注册1234import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex) 常用配置1234567891011121314151617181920212223242526import Vue from &#x27;vue&#x27; //引入vueimport Vuex from &#x27;vuex&#x27; //引入vuexVue.use(Vuex) //使用vuex插件export default new Vuex.Store(&#123; //输出一个 vuex的仓库实例 state: &#123; #里面存储数据 【相当于 data 】 &#125;, getters: &#123; #获取state数据并处理返回 相当于computed &#125;, mutations: &#123; #里面写方法 同步改变state的值 参数一:state 参数二:payload ==&gt; 携带的东西 例如：Payload.name // 在定义方法时有可能会使用常量来定义，const ADD = &quot;ADD&quot; &#125;, actions: &#123; #里面写方法 调用mutations方法 改变state的值 ，可以写异步 // 参数一：context // context参数包含如下 // state, 等同于store.$state，若在模块中则为局部状态 // rootState, 等同于store.$state,只存在模块中 // commit, 等同于store.$commit // dispatch, 等同于store.$dispatch // getters 等同于store.$getters // 参数二：Payload &#125;, modules: &#123;#模块化 用于大型项目 多模块开发 &#125;&#125;) 使用state123456789101112#1 this.$store.state.数据属性#2 辅助函数模式//引入vuex 解构辅助函数 [亲自推荐]import &#123; mapState &#125; from &quot;vuex&quot;;export default &#123; computed: &#123; ...mapState([&#x27;数据属性1&#x27;,&#x27;数据属性2&#x27;]), #辅助函数的数据 在computed解构出来相当于挂着data上 可以直接用 &#125;&#125; 使用getters方法相当于 computed 12345678910#引入辅助函数import &#123; mapGetters &#125; from &quot;vuex&quot;;export default &#123; #在computed 使用 computed: &#123; ...mapGetters([&#x27;计算属性1&#x27;,&#x27;计算属性2&#x27;]) &#125;&#125;&lt;/script&gt; 使用vuex 的方法 MutationsMutations里面 是同步改变state值的方法 123456789101112131415161718192021#方法1 export default &#123; methods: &#123; 方法名() &#123; # 用 this.$store.commit(&#x27;mutations里面的函数触发&#x27;) this.$store.commit(&#x27;vuex mutations里面的方法名&#x27;) &#125; &#125;&#125;&lt;/script&gt;#方法2 引入vuex 解构辅助函数 [亲自推荐]import &#123; mapMutations &#125; from &quot;vuex&quot;;export default &#123; //方法 methods: &#123; ...mapMutations([&#x27;vuex mutations里面的方法名&#x27;,&#x27;同方法2&#x27;]) #方法名相当于挂着methods里面 &#125;,&#125; 使用vuex 的方法 Actions123456789101112131415161718192021222324252627282930313233343536export default new Vuex.Store(&#123; //输出一个 vuex的仓库实例 state: &#123; //里面存储数据 【相当于 data 】 userInfo: &#123;&#125;, //模拟储存用户信息 &#125;, mutations: &#123; //里面写方法 同步改变state的值 [规范写法 必须大写用下划线分割] #存储用户信息 SET_USER_INFO(state, payload) &#123; state.userInfo = payload &#125; &#125;, actions: &#123; #里面写方法 调用mutations方法 改变state的值 ，可以写异步 async getUserInfo(&#123; commit &#125;, data) &#123; // 方法参数1：上下文，参数2：形参 ... await new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; commit(&#x27;SET_USER_INFO&#x27;, data) resolve() &#125;, 1000); &#125;) &#125; &#125;,&#125;)#使用#写法1this.$store.dispatch(&#x27;actions里面的函数&#x27;, 数据)#写法2 辅助函数写法import &#123; mapActions &#125; from &quot;vuex&quot;;export default &#123; //方法 methods: &#123; ...mapActions([&#x27;actions里面的方法1&#x27;,&#x27;同方法2&#x27;]) //actions里面的方法1 解构actions里面的方法挂在methods里面 &#125;,&#125; 使用vuex 的 模块化module1234567891011121314151617181920212223242526# shopcar.js/** * 购物车 vuex 模块 */const state = &#123; price: 120, count: 20,&#125;const getters = &#123; calcPrice(state) &#123; return state.price * state.count &#125;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;export default &#123; namespaced: true, //如果是模块化开发 namespaced属性必填 【命名空间】 state, getters, mutations, actions&#125; 123456# store/index.jsexport default new Vuex.Store(&#123; //输出一个 vuex的仓库实例 modules: &#123; //模块化 用于大型项目 多模块开发 shopcar &#125;&#125;) 使用 12345export default &#123; computed: &#123; ...mapState(&#x27;模块名&#x27;, [&#x27;数据名1&#x27;,&#x27;数据名2&#x27;]) #同理mapMutations，mapActions 写法类似 &#125;,&#125; vuex使用数据/方法常规（无模块） 无辅助函数 state：this.$store.state.数据 getters：this.$store.getters.数据 actions：this.$store.dispatch(‘actions方法名’,所传值)； mutations：this.$store.commit(‘mutations方法名’,所传值)； 有辅助函数 key自定义名称，value对应vuex中数据/方法并且是字符串 state：mapState({key:value}) / mapState([value]) getters：mapGetters({key:value}) / mapGetters([value]) actions：mapActions({key:value}) / mapActions([value]) mutations：mapMutations({key:value}) / mapMutations([value]) 分模块并开启命名空间 无辅助函数 state：this.$store.state.模块名称.数据 getters：this.$store.getters.模块名称.数据 actions：this.$store.dispatch(‘模块名称/actions方法名’,所传值)； mutations：this.$store.commit(‘模块名称/mutations方法名’,所传值)； 有辅助函数 key自定义名称，value对应vuex中数据/方法并且是字符串，模块名称是字符串 state：mapState(模块名称,{key:value}) / mapState(模块名称,[value]) getters：mapGetters(模块名称,{key:value}) / mapGetters(模块名称,[value]) actions：mapActions(模块名称,{key:value}) / mapActions(模块名称,[value]) mutations：mapMutations(模块名称,{key:value}) / mapMutations(模块名称,[value])"},{"title":"Vue3基础复习","path":"2025/05/12/Vue3复习/","text":"可以访问线上的（尚硅谷版本，自己拷贝下来部署的）：https://vue3-study.pages.dev/ 下面的是黑马（好像是评论区别人发的） 一、Vue3.0介绍1、Vue3.0介绍在学习Vue3.0之前，先来看一下与Vue2.x的区别 会从如下几点来介绍 源码组织方式的变化 Composition API 性能提升 Vite Vue3.0全部使用TypeScript进行重写，但是90%的API还是兼容2.x,这里增加了Composition API也就是组合API. 在性能方面有了大幅度的提升，在Vue3.0中使用Proxy重写了响应式的代码，并且对编译器做了一定的优化，重写了虚拟DOM,让渲染有了很大的性能提升。 同时官方也提供了一款工具Vite,使用该工具，在开发阶段进行测试的时候，不需要进行打包，直接运行项目，提升了开发的效率 下面先来看一下源码组织方式： 源码采用TypeScript重写 使用Monorepo管理项目结构 首先，我们可以看到最开始是以compiler开头的包，这些都是与编译相关的代码。compiler-core是与平台无关的编译器，compiler-dom是浏览器平台下的编译器，依赖于compiler-core. compiler-sfc:用来编译单文件组件，依赖于compiler-core与compiler-dom compiler-ssr:是服务端渲染的编译器，依赖于compiler-dom reactivity:数据响应式系统 ·runtime-core·:是与平台无关的运行时 runtime-dom:是针对浏览器的运行时，用来处理元素DOM的api和事件等 runtime-test:进行测试的运行时 server-renderer：进行服务端渲染 shared:是VUE内部使用的一些公共的API size-check:是一个私有的包，用来检查包的大小 template-explorer:是在浏览器中运行的实时编译组件，会输出render函数 Vue构建完整版的Vue,依赖于compiler与runtime 2、不同的构建版本Vue3与Vue2一样，都提供了不同的构建版本，可以在不同的场合中使用。 和Vue2不同的是，在Vue3中不在构建UMD的模块化方式。 cjs模块化方式,也就是CommonJS模块化方式，在该模式下对应的文件是vue.cjs.js与vue.cjs.prod.js 这个两个文件都是完整版的vue,包含了运行时与编译器，vue.cjs.js是开发版，代码没有被压缩。 vue.cjs.prod.js:表示的是生产版本，代码被压缩过。 下面是global vue.global.js vue.global.prod.js vue.runtime.global.js vue.runtime.global.prod.js 以上四个js文件，都可以通过script方式进行导入，导入以后，会增加一个全局的Vue对象， vue.global.js vue.global.prod.js 以上两个文件包含了完整版的vue,包含编译器与运行时。vue.global.js是开发版本，代码没有被压缩，vue.global.prod.js是生产版本，代码进行了压缩。 vue.runtime.global.js vue.runtime.global.prod.js 以上两个文件，只包含了运行时，同样有开发版本与生产版本。 下面我们再来看一下browser vue.esm-browser.js vue.esm-browser.prod.js vue.runtime.esm-browser.js vue.runtime.esm-browser.prod.js 以上四个文件都包含了浏览器原生模块化的方式，在浏览器中可以直接通过script type=&#39;module&#39; 的方式来导入模块。 vue.esm-browser.js vue.esm-browser.prod.js 上面两个文件是，esmodule的完整版，包含了开发版本与生产版本， vue.runtime.esm-browser.js vue.runtime.esm-browser.prod.js 以上两个文件是运行时版本， 最后我们再来看一下bundler `vue.esm-bundler.js` `vue.runtime.esm-bundler.js` 以上两个文件没有打包所有的代码，需要配合打包工具来使用，这两个文件都是使用es module的模块化方式，内部通过import导入了runtime core vue.esm-bundler.js是完整版，其内部还导入了runtime-compiler,也就是编译器，我们使用脚手架创建的项目，默认导入了 vue.runtime.esm-bundler.js，这个文件只导入了运行时，也就是vue的最小版本，在打包的时候，只会打包我们使用到的代码，可以让vue的体积更小。 以上就是不同构建版本的介绍。 3、Composition API 设计动机Vue2.x在设计中小型项目的时候，使用非常方便，开发效率也高。但是在开发一些大型项目的时候也会带来一定的限制， 在Vue2.x中使用的API是Options API,该类型的API包含一个描述组件选项(data,methods,props等)的对象，在使用Options API开发复杂的组件的时候，同一个功能逻辑的代码被拆分到不同的选项中，这样在代码量比较多的情况下就会导致不停的拖动滚动条才能把代码全部看清，非常的不方便。 如下代码示例： 12345678910111213141516171819202122export default &#123; data()&#123; return &#123; position:&#123; x:0, y:0 &#125; &#125; &#125;, created()&#123; window.addEventListener(&#x27;mousemove&#x27;,this.handle) &#125; destroyed()&#123; window.removeEventListener(&#x27;mousemove&#x27;,this.handle) &#125;, methods:&#123; handle(e)&#123; this.position.x=e.pageX this.position.y=e.pageY &#125; &#125;&#125; 在上面的代码中，我们实现的是获取鼠标的位置，然后展示到页面中，如果现在需要在上面的程序中添加新的功能，可能需要在data和methods等选项中，添加新的代码，这样代码量比较多以后，在进行查看的时候，需要不断的拖动滚动条，非常麻烦。 而使用Composition API可以解决这样的问题。 下面先来看一下Composition API的介绍 Composition API 是Vue.js 3.0 中新增的一组API，是一组基于函数的API,可以更灵活的组织组件的逻辑。 下面，我们通过Composition API来演示上面的案例 1234567891011121314151617181920212223242526import &#123;reactive, onMounted,onUnmounted&#125; from &#x27;vue&#x27;function useMousePosition()&#123; const position=reactive(&#123; x:0, y:0 &#125;) const upate=(e)=&gt;&#123; position.x=e.pageX position.y=e.pageY &#125; onMounted(()=&gt;&#123; window.addEventListener(&#x27;mousemove&#x27;,update) &#125;) onUnmounted(()=&gt;&#123; window.removeEventListener(&#x27;mousemove&#x27;,update) &#125;) return position&#125;export default &#123; setup()&#123; const position=useMousePosition() return &#123; position &#125; &#125;&#125; 在上面的代码中，我们可以看到关于获取鼠标位置的核心逻辑代码封装到一个函数中了，这样其它组件也可以使用，只需要封装到一个公共模块中，进行导出，其它组件进行导入即可。通过这一点，我们也能够看出，Composition API 提供了很好的代码的封装与复用性。 如果，现在我们需要添加一个新的功能，例如搜索的功能，我们只需要添加一个函数就可以了。 这样，我们以后在查看代码的时候，只需要查看某个具体实现业务的函数就可以了。因为核心的业务我们到封装到了一个函数中，不像Options API一样，把核心的业务都分散到了不同的位置，查看代码的时候，需要不断的拖动滚动条。 当然，在Vue3.js中可以使用Composition API也可以使用Options API,这里可以根据个人喜好来进行选择。如果开发的组件中需要提取可复用的逻辑，这时可以使用Compositon API,这样更加的方便。 最后，我们来做一个总结: Composition API提供了一组基于函数的API,让我们能够更加灵活的组织组件的逻辑，也能够更加灵活的组织组件内的代码结构，还能够把一些逻辑功能从组件中提取出来，方便其它的组件重用。 4、性能提升这一小节，我们来看一下关于Vue3中的性能的提升。 关于Vue3中的性能提升，主要体现在如下几点 第一: 响应式系统升级，在Vue3中使用Pxory重写了响应式系统 第二：编译优化，重写了虚拟DMO,提升了渲染的性能。 第三：源码体积的优化，减少了打包的体积 下面，我们先来看一下“响应式系统的升级” 在Vue2.x中响应式系统的核心是defineProperty,在初始化的时候，会遍历data中的所有成员，将其转换为getter/setter,如果data中的属性又是对象，需要通过递归处理每一个子对象中的属性，注意：这些都是在初始化的时候进行的。也就是，你没有使用这个属性，也进行了响应式的处理。 而在Vue3中使用的是Proxy对象来重写了响应式系统，并且Proxy的性能要高于defineProperty,并且proxy可以拦截属性的访问，删除，赋值等操作，不需要在初始化的时候遍历所有的属性，另外有多层属性的嵌套的时候，只有访问某个属性的时候，才会递归访问下一级的属性。使用proxy默认就可以监听到动态新增的属性，而Vue2中想动态新增一个属性，需要通过Vue.set()来进行处理。而且Vue2中无法监听到属性的删除，对数组的索引与length属性的修改也监听不到，而在Vue3中使用proxy可以监听动态的新增的属性，可以监听删除的属性，同时也可以监听数组的索引和length属性的修改操作。 所以Vue3中使用proxy以后，提升了响应式的性能和功能。 除了响应式系统的升级以外，Vue3中通过优化编译的过程，和重写虚拟DOM, 让首次渲染与更新的性能有了很大的提升。 下面，我们通过一个组件，来回顾一下Vue2中的编译过程 1234567891011121314&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; static root &lt;div&gt;static node&lt;/div&gt; &lt;/div&gt; &lt;div&gt;static node&lt;/div&gt; &lt;div&gt;static node&lt;/div&gt; &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;handler&quot;&gt; button &lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 我们知道在Vue2中，模板首先会被编译成render函数，这个过程是在构建的过程中完成的，在编译的时候会编译静态的根节点和静态节点，静态根节点要求节点中必须有一个静态的子节点. 当组件的状态发生变化后，会通知watcher,会触发watcher的update,最终去执行虚拟DOM的patch方法，遍历所有的虚拟节点，找到差异，然后更新到真实的DOM中，diff的过程中，会比较整个的虚拟DOM,先对比新旧的节点以及属性，然后在对比子节点。Vue2中渲染的最小的单位是组件， 在vue2中diff的过程会跳过，静态的根节点，因为静态根节点的内容不会发生变化，也就是说在Vue2中通过标记静态根节点，优化了diff的过程。但是在vue2中静态节点还需要进行diff,这个过程没有被优化。 在Vue3中标记和提升了所有的静态节点，diff的时候只需要对比动态节点内容。另外在Vue3中新引入了Fragments,这样在模板中不需要在创建一个唯一根节点的特性。模板中可以直接放文本内容，或者很多的同级的标签，当然这需要你在vscode中升级vetur插件，否则如果模板中没有唯一的根节点，vscode会提示错误。 下面，我们再来看一下：优化打包体积 在Vue3中移除了一些不常用的API,例如：inline-template,filter等。 同时Vue3对Tree-shaking的支持更好，通过编译阶段的静态分析，将没有引入的模块在打包的时候直接过滤掉。让打包后的体积更小。 5、ViteVite是针对Vue3的一个构建工具，Vite翻译成中文就是“快”的意思，也就是比基于webpack的vue-cli更快。 在讲解Vite之前，我们先来回顾一下在浏览中使用ES Module的方式。 现代浏览器都支持ES Module(IE不支持) 通过下面的方式加载模块 1&lt;script type=&#x27;module&#x27; src=&#x27;..&#x27;&gt;&lt;/script&gt; 支持模块的script默认具有延迟加载的特性，类似于script标签设置了defer.也就是说type=&#39;module&#39;的script的标签相当于省略了defer, 它是在文档解析完后也就是DOM树生成之后，并且是在触发DOMContentLoaded事件前执行。 Vite的快就是体现在，使用了浏览器支持的ES Module的方式，避免了在开发环境下的打包，从而提升了开发的速度。 下面我们看一下Vite与Vue-cli的区别 它们两者之间最主要的区别就是：Vite在开发模式下不需要打包就可以直接运行。因为，在开发模式下，vite是使用了浏览器支持的es module加载模块，也就是通过import导入模块，浏览器通过&lt;script type=&#39;module&#39;&gt;的形式加载模块代码，因为vite不需要打包项目，所以vite在开发模式下，打开页面是秒开的。 Vue-cli:在开发模式下必须对项目打包才可以运行，而且项目如果比较大，速度会很慢。 Vite特点 第一：因为不需要打包，可以快速冷启动。 第二：代码是按需编译的，只有代码在当前需要加载的时候才会编译。不需要在开启开发服务器的时候，等待整个项目被打包。 第三：Vite支持模块的热更新。 Vite在生产环境下使用Rollup打包，Rollup基于浏览器原生的ES Module的方式来打包，从而不需要使用babel将import转换成require以及一些辅助函数，所以打包的体积比webpack更小。 下面，我们看一下Vite创建项目 1234npm init vite-app 项目名称cd 项目名称npm installnpm run dev 注意：npm install安装相应的依赖，这一步不能省略。 创建好项目以后，查看index.html文件，可以看到如下代码 1&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt; 以上就是加载了src下的main.js模块，在main.js模块中加载了App.vue这个模块，App.vue这个模块是单文件组件，浏览器不支持，但是页面可以正常的展示。那么它是如何处理的呢？ vite开启的服务会监听.vue后缀的请求，会将.vue文件解析成js文件。vite使用了浏览器支持的es module来加载模块，在开发环境下不会打包项目，所有模块的请求都会交给服务器来处理，服务器会处理浏览器不能识别的模块，如果是单文件组件，会调用compiler-sfc来编译单文件组件，并将编译的结果返回给浏览器。 二、Composition API1、Composition API基本使用下面，我们来学习一下Composition API的应用，这里为了简单方便，我们先不使用Vite来创建项目。而使用浏览器原生的es module的形式，来加载Vue的模块。 创建好项目文件夹composition-api-demo后,执行如下命令安装最新的Vue版本 1npm install vue@next 在项目目录下面创建index.html,代码如下： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; x:&#123;&#123;position.x&#125;&#125;&lt;br/&gt; y:&#123;&#123;position.y&#125;&#125; &lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import &#123;createApp&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; const app=createApp(&#123; data()&#123; return &#123; position:&#123; x:0, y:0 &#125; &#125; &#125; &#125;) app.mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上面的代码中，导入了createApp方法，该方法创建一个Vue的实例，同时将其绑定到了id=app的这个div上。在createApp这个方法中创建对应的选项内容。 注意：这里的data只能是函数的形式，不能是对象的形式。（注意：在vscode中安装了Live Server 插件，所以右击index.html，在弹出的对话框中选择’open with Live Server ‘,这时会启动一个服务打开该页面，避免出现跨域的问题） 下面，我们开始使用Compositon API,使用该API，需要用到一个新的选项setup,setup是composition api的入口函数。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; x:&#123;&#123;position.x&#125;&#125;&lt;br/&gt; y:&#123;&#123;position.y&#125;&#125; &lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import &#123;createApp&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; const app=createApp(&#123; setup() &#123; //setup可以有两个参数 //第一个参数是`props`,props的作用是用来接收外部传入的参数，并且props是一个响应式的对象，并且不能被解构。 //第二个参数是：context,context是一个对象，该对象有三个成员，分别是attrs,emit,slots,这个案例暂时没有用到。 //setup的执行时机：是在props解析完毕，但是是在组件实例被创建之前执行的，所以在setup内部无法通过this获取组件的实例，因为组件的实例还没有被创建，所以在setup中无法访问到组件中的data,methods等。setup内的this指向的是undefined //下面创建positon对象，该对象目前是普通对象，并不是响应式的。 const position=&#123; x:0, y:0 &#125; //将positon对象返回，这样可以在模板，以及生命周期的钩子函数中使用该对象 return &#123; position &#125; &#125;, //下面我们在mounted的钩子函数中，修改一下positon中的x的值，来验证是否为响应式的。 mounted()&#123; this.position.x=100 &#125; &#125;) console.log(app) app.mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在setup方法中创建了一个positon对象，该对象并不是响应式的，下面看一下怎样将其修改成响应式的。 以前我们是在data这个选项中设置响应式的对象，当然这里还可以定义到data中，但是为了能够将某一个逻辑的所有代码封装到一个函数中，vue3中提供了一个新的api来创建响应式的对象。这个api就是reactive 首先导入该函数 1import &#123;createApp,reactive&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; 使用reactive函数将positon对象包裹起来。 1234const position=reactive(&#123; x:0, y:0&#125;) 现在position对象就是响应式的对象了，刷新浏览器，可以看到positon中的x属性的值发生了更改。 2、生命周期钩子函数这一小节，看一下怎样在setup中使用生命周期的钩子函数。 在setup中可以使用生命周期的钩子函数，但是需要在钩子函数名称前面加上on,然后首字母大写。例如:mounted setup是在组件初始化之前执行的，是在beforeCreate与created之间执行的，所以beforeCreate与created的代码都可以放到setup函数中。 所以，在上图中，我们可以看到beforeCreate与created在setup中没有对应的实现。 其它的都是在钩子函数名称前面添加上on,并且首字母大写。 注意:onUnmounted类似于之前的destoryed，调用组件的onUnmounted方法会触发unmounted钩子函数 renderTracked与renderTriggered这两个钩子函数都是在render函数被重新调用的时候触发的。 不同是的是，在首次调用render的时候renderTracked也会被触发，renderTriggered在render首次调用的时候不会被触发。 了解了在setup中使用钩子函数的方式后，下面继续完善获取鼠标坐标位置的案例 在定义鼠标移动事件的时候，可以在原有代码的mounted钩子函数中定义，但是为了能够将获取鼠标位置的相关的逻辑代码封装到一个函数中，让任何一个组件都可以重用，这时使用mounted选项就不合适了。这样我们最好是在setup中使用生命周期的钩子函数， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; x:&#123;&#123;position.x&#125;&#125;&lt;br/&gt; y:&#123;&#123;position.y&#125;&#125; &lt;/div&gt; &lt;script type=&quot;module&quot;&gt; //导入onMounted,onUnmounted函数 import &#123;createApp,reactive,onMounted,onUnmounted&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; const app=createApp(&#123; setup() &#123; const position=reactive(&#123; x:0, y:0 &#125;) //获取鼠标的位置坐标 const update=e=&gt;&#123; position.x=e.pageX position.y=e.pageY &#125; onMounted(()=&gt;&#123; window.addEventListener(&#x27;mousemove&#x27;, update) &#125;) //onUnmounted类似于之前的destoryed onUnmounted(()=&gt;&#123; window.removeEventListener(&#x27;mousemove&#x27;, update) &#125;) return &#123; position &#125; &#125;, mounted()&#123; this.position.x=100 &#125; &#125;) console.log(app) app.mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上面的代码中，首先导入了onMounted,onUnmounted 1import &#123;createApp,reactive,onMounted,onUnmounted&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; 定义获取鼠标位置的update函数 12345//获取鼠标的位置坐标 const update=e=&gt;&#123; position.x=e.pageX position.y=e.pageY &#125; 在onMounted钩子函数中注册mousemove事件 123onMounted(()=&gt;&#123; window.addEventListener(&#x27;mousemove&#x27;, update) &#125;) 在onUnmounted钩子函数中移除mousemove事件 1234onUnmounted(()=&gt;&#123; window.removeEventListener(&#x27;mousemove&#x27;, update) &#125;) 现在，功能已经实现了，下面我们在将代码进行重构。 将获取鼠标位置的功能封装到一个函数中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; x:&#123;&#123;position.x&#125;&#125;&lt;br/&gt; y:&#123;&#123;position.y&#125;&#125; &lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import &#123;createApp,reactive,onMounted,onUnmounted&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; //将获取鼠标位置坐标的代码封装到了useMousePosition函数中 function useMousePosition()&#123; const position=reactive(&#123; x:0, y:0 &#125;) const update=e=&gt;&#123; position.x=e.pageX position.y=e.pageY &#125; onMounted(()=&gt;&#123; window.addEventListener(&#x27;mousemove&#x27;, update) &#125;) onUnmounted(()=&gt;&#123; window.removeEventListener(&#x27;mousemove&#x27;, update) &#125;) //将positon对象返回 return position &#125; const app=createApp(&#123; setup() &#123; //调用useMousePosition函数，接收返回的postion const position=useMousePosition() return &#123; position &#125; &#125;, //下面我们在mounted的钩子函数中，修改一下positon中的x的值，来验证是否为响应式的。 mounted()&#123; this.position.x=100 &#125; &#125;) console.log(app) app.mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上面的代码中定义了，useMousePosition函数，在该函数中封装了获取鼠标位置的业务代码，最终返回。 在setup函数中调用useMousePositon函数，接收返回的positon,然后返回，这样在模板中可以展示鼠标的位置。 通过这个案例，我们可以体会出Composition API与options API的区别。 如果现在使用options api来实现这个案例，我们需要在data中定义x,y,在methods中定义update,这样把同一个逻辑的代码分散到了不同的位置，这样查找起来也非常的麻烦，而现在根这个逻辑函数相关的代码都封装到了一个函数中，这样方便了以后的维护也就是如果出错了，直接查找这个函数就可以了。并且这个函数也可以单独的放到一个模块中，这样在任何一个组件中都可以使用。 3、reactive/toRefs/ref这一小节，我们来介绍Compositiont API中的三个函数reactive/toRefs/ref 这三个函数都是创建响应式数据的。 我们首先看一下reactive,该函数，我们在前面的案例中已经使用过，该函数的作用就是将一个对象设置为响应式的。现在，我们对前面写的程序进行一个简单的优化。 在模板中，我们是通过以下的方式来获取x与y的值。 1234&lt;div id=&quot;app&quot;&gt; x:&#123;&#123;position.x&#125;&#125;&lt;br/&gt; y:&#123;&#123;position.y&#125;&#125; &lt;/div&gt; 这样写笔记麻烦，可以简化成如下的形式 1234&lt;div id=&quot;app&quot;&gt; x:&#123;&#123;x&#125;&#125;&lt;br/&gt; y:&#123;&#123;y&#125;&#125; &lt;/div&gt; 同时，在setup函数中，进行如下的修改： 1234567// const position=useMousePosition() const &#123;x,y&#125;=useMousePosition() return &#123; x, y &#125; &#125;, 我们知道，当我们调用useMousePosition方法的时候，返回的是一个position对象，该对象中包含了x与y两个属性，那么这里我们可以进行解构处理。 最后将解构出来的x,y返回，这样在模板中就可以直接使用x,y. 但是，当我们的鼠标在浏览器中移动的时候，x,y的值没有发生变化，说明它们不是响应式的了。 原因是什么呢？ 原因是，当对position对象进行解构的时候，就是定义了两个变量x,y来接收解构出来的值。所以这里的x,y就是两个变量，与原有的对象没有任何关系。 但是，这里我们还是希望对模板进行修改呢？ 可以使用toRefs 首先导入toRefs 1import &#123;createApp,reactive,onMounted,onUnmounted,toRefs&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; 然后在useMousePosition方法中，将返回的position对象,通过toRefs函数包括起来。 1return toRefs(position) toRefs函数，可以将一个响应式对象中的所有属性转换成响应式的。 现在，通过浏览器进行测试，发现没有任何的问题了。 下面我们来解释一下toRefs的工作原理，首先传递给toRefs函数的参数，必须是一个响应式的对象(代理的对象)，而position就是一个通过reactive函数处理后的一个响应式对象。在toRefs方法内部首先会创建一个新的对象，然后会遍历传递过来的响应式对象内的所有属性，把属性的值都转换成响应式对象，然后再挂载到toRefs函数内部所创建的这个新的对象上，最后返回。 toRefs函数是把reactive返回的对象中的所有属性，都转换成了一个对象，所以对响应式对象进行解构的时候，解构出的每一个属性都是对象，对象是引用 传递的，所以解构出的数据依然是响应式的。 那么，我们解构toRefs返回的对象，解构出来的每个属性都是响应式的。 现在，我们先知道toRefs函数的作用就是：可以将一个响应式对象中的所有属性转换成响应式的。 后面还会继续探讨它的应用。 下面，我们再来看一下ref函数的应用 ref函数的作用就是把普通数据转换成响应式数据。与reactive不同的是，reactive是把一个对象转换成响应式数据。 ref可以把一个基本类型的数据包装成响应式对象。 下面，我们使用ref函数实现一个自增的案例。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;add&quot;&gt;增加&lt;/button&gt; &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import&#123;createApp,ref&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; function useCount()&#123; const count=ref(0) return &#123; count, add:()=&gt;&#123; count.value++ &#125; &#125; &#125; createApp(&#123; setup()&#123; return &#123; ...useCount() &#125; &#125; &#125;).mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面，我们把上面的代码做一个解析： 首先在模板中有一个按钮，与展示数字的插值表达式。 下面导入createApp与ref函数。 虽然这个案例中的业务非常的简单，但是这里，我们还是单独的将其封装到一个函数中useCount中。 如果，我们写的是如下代码： 1const count=0 那么，count就是一个基本的数据类型的变量。 但是，如果写成如下的形式： 1const count=ref(0) count就是一个响应式对象，该对象中会有一个value属性，该属性存储的就是具体的值。该属性中包含了getter/setter. useCount方法将count与add方法返回。 在setup方法中调用useCount方法，并且将该方法返回的内容进行解构，注意：这里解构出来的count就是一个响应式的对象。 而在模板中使用count响应式对象的时候，不需要添加value属性。当我们单击“增加”按钮的时候，会执行add方法，该方法中让count中的value属性值加1,由于count是一个响应式对象，它内部的值发生了变化后，视图就会重新渲染，展示新的数据。 下面，我们来介绍一下ref函数的工作原理。 我们知道，基本数据类型，存储的是值。所以它不可能是响应式数据，我们知道响应式数据需要通过getter收集依赖(watcher对象)，通过setter触发更新， 如果ref的参数是一个对象，内部会调用reactive返回一个代理对象，也就是说，如果我们给ref传递的是一个对象，那么内部调用的就是reactive 如果ref的参数是一个基本类型的值，例如我们案例中传递的0，那么在ref内部会创建一个新的对象，这个对象中只有一个value属性，该value属性具有getter/setter.通过getter收集依赖(watcher对象)，通过setter触发更新. 以上就是我们常用的响应式函数。 reactive：把一个对象转换成响应式对象 ref:把基本类型数据转换成响应式对象 toRefs：把一个响应式对象中的所有属性都转换成响应式对象，该函数处理reactive返回的对象的时候，可以进行解构的操作。 4、ComputedComputed是计算属性，计算属性的作用就是简化模板中的代码，可以缓存计算的结果，当数据变化后才会重新进行计算。 下面，我们来看一下Computed的使用。 Computed有两种用法 第一种用法： 给computed传入获取值的函数，函数内部依赖响应式的数据，当依赖的数据发生变化后，会重新执行该函数来获取数据。 computed返回的是一个不可变的响应式对象，类似于使用ref创建的对象，只有一个value属性，获取计算属性的值，需要通过value属性来获取。如果模板中使用可以省略value. 1computed(()=&gt;count.value+1) 第二种用法： computed的第二种用法是传入一个对象，这个对象具有getter/setter,computed方法返回一个不可变的响应式对象，当获取值的时候，会执行getter,当设置值的时候，会执行该对象中的setter,后面我们会演示这种用法 1234567const count=ref(1)const plusOne=computed(&#123; get:()=&gt;count.value+1 set:val=&gt;&#123; count.value=val-1&#125;&#125;) 下面我们先来使用第一种用法 下面这个案例，会使用computed来计算出未处理的任务的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;push&quot;&gt;按钮&lt;/button&gt; 未完成&#123;&#123;activeCount&#125;&#125; &lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import &#123;createApp,reactive,computed&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; const data=[ &#123;text:&#x27;看书&#x27;,completed:false&#125;, &#123;text:&#x27;睡觉&#x27;,completed:false&#125;, &#123;text:&#x27;玩游戏&#x27;,completed:true&#125;, ] createApp(&#123; setup()&#123; //在computed内部依赖的对象必须是一个响应式对象 const todos=reactive(data) //computed返回的也是一个响应式对象，该对象中只有一个value属性 const activeCount=computed(()=&gt;&#123; return todos.filter(item=&gt;!item.completed).length &#125;) //computed返回的是一个不可变的响应式对象，类似于使用ref创建的对象，只有一个value属性，获取计算属性的值，需要通过value属性来获取。如果模板中使用可以省略value. // console.log(&#x27;activeCount===&#x27;,activeCount.value) return &#123; activeCount, push:()=&gt;&#123; todos.push(&#123; text:&#x27;打球&#x27;,completed:false &#125;) &#125; &#125; &#125; &#125;).mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在setup函数的内部，我们通过reactive函数将data对象转换成了响应式的对象，todos就是一个响应式对象。下面通过计算属性对响应式对象todos中的内容进行计算，计算出未完成的任务的个数，并且返回。将返回的数量保存到了activeCount中，然后将activeCount返回,这样在模板中就可以通过差值表达式来使用activeCount.同时，当单击了按钮以后，会向todos响应式对象中添加数据，这时会重新执行计算属性，计算没有完成的任务数量。 5、Watch我们可以在setup函数中使用watch函数创建一个侦听器。监听响应式数据的变化，然后执行一个回调函数，可以获取到监听的数据的新值与旧值。 watch的三个参数 第一个参数：要监听的数据 第二个参数：监听到的数据变化后执行的函数，这个函数有两个参数，分别是新值和旧值。 第三个参数：选项对象，deep(深度监听)和immediate（立即执行） Watch函数的返回值是一个函数，作用是用来取消监听。 watch与以前的this.$watch的使用方式是一样的，不一样的是watch第一个参数不是字符串(this.$watch第一个参数是字符串)，而是ref和reactive返回的对象。 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&#x27;app&#x27;&gt; &lt;p&gt; &lt;input v-model=&quot;question&quot;&gt; &lt;/p&gt; &lt;p&gt; &#123;&#123;answer&#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import&#123;createApp,ref,watch&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; createApp(&#123; setup()&#123; const question=ref(&#x27;&#x27;) const answer=ref(&#x27;&#x27;) watch(question,async(newValue,oldValue)=&gt;&#123; const response=await fetch(&#x27;https://www.yesno.wtf/api&#x27;) const data=await response.json() answer.value=data.answer &#125;) return &#123; question, answer &#125; &#125; &#125;).mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上面的代码中，setup函数内，定义两个响应式对象分别是question与answer,这两项的内容都是字符串，所以通过ref来创建。使用watch来监听quest的变化，由于question与文本框进行了双向绑定，当在文本框中输入内容后，question的值会发生变化，发生变化后，就会执行watch的第二个参数，也就是回调函数。该回调函数内，发送一个异步请求，注意这里使用了fetch方法，发送请求，该方法返回的是一个promise对象，所以这里使用了await,下面调用json方法获取json对象，注意该方法返回的也是promise,所以这里也使用了await,最后把获取到的数据给了answer中的value属性。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt; &lt;input v-model=&quot;question&quot;&gt; &lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import &#123;createApp,ref,watch&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; createApp(&#123; setup()&#123; const question =ref(&#x27;&#x27;) watch(question,(newValue,oldValue)=&gt;&#123; console.log(&#x27;newValue==&#x27;,newValue) console.log(&#x27;oldValue==&#x27;,oldValue) &#125;) return&#123; question &#125; &#125; &#125;).mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6、WatchEffect在Vue3中还提供了一个新的函数WatchEffect. WatchEffect是Watch函数的简化版本，也用来监视数据的变化，WatchEffect接收一个函数作为参数，监听函数内响应式数据的变化，会立即执行一次该函数，当数据发生了变化后，会重新运行该函数。返回的也是一个取消监听的函数。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;add&quot;&gt;add&lt;/button&gt; &lt;button @click=&quot;stop&quot;&gt;stop&lt;/button&gt; &lt;br/&gt; &#123;&#123;count&#125;&#125; &lt;/div&gt; &lt;script type=&#x27;module&#x27;&gt; import &#123;createApp,ref,watchEffect&#125; from &#x27;./node_modules/vue/dist/vue.esm-browser.js&#x27; createApp(&#123; setup()&#123; const count=ref(0) const stop=watchEffect(()=&gt;&#123; console.log(count.value) &#125;) return &#123; count, stop, add:()=&gt;&#123; count.value++ &#125; &#125; &#125; &#125;).mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在setup函数中，定义响应式对象count,同时使用watchEffect函数监听count的变化，当我们第一次打开页面的时候，watchEffect会执行一次，所以在控制台中输出的值为0,watchEffect返回的是一个取消监听的函数，这里定义stop来接收。 下面将count,stop,add函数返回，这样在模板中就可以使用了。当用户单击add按钮的时候，count的值累加(注意修改的是count中的value属性的值)，这时watchEffect函数执行，在浏览器控制台中打印count的值。如果，单击了stop按钮，再次单击add的按钮，count的值还会进行累加，但是watchEffect函数不执行，那么控制台中不会打印count的值，但是页面中count的值不断的变化。 三、ToDoList案例整个案例实现的功能如下： 添加任务 删除任务 编辑任务 切换任务 存储任务，实现持久化 1、项目结构从这个案例开始，我们使用Vue的脚手架来创建项目，首先需要升级Vue-cli,升级到4.5以上的版本，这样我们在创建项目的时候，可以使用vue3.0 升级vue-cli 1npm install -g @vue/cli 查看版本： 1vue -V 项目创建 1vue create todolist 在创建的时候选择Vue3.0 在App.vue文件中，构建出基本的结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;section id=&quot;app&quot; class=&quot;todoapp&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;input class=&quot;new-todo&quot; placeholder=&quot;What needs to be done?&quot; autocomplete=&quot;off&quot; autofocus /&gt; &lt;/header&gt; &lt;section class=&quot;main&quot;&gt; &lt;input id=&quot;toggle-all&quot; class=&quot;toggle-all&quot; type=&quot;checkbox&quot; /&gt; &lt;label for=&quot;toggle-all&quot;&gt;Mark all as complete&lt;/label&gt; &lt;ul class=&quot;todo-list&quot;&gt; &lt;li&gt; &lt;div class=&quot;view&quot;&gt; &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; /&gt; &lt;label&gt;测试数据&lt;/label&gt; &lt;button class=&quot;destroy&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class=&quot;edit&quot; type=&quot;text&quot; /&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;view&quot;&gt; &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; /&gt; &lt;label&gt;测试数据&lt;/label&gt; &lt;button class=&quot;destroy&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class=&quot;edit&quot; type=&quot;text&quot; /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;footer class=&quot;footer&quot;&gt; &lt;span class=&quot;todo-count&quot;&gt; &lt;strong&gt;1&lt;/strong&gt; item left &lt;/span&gt; &lt;ul class=&quot;filters&quot;&gt; &lt;li&gt;&lt;a href=&quot;#/all&quot;&gt;All&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/active&quot;&gt;Active&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/completed&quot;&gt;Completed&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;button class=&quot;clear-completed&quot;&gt; Clear completed &lt;/button&gt; &lt;/footer&gt; &lt;/section&gt; &lt;footer class=&quot;info&quot;&gt; &lt;p&gt;Double-click to edit a todo&lt;/p&gt; &lt;/footer&gt;&lt;/template&gt;&lt;script&gt;import &quot;./assets/index.css&quot;;export default &#123; name: &quot;App&quot;, components: &#123;&#125;,&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在上面的代码中，导入了样式。 2、添加任务在模板的header的内，给文本框添加v-model实现双向绑定，同时为其添加一个enter事件，该事件触发，表明用户按下了键盘上的回车键，那么这里就需要将用户在文本框中输入的内容保存到一个数组中。 1234567891011&lt;header class=&quot;header&quot;&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;input class=&quot;new-todo&quot; placeholder=&quot;What needs to be done?&quot; autocomplete=&quot;off&quot; autofocus v-model=&quot;input&quot; @keyup.enter=&quot;addTodo&quot; /&gt; &lt;/header&gt; 下面，将添加任务的业务单独的封装到一函数中处理。 12345678910111213141516171819202122232425262728293031&lt;script&gt;import &#123; ref &#125; from &quot;vue&quot;;import &quot;./assets/index.css&quot;;//1、添加任务const useAdd = (todos) =&gt; &#123; const input = ref(&quot;&quot;); const addTodo = () =&gt; &#123; const text = input.value &amp;&amp; input.value.trim(); if (text.length === 0) return; todos.value.unshift(&#123; text, completed: false, &#125;); input.value=&quot;&quot; &#125;; return &#123; input, addTodo, &#125;;&#125;;export default &#123; name: &quot;App&quot;, setup() &#123; const todos = ref([]); return &#123; ...useAdd(todos), &#125;; &#125;,&#125;;&lt;/script&gt; 在上面的代码中，创建了useAdd这个函数，该函数完成保存任务数据，所以调用该函数的时候，需要传递一个数组。 在该函数内，创建input这个响应式对象（这里input的值为字符串，所以使用ref函数创建响应式对象，在这里输入ref，然后按下tab键，会自动导入ref函数），最后返回，然后在setup 函数中会将其解构出来，这样模板中就可以使用input这个响应式对象，该响应式对象中存储了用户在文本框中输入的值。 在userAdd方法内，创建addTodo方法，该方法获取文本框中输入的值，并且构建出一个对象，插入到todos这个数组中，这里要求新输入的数据在最开始进行展示，所以这里使用了unshif函数来插入对象。最后返回。 在setup函数中，对useAdd函数返回的结果进行解构，然后返回，这样在模板中就可以使用input 和addTodo方法。当然这里调用useAdd方法的时候，需要传递一个数组，注意这个数组也是响应式，因为我们把数据添加到该数组以后，列表要重新渲染展示最新的数据，在最开始创建数组的时候，默认就是一个空数组。 同时，还需要注意在addTodo方法中，使用的todos是一个响应式的对象(这里是通过ref([])创建出来，然后传递到了addTodo方法中)，想使用它里面的值，需要通过value属性才能获取到，这时获取到的才是真正的数组。 1234todos.value.unshift(&#123; text, completed: false, &#125;); 下面，把todos中的数据展示出来。也就是在模板中遍历todos这个数组。 所以这里需要将todos这个数组，在setup函数中返回。 1234567setup() &#123; const todos = ref([]); return &#123; ...useAdd(todos), todos, &#125;; &#125;, 下面对列表进行循环遍历 12345678910&lt;ul class=&quot;todo-list&quot;&gt; &lt;li v-for=&quot;item in todos&quot; :key=&quot;item.text&quot;&gt;//这里可以写成item &lt;div class=&quot;view&quot;&gt; &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; /&gt; &lt;label&gt;&#123;&#123; item.text &#125;&#125;&lt;/label&gt; &lt;button class=&quot;destroy&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class=&quot;edit&quot; type=&quot;text&quot; /&gt; &lt;/li&gt; &lt;/ul&gt; 3、删除任务在列表中找到删除按钮，并且为其添加单击事件，事件触发后调用remove方法，给该方法传递传递的是要删除的任务。 12345678910&lt;ul class=&quot;todo-list&quot;&gt; &lt;li v-for=&quot;item in todos&quot; :key=&quot;item.text&quot;&gt; &lt;div class=&quot;view&quot;&gt; &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; /&gt; &lt;label&gt;&#123;&#123; item.text &#125;&#125;&lt;/label&gt; &lt;button class=&quot;destroy&quot; @click=&quot;remove(todo)&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class=&quot;edit&quot; type=&quot;text&quot; /&gt; &lt;/li&gt; &lt;/ul&gt; 定义useRemove方法，当调用该方法的时候，传递todos数组，然后在该方法中实现remove方法，该方法就是根据传递过来的要删除的todo，从数组todos中， 找到对应的索引值（注意todos是一个响应式对象，todos.value才是真正的数组），然后调用splice方法将其从todos中删除。 最后返回remove这个方法。 12345678910// 2. 删除任务const useRemove = (todos) =&gt; &#123; const remove = (todo) =&gt; &#123; const index = todos.value.indexOf(todo); todos.value.splice(index, 1); &#125;; return &#123; remove, &#125;;&#125;; 下面回到setup这个函数中，调用useRemove函数，传递todos这个响应式对象，然后将useRomove函数的返回值解构，解构出来的就是remove函数，这样在模板中就可以使用了。 12345678setup() &#123; const todos = ref([]); return &#123; ...useAdd(todos), ...useRemove(todos), todos, &#125;;&#125;, 4、编辑任务整个编辑操作，要完成的功能如下： 双击任务项，展示编辑文本框 按回车键或者编辑文本框失去焦点，修改数据 按下esc键取消编辑操作 把编辑文本框内容清空，然后按下回车键，删除这一项 显示编辑文本框的时候获取焦点 下面创建编辑函数： 1234567891011121314151617181920212223242526272829303132333435363738394041// 3、编辑任务const useEdit = (remove) =&gt; &#123; //定义一个变量，存储要编辑的任务项，当取消编辑的时候，可以进行还原。不需要是响应式对象 let beforeEditingText = &quot;&quot;; //定义一个常量，记录当前是否为编辑状态，它是响应式的，它的值的改变要控制页面中文本框的显示与隐藏 const editingTodo = ref(null); //默认情况下没有要编辑的数据 //editTodo方法记录要编辑的任务的文体，以及要编辑的状态 //参数todo就是当前要编辑的任务对象 const editTodo = (todo) =&gt; &#123; beforeEditingText = todo.text; //editingTodo是一个响应式对象，这里需要调用value属性 editingTodo.value = todo; &#125;; //实现按下回车或者失去焦点后，修改数据的函数，参数为要编辑的任务对象 const doneEdit = (todo) =&gt; &#123; //判断是否为编辑的状态，如果editingTodo中没有值，表示没有处于编辑状态，直接返回 if (!editingTodo.value) return; //获取到要编辑的任务的文本数据，去掉要编辑的文本的前后空格 todo.text = todo.text.trim(); //如果按下回车键后，发现要编辑的任务对象中没有数据，表明是把当前要编辑的任务对象删除。 if (!todo.text) &#123; remove(todo); //在调用useEdit函数的时候将remove传递过来。 &#125; //修改当前的状态，编辑完成后，状态变为非编辑状态。 editingTodo.value = null; &#125;; //定义取消编辑的函数 const cancelEdit = (todo) =&gt; &#123; //将editingTodo的值设置为null, editingTodo.value = null; //让todo中的text的值还原为原有的值。 todo.text = beforeEditingText; &#125;; return &#123; editingTodo, editTodo, doneEdit, cancelEdit, &#125;;&#125;; 下面，在setup函数中将useEdit方法的返回内容解构出来，这样在模板中就可以使用了。当然在调用useEdit方法的时候，需要传递一个remvoe函数，而该函数是useRemove方法解构出来的，所以这里需要在return返回之前，先把useRemove返回的remove解构出来，然后传递给useEdit方法，同时remove方法也要返回，因为在模板中使用到了该方法。 12345678910111213export default &#123; name: &quot;App&quot;, setup() &#123; const todos = ref([]); const &#123; remove &#125; = useRemove(todos); return &#123; ...useAdd(todos), ...useEdit(remove), remove, todos, &#125;; &#125;,&#125;; 下面要处理的就是模板的内容了。 123456789101112131415161718192021&lt;ul class=&quot;todo-list&quot;&gt; &lt;li v-for=&quot;item in todos&quot; :key=&quot;item.text&quot; :class=&quot;&#123; editing: item === editingTodo &#125;&quot; &gt; &lt;div class=&quot;view&quot;&gt; &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; /&gt; &lt;label @dblclick=&quot;editTodo(item)&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;/label&gt; &lt;button class=&quot;destroy&quot; @click=&quot;remove(item)&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class=&quot;edit&quot; type=&quot;text&quot; v-model=&quot;item.text&quot; @keyup.enter=&quot;doneEdit(item)&quot; @blur=&quot;doneEdit(item)&quot; @keyup.esc=&quot;cancelEdit(item)&quot; /&gt; &lt;/li&gt; &lt;/ul&gt; 在上面的代码中，我们给li添加了一个类样式，editing,如果当前的item与editingTodo相等，表明是当前的这个任务处于编辑状态，所以要显示文本框。 这里我们给input文本框添加了v-model,这样文本框中会展示要编辑的数据，如果在文本框中输入了新数据item.text中的值为新数据，，添加了@key.enter事件，按下回车键该事件触发调用doneEdit方法完成更新，这时把当前的数据项传递到了doneEdit方法中，该方法中，会执行如下语句 1todo.text = todo.text.trim(); 把数据中的空格去掉后有赋值给了自己,也就是todo.text,然后，执行 1editingTodo.value = null; 这时候，为非编辑状态，不在显示文本框，而显示div,而div中的label中展示的数据为修改后的数据。 1@blur=&quot;doneEdit(item)&quot; 失去焦点的时候，也是调用doneEdit方法。 按下esc键的时候，执行cancelEdit方法，显示div中的内容不，不在展示文本框，同时内容还是原来的内容数据。 给div中的label添加双击事件。 1&lt;label @dblclick=&quot;editTodo(item)&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;/label&gt; 现在，在测试的时候出现了一个问题就是，当我们双击数据项的时候，也就是label标签的时候，文本框可以展示出来，但是没有焦点，这一点我们后面解决。 那么，我们先来看另完一个问题，就是双击以后，出现文本框，然后单击一下有焦点了，然后输入内容，发现焦点又没有了。 这时什么原因呢？ 原因是li的key的问题 12345&lt;li v-for=&quot;item in todos&quot; :key=&quot;item.text&quot; :class=&quot;&#123; editing: item === editingTodo &#125;&quot; &gt; 上面的代码中key绑定了item.text 然后文本框也绑定了item.text(v-model绑定了item.text) 12345678&lt;input class=&quot;edit&quot; type=&quot;text&quot; v-model=&quot;item.text&quot; @key.enter=&quot;doneEdit(item)&quot; @blur=&quot;doneEdit(item)&quot; @keyup.esc=&quot;cancelEdit(item)&quot; /&gt; 当我们在文本框中输入值的时候item.text的值发生了变化。当key发生了变化后，重新渲染的时候发现新的li对应的vnode（虚拟DOM）与原有的li的vnode的key不相同，此时会重新生成li,导致其内部的子元素也会重新生成。由于重新生成了文本框，所以文本框内没有焦点。 如果item对象内有id属性，绑定该属性就可以解决这个问题了，但是这里没有，可以直接绑定item,因为每个item对象是不相等的。 12345&lt;li v-for=&quot;item in todos&quot; :key=&quot;item&quot; :class=&quot;&#123; editing: item === editingTodo &#125;&quot; &gt; 经过测试，发现这时就解决了我们刚才提到的问题，因为由于key的值为item,那么在文本框中输入值的时候，对应的item对象没有变化，变化的是item中的text属性，对象还是原来的对象，只是其中的text的属性的值发生了变化。那么这样由于key的值不会发生变化，那么就不会重新生成li·以及内部的文本框，所以在这里输入内容的文本框还是原来的文本框。 最后，还有一个问题需要解决，就是双击以后，出现文本框，然后让其获取焦点。 5、编辑任务2为了能够实现双击文本后，出现文本框，并且在文本框中显示焦点，这里需要用到指令来实现。 Vue3与Vue2.x在自定义指令的差别，就是在钩子函数的命名上，vue3中把指令的钩子函数与组件的钩子函数保持一致,这样更容易理解 Vue2.x中指令的定义方式 1234567Vue.directive(&#x27;editingFocus&#x27;,&#123; bind(el,binding,vnode,prevVnode)&#123;&#125;, inserted()&#123;&#125;, update()&#123;&#125;, componentUpdated()&#123;&#125;, unbind()&#123; &#125;&#125;) 12345bind：当指令绑定在对应元素时触发。只会触发一次。inserted：当对应元素被插入到 DOM 的父元素时触发。update：当元素更新时，这个钩子会被触发（此时元素的后代元素还没有触发更新）。componentUpdated：当整个组件（包括子组件）完成更新后，这个钩子触发。unbind：当指令被从元素上移除时，这个钩子会被触发。也只触发一次。 Vue3中指令的定义方式 12345678app.directive(&#x27;editingFocus&#x27;,&#123; beforeMount(el, binding, vnode, prevVnode) &#123;&#125;, mounted() &#123;&#125;, beforeUpdate() &#123;&#125;, updated() &#123;&#125;, beforeUnmount() &#123;&#125;, unmounted() &#123;&#125;,&#125;) 1234567bind =&gt; beforeMountinserted =&gt; mountedbeforeUpdate: 新的钩子，会在元素自身更新前触发update =&gt; 移除！componentUpdated =&gt; updatedbeforeUnmount: 新的钩子，当元素自身被卸载前触发unbind =&gt; unmounted 以上是自定义指令的第一种用法，在定义自定义指令的时候，还可以传函数。这样用法比较简洁，而且更加常用。第二个参数是函数的时候，vue2与vu3的用法是一样的。 Vue2.x 123Vue.directive(&#x27;editingFocus&#x27;,(el,binding)=&gt;&#123; binding.value &amp;&amp; el.focus()&#125;) Vue3.0 123app.directive(&#x27;editingFocus&#x27;,(el,binding)=&gt;&#123; binding.value &amp;&amp; el.focus()&#125;) 指令名称后面的这个函数在vue3中是在，mounted与updated的时候执行，与Vue2的执行时机是一样的。在Vue2中这个函数是在bind与update的时候执行。 函数中的el参数是指令所绑定的元素，binding中可以获取指令对应的值。通过binding.value来获取。 下面，根文本框添加指令 123456789&lt;input class=&quot;edit&quot; type=&quot;text&quot; v-model=&quot;item.text&quot; v-editing-focus=&quot;item === editingTodo&quot; @key.enter=&quot;doneEdit(item)&quot; @blur=&quot;doneEdit(item)&quot; @keyup.esc=&quot;cancelEdit(item)&quot; /&gt; 在input标签上添加了一个v-eding-focus的指令，该指令以v-开头。但是这里需要注意的一点就是，当文本框处于编辑状态的时候，该指令才起作用。所以，这里，判断item是否等于editingTodo，如果成立，也就是为true,表明处于编辑状态，则让文本框获得焦点。 v-editing-focus指令定义如下： 1234567891011121314151617181920export default &#123; name: &quot;App&quot;, setup() &#123; const todos = ref([]); const &#123; remove &#125; = useRemove(todos); return &#123; ...useAdd(todos), ...useEdit(remove), remove, todos, &#125;; &#125;, directives: &#123; editingFocus: (el, binding) =&gt; &#123; if (binding.value) &#123; el.focus(); &#125; &#125;, &#125;,&#125;; 注意：directives与setup是同级定义的。 在定义指令的时候，不需要添加v-前缀。同时判断一下binding.value中的值是否为true,如果是，在让文本框获取焦点，因为当前处于编辑状态。 6、切换任务状态 点击左上角的复选框(该复选框的高度与宽度都是1px,为了美观，这里单击的是label),改变所有任务的状态(要么全部完成，要么全部未完成) 单击底部的All/Active/Completed按钮，单击All按钮，展示所有的任务。单击Active展示的是没有完成的任务,Completed展示的是已经完成的任务 显示未完成的任务项个数。 移除所有完成的项目 如果没有任务项，隐藏main与footer区域。 6.1 改变所有任务的状态单击左上角的复选框，改变所有任务项的状态。 12345&lt;div class=&quot;view&quot;&gt; &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; v-model=&quot;item.completed&quot; /&gt; &lt;label @dblclick=&quot;editTodo(item)&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;/label&gt; &lt;button class=&quot;destroy&quot; @click=&quot;remove(item)&quot;&gt;&lt;/button&gt; &lt;/div&gt; 在li中的每个任务项名称前面都有一个复选框，这里复选框的状态是有completed属性来决定，所以这里通过v-model绑定completed属性。 根左上角的复选框绑定一个计算属性 123456&lt;input id=&quot;toggle-all&quot; class=&quot;toggle-all&quot; type=&quot;checkbox&quot; v-model=&quot;allDone&quot; /&gt; 123456789101112131415161718192021222324252627282930//4、切换任务的状态。//这里单击左上角的复选框后，会改变所有任务项的状态，同时，如果所有的任务项都选中，左上角的复选框也选中//只要有一个未选中，则该复选框不选中。这里复选框的状态是受`todos`这个数组中的数据的影响，所以通过计算属性来完成const userFilter = (todos) =&gt; &#123; const allDone = computed(&#123; //渲染左上角的checkbox的时候，会执行`get` //在`get`方法中，遍历`todos`，获取每个任务项的状态，从而决定左上角的复选框的状态。 //如果`todos`中的任务都完成处理，返回true,只有有一项没有完成则返回false. get() &#123; //注意todos是响应式对象，通过value获取数组。下面这行代码可以获取到todos数组中所有完成的任务。 // return todos.value.filter((todo) =&gt; todo.completed); //获取的是所有未完成的任务的数量 // return todos.value.filter((todo) =&gt; !todo.completed).length; // 在todos前面加上了!,表示的含义是，如果所有的任务都完成(所有的任务都完成，那么长度length的值为0，前面取反，则为true)返回true.如果有一项任务没有完成，则返回false. //当单击每个任务项前面的复选框时，都会执行该计算属性的get方法，因为每一个任务项前面的复选框通过`v-model`绑定了todos中的completed属性，该属性值的变化，导致`todos`这个数组中的数据变化，所以get方法会执行。 return !todos.value.filter((todo) =&gt; !todo.completed).length; &#125;, //当单击左上角的checkbox的时候，会执行set操作。在set方法中，设置每个任务的状态.与左上角的checkbox的状态保持一致,该方法的参数value,表示的是当单击左上角的checkbox的时候，会将该checkbox的状态传递过来。所以value参数存储的就是左上角复选框的状态。那么根据传递过来的状态修改&#x27;todos&#x27;中所有任务项的`completed`属性的值。 //当todos中的`completed`中的状态发生了变化，会重新渲染视图（todos响应式数据）。 set(value) &#123; todos.value.forEach((todo) =&gt; &#123; todo.completed = value; &#125;); &#125;, &#125;); return &#123; allDone, &#125;;&#125;; 下面要解决的是，当处理完某个任务后，为其添加上对应的横线。 12345&lt;li v-for=&quot;item in todos&quot; :key=&quot;item&quot; :class=&quot;&#123; editing: item === editingTodo, completed: item.completed &#125;&quot; &gt; 当item.completed属性为true的时候，给列表添加completed样式。 6.2 切换状态单击底部的All/Active/Completed按钮，单击All按钮，展示所有的任务。单击Active展示的是没有完成的任务,Completed展示的是已经完成的任务 以上三个按钮，都是基于hash的链接，当单击这些链接的时候，会触发hashchange事件，在事件的处理函数中，我们可以获取到对应的hash值，然后根据hash值，调用不同的过滤方法，查询对应的数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const userFilter = (todos) =&gt; &#123; const allDone = computed(&#123; //渲染左上角的checkbox的时候，会执行`get` //在`get`方法中，遍历`todos`，获取每个任务项的状态，从而决定左上角的复选框的状态。 //如果`todos`中的任务都完成处理，返回true,只有有一项没有完成则返回false. get() &#123; console.log(&quot;abc&quot;); //注意todos是响应式对象，通过value获取数组。下面这行代码可以获取到todos数组中所有完成的任务。 // return todos.value.filter((todo) =&gt; todo.completed); //获取的是所有未完成的任务的数量 // return todos.value.filter((todo) =&gt; !todo.completed).length; // 在todos前面加上了!,表示的含义是，如果所有的任务都完成(所有的任务都完成，那么长度length的值为0，前面取反，则为true)返回true.如果有一项任务没有完成，则返回false. return !todos.value.filter((todo) =&gt; !todo.completed).length; &#125;, //当单击左上角的checkbox的时候，会执行set操作。在set方法中，设置每个任务的状态.与左上角的checkbox的状态保持一致,该方法的参数value,表示的是当单击左上角的checkbox的时候，会将该checkbox的状态传递过来。所以value参数存储的就是左上角复选框的状态。 set(value) &#123; todos.value.forEach((todo) =&gt; &#123; todo.completed = value; &#125;); &#125;, &#125;); const filter = &#123; all: (list) =&gt; list, active: (list) =&gt; list.filter((todo) =&gt; !todo.completed), completed: (list) =&gt; list.filter((todo) =&gt; todo.completed), &#125;; const type = ref(&quot;all&quot;); const filterreadTodos = computed(() =&gt; filter[type.value](todos.value)); const onHashChange = () =&gt; &#123; const hash = window.location.hash.replace(&quot;#/&quot;, &quot;&quot;); if (filter[hash]) &#123; type.value = hash; &#125; else &#123; //有可能首次加载，或者输入了错误的hash值 type.value = &quot;all&quot;; window.location.hash = &quot;&quot;; &#125; &#125;; onMounted(() =&gt; &#123; window.addEventListener(&quot;hashchange&quot;, onHashChange); onHashChange(); &#125;); onUnmounted(() =&gt; &#123; window.removeEventListener(&quot;hashchange&quot;, onHashChange); &#125;); return &#123; allDone, filterreadTodos, &#125;;&#125;; 模板中遍历的是filterreadTodos 12345&lt;li v-for=&quot;item in filterreadTodos&quot; :key=&quot;item&quot; :class=&quot;&#123; editing: item === editingTodo, completed: item.completed &#125;&quot; &gt; 整个数据的过滤的操作还是定义在userFilter方法中完成。在该方法中，指定onMounted钩子函数，也就是组件挂载完毕后，完成hashchange事件的绑定， 事件触发以后执行`` 1234onMounted(() =&gt; &#123; window.addEventListener(&quot;hashchange&quot;, onHashChange); onHashChange(); &#125;); 当第一次进入页面，还没有单击链接的时候，也要调用 onHashChange();方法,进行数据的过滤，当单击了链接以后，hashchange事件触发也要调用onHashChange方法，完成数据的过滤。 在onUnmounted方法中移除事件的绑定。 123onUnmounted(() =&gt; &#123; window.removeEventListener(&quot;hashchange&quot;, onHashChange); &#125;); 下面看一下 onHashChange();方法的实现 12345678910const onHashChange = () =&gt; &#123; const hash = window.location.hash.replace(&quot;#/&quot;, &quot;&quot;); if (filter[hash]) &#123; type.value = hash; &#125; else &#123; //有可能首次加载，或者输入了错误的hash值 type.value = &quot;all&quot;; window.location.hash = &quot;&quot;; &#125;&#125;; 在onHashChange方法中，首先获取hash值，然后将#/去掉，只保留all或者是active,completed. 然后判断在filter中是否定义了对应的过滤方法。 filter类的实现如下： 12345const filter = &#123; all: (list) =&gt; list, active: (list) =&gt; list.filter((todo) =&gt; !todo.completed), completed: (list) =&gt; list.filter((todo) =&gt; todo.completed),&#125;; 在filter中，定义了不同的过滤方法。 如果根据获取到的hash值能够从filter中查询到对应的过滤方法。那么把hash值赋值给type.value type是一个响应式对象，默认值为all 1const type = ref(&quot;all&quot;); type的值发生了改变，就会重新渲染视图，渲染视图的时候会执行 v-for=&quot;item in filterreadTodos&quot;,而filterreadTodos是一个计算属性。 1const filterreadTodos = computed(() =&gt; filter[type.value](todos.value)); 该计算属性依赖的type的值发生变化，所以会执行computed内的函数，根据type中存储的值，从filter中查询到对应的过滤函数，把todos数组中的内容传递到该函数中进行过滤。 以上是在filter中找到对应的过滤方法的情况。 如果在filter中找不到对应的过滤方法，会执行： 12type.value = &quot;all&quot;; window.location.hash = &quot;&quot;; 执行上面的代码，有可能是首次加载，也有可能是输入的hash值是错误的。 这时把type的值修改成all,表示加载所有的任务数据。并且把地址栏中的hash值清空。 注意：最开开始要导入对应的钩子函数。 1import &#123; ref, computed, onMounted, onUnmounted &#125; from &quot;vue&quot;; 同时，还需要注意，最后一定要将filterreadTodos内容返回。 1234return &#123; allDone, filterreadTodos,&#125;; 6.3 剩余内容处理 显示未完成的任务项个数。 移除所有完成的项目 如果没有任务项，隐藏main与footer区域。 下面先来实现第一条内容：显示未完成的任务项个数。 这个功能需要通过计算属性来完成，也就是统计todos数组中数据的变化情况。 12345&lt;footer class=&quot;footer&quot;&gt; &lt;span class=&quot;todo-count&quot;&gt; &lt;strong&gt;&#123;&#123; remainingCount &#125;&#125;&lt;/strong&gt; &#123;&#123; remainingCount &gt; 1 ? &quot;items&quot; : &quot;item&quot; &#125;&#125; left &lt;/span&gt; 整个数据的统计是有remainingCount计算属性完成的，该属性返回的值如果大于1,显示items，否则显示item. 关于remainingCount计算属性的实现还是在userFilter方法中完成，该方法都是与过滤相关的业务内容。 12const filterreadTodos = computed(() =&gt; filter[type.value](todos.value)); const remainingCount = computed(() =&gt; filter.active(todos.value).length); 在原有的filterreadTodos整个过滤器的下面，定义了remainingCount过滤器，该过滤器调用了filter中的active方法来获取未处理的任务项数据，然后再统计其个数。当第一次渲染的时候，会执行remainingCount计算属性，当todos数组中的数据发生了变化后，还会执行该计算属性，来进行数据的统计。 最后需要将remainingCount计算属性返回，这样在模板中才能使用。 12345return &#123; allDone, filterreadTodos, remainingCount, &#125;; 下面要实现的是”移除所有完成的项目” 给底部右下角的按钮绑定单击事件。 123&lt;button class=&quot;clear-completed&quot; @click=&quot;removeCompleted&quot;&gt; Clear completed &lt;/button&gt; removeCompleted方法定义在useRemove方法中，该方法是有关删除的相关业务的内容。 12345678910111213141516// 2. 删除任务const useRemove = (todos) =&gt; &#123; const remove = (todo) =&gt; &#123; const index = todos.value.indexOf(todo); todos.value.splice(index, 1); &#125;; //删除已经完成的任务项数据 const removeCompleted = () =&gt; &#123; //这里把未完成的数据过滤出来，展示的页面中就可以了。 todos.value = todos.value.filter((todo) =&gt; !todo.completed); &#125;; return &#123; remove, removeCompleted,//最后要将removeCompleted函数返回 &#125;;&#125;; 在removeCompleted方法中，把todos数组中未完成的数据查询出来，重新赋值给todos数组，这样数组todos数组中存储的就是未完成处理的数据。当todos中的内容发生了变化后，计算属性filterreadTodos也会重新执行，从而重新渲染列表。注意：最后要将removeCompleted函数返回 下面修改一下setup函数中的内容。 12345678910111213setup() &#123; const todos = ref([]); //将useRomve函数中定义的removeCompleted方法解构出来 const &#123; remove, removeCompleted &#125; = useRemove(todos); return &#123; ...useAdd(todos), ...useEdit(remove), ...userFilter(todos), remove, removeCompleted,//返回removeCompleted方法，这样模板中就可以使用了。 todos, &#125;; &#125;, 如果没有任务项，隐藏main与footer区域。 如果没有数据，只显示输入的文本框，隐藏其它的位置 下面给footer与main,都去添加v-show 12&lt;section class=&quot;main&quot; v-show=&quot;count&quot;&gt; &lt;footer class=&quot;footer&quot; v-show=&quot;count&quot;&gt; 当count中有值，则展示main与footer中的内容，否则进行隐藏。count中的值为任务的总数。 这里的count必须是一个计算属性，因为count的值依赖响应式数据todos.todos的数据发生了变化，需要重新计算count的值。 下面，我们在userFilter中实现count这个计算属性。 12const remainingCount = computed(() =&gt; filter.active(todos.value).length); const count = computed(() =&gt; todos.value.length); 在remainingCount下面定义count这个计算属性，同时将count返回。 123456return &#123; allDone, filterreadTodos, remainingCount, count,&#125;; 7、本地存储下面要将数据存储起来，否则单击浏览器的刷新按钮，数据会丢失。这里是把任务数据存储到localStorage中。 在src目录下面定义utils目录，在该目录下面创建useLocalStorage.js文件，该文件中的代码如下： 1234567891011121314151617181920212223242526272829303132333435function parse(str)&#123; let value; try&#123; value=JSON.parse(str) &#125;catch&#123; value=null &#125; return value&#125;function stringify(obj)&#123; let value try&#123; value=JSON.stringify(obj) &#125;catch&#123; value=null &#125; return value&#125;export default function useLocalStorage()&#123; function setItem(key,value)&#123; value=stringify(value) window.localStorage.setItem(key,value) &#125; function getItem(key)&#123; let value=window.localStorage.getItem(key) if(value)&#123; value=parse(value) &#125; return value &#125; return &#123; setItem, getItem &#125;&#125; 在上面的代码中创建了parse函数，该函数将字符串转换成对象，stringify函数将对象转换成字符串。 同时导出了useLocalStorage函数，该函数中封装了对localStorage操作的两个方法，setItem添加数据到localStorage中，getItem把数据从localStorage找那个取出来。 最后返回setItem与getItem这两个方法。 现在回到App.vue文件中。 12345import &#123; ref, computed, onMounted, onUnmounted, watchEffect &#125; from &quot;vue&quot;;import useLocalStorage from &quot;./utils/useLocalStorage&quot;;import &quot;./assets/index.css&quot;;const storage = useLocalStorage(); 首先导入useLocalStorage函数，接下来调用该函数，我们知道该函数返回的是一个对象，该对象中存储的是getItem与setItem,这里都存储到常量storage中。 我们知道，当数据发生变化后，不管是添加，更新，还是删除，都需要将变化后的数据重新的保存到localStorage中，哪么应该怎样处理呢？如果在添加,删除，更新的方法中都写这些代码，那么就比较麻烦了。所以这里我们可以在封装一个方法，这个方法里完成对localStorage中数据更新的操作。 123456789//5、存储任务数据const useStorage = () =&gt; &#123; const key = &quot;todokey&quot;; const todos = ref(storage.getItem(key) || []); watchEffect(() =&gt; &#123; storage.setItem(key, todos.value); &#125;); return todos;&#125;; 在useStorage方法中，首先获取localStorage中的数据，获取到了给todos，如果没有获取到返回的就是一个空数组。注意这里的todos是一个响应式的对象。 下面我们通过watchEffect函数检测todos中的数据是否有变化，如果有变化执行watchEffect内的回调函数，将数据重新保存到localStroage中。最后把响应式对象todos返回。 下面修改setup方法中的代码 123456789101112setup() &#123; const todos = useStorage(); const &#123; remove, removeCompleted &#125; = useRemove(todos); return &#123; ...useAdd(todos), ...useEdit(remove), ...userFilter(todos), remove, removeCompleted, todos, &#125;; &#125;, 在setup这个方法中，我们调用了useStorage方法，把返回的内容给了todos这个常量，注意：这个常量也是响应式对象，因为useStorage方法返回的就是一个响应式对象。当我们第一次执行的时候，从storage中获取数据，后期todos中数据有变化都会执行watchEffect这个函数，然后将数据保存到localStorage中。 以上，就是整个todoList案例，在这个案例中，我们将不同的业务逻辑封装到了不同的函数中，整体的代码结构非常的情形。"},{"title":"Pinia基本使用","path":"2025/05/12/Pinia/","text":"Pinia基本使用Pinia中文文档：https://pinia.web3doc.top/ Pinia的介绍 Pinia最初是为了探索Vuex下一次迭代而产生的，结合了Vue5核心团队的很多想法。最终团队意识到Pinia已经实现了Vue5的大部分内容，决定实验Pinia来替代Vuex。 Pinia与Vuex的对比 mutations不在存在。 Pinia与Vuex的对比，Pinia提供了更简单的api，并且与ts一起使用时具有更可靠的类型判断。 没有模块嵌套和命名空间，不在需要记住他们之间的关系。 安装Pinia123yarn add pinia# 或者使用 npmnpm install pinia 定义Storethis 可以访问到 整个 store 的实例 12345678910111213141516171819202122232425import &#123; defineStore &#125; from &#x27;pinia&#x27;// useStore 可以是 useUser、useCart 之类的任何东西// 第一个参数是应用程序中 store 的唯一 id，官方的约束是use***，以use+name的一个约定，不是必须，只是建议export const useStore = defineStore(&#x27;main&#x27;, &#123; state: () =&gt; &#123; // 数据 return &#123; // 所有这些属性都将自动推断其类型 counter: 0, name: &#x27;Eduardo&#x27;, isAdmin: true, &#125; &#125;, getters: &#123; // 同计算属性 doubleCount: (state) =&gt; state.counter * 2, &#125;, actions: &#123; increment() &#123; this.counter++ &#125;, randomizeCounter() &#123; this.counter = Math.round(100 * Math.random()) &#125;, &#125;,&#125;) 修改Store的数据 注意：修改的数据如果直接结构，数据不是响应式的 使用Vue的toRefs()或Pinia的storeToRefs() 在组件中引入Store直接修改 123456// 简单粗暴import &#123;Store&#125; from &#x27;../store/index&#x27;const store = Store()const handleClick = () =&gt; &#123; store.count++&#125; 使用$patch对象 12345678// 多数据修改做过优化import &#123;Store&#125; from &#x27;../store/index&#x27;const store = Store()const handleClick = () =&gt; &#123; store.$patch(&#123; count:store.count+2 &#125;)&#125; 使用$patch函数 12345678// 使用的是函数，可以处理复制的业务import &#123;Store&#125; from &#x27;../store/index&#x27;const store = Store()const handleClick = () =&gt; &#123; store.$patch((state)=&gt;&#123; state.count++ &#125;)&#125; 在actions中修改 12345678// 用于复杂或多处使用相同的方法actions: &#123; changeState()&#123; this.count++ &#125;&#125;// 在组件中使用store.changeState() Pinia中的getters使用与Vue的计算属性一样，修改的数据有缓存，对性能优化有好处 123456getters: &#123; // 同计算属性 doubleCount: (state) =&gt; state.counter * 2, phoneHidden: (state) =&gt; state.phone.toString().replace(/^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/,&#x27;$1****$2&#x27;)&#125;// 组件中使用store.doubleCount Pinia中Store的互相调用 不同的Store的相互调用非常简单，和组件使用相同 1234import &#123;userInfo&#125; from &#x27;../store/userInfo&#x27;const store = userInfo()store.xxx需要在哪使用直接拿即可 Pinia组合式 上面的使用方法更适合Vue2的形式，在Vue3中更使用组合式 将defineStore的第二个参数改为函数，需要使用的值返回出去 1234567891011121314151617181920212223242526272829import &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; ref &#125; from &quot;vue&quot;;// 定义 Store，使用函数，更适合Vue3，注意要使用ref并将需要的数据或函数返回出去export const useTestStore = defineStore( &quot;test&quot;, () =&gt; &#123; // 定义的变量使用ref const testText = ref&lt;string&gt;(&quot;&quot;); // 保存会员信息，登录时使用 const setTestText = (val: string) =&gt; &#123; testText.value = val; &#125;; // 清理会员信息，退出时使用 const clearsetTestText = () =&gt; &#123; testText.value = &quot;&quot;; &#125;; // 返回需要使用的变量，和setup函数一样 return &#123; testText, setTestText, clearsetTestText, &#125;; &#125;); 持久化 pinia的数据默认情况下刷新后会丢失 pinia-plugin-persistedstate：帮助pinia持久化的插件 uniapp的代码示例： 1234567891011121314// index.tsimport &#123; createPinia &#125; from &quot;pinia&quot;;import persist from &quot;pinia-plugin-persistedstate&quot;;// 创建 pinia 实例const pinia = createPinia();// 使用持久化存储插件pinia.use(persist);// 默认导出，给 main.ts 使用export default pinia;// 统一导出export * from &quot;./modules/test&quot;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// modules/test.tsimport &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; ref &#125; from &quot;vue&quot;;// 实际上可以直接使用 uni.getStorageSync() ,但是使用原生的方式理论上性能会好一点（不需要经过uniapp的编译/处理）let persist;// #ifdef H5 || WEBpersist = true;// #endif// #ifndef H5 || WEBpersist = &#123; storage: &#123; getItem(key: string) &#123; return uni.getStorageSync(key); &#125;, setItem(key: string, value: any) &#123; uni.setStorageSync(key, value); &#125;, &#125;,&#125;;// #endif// 定义 Store，使用函数，更适合Vue3，注意要使用ref并将需要的数据或函数返回出去export const useTestStore = defineStore( &quot;test&quot;, () =&gt; &#123; const testText = ref&lt;string&gt;(&quot;&quot;); // 保存会员信息，登录时使用 const setTestText = (val: string) =&gt; &#123; testText.value = val; &#125;; // 清理会员信息，退出时使用 const clearsetTestText = () =&gt; &#123; testText.value = &quot;&quot;; &#125;; // 记得 return return &#123; testText, setTestText, clearsetTestText, &#125;; &#125;, &#123; persist, &#125;);"},{"title":"Vue2懒加载下拉组件","path":"2025/05/12/Vue2懒加载下拉组件/","text":"Vue2懒加载下拉组件 需要安装element 或者按照这个思路封装其他的组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;template&gt; &lt;el-select :value=&quot;value&quot; size=&quot;small&quot; clearable filterable :multiple=&quot;multiple&quot; placeholder=&quot;请输入关键词&quot; v-el-select-loadmore=&quot;loadmore&quot; :filter-method=&quot;handleSearch&quot; @change=&quot;handleChange&quot;&gt; &lt;template v-if=&quot;lazyData&amp;&amp;lazyData.length&gt;0&quot;&gt; &lt;el-option v-for=&quot;item in lazyData&quot; :key=&quot;item[prop.key||&#x27;id&#x27;]&quot; :label=&quot;item[prop.label||&#x27;label&#x27;]&quot; :value=&quot;item[prop.value||&#x27;id&#x27;]&quot;&gt; &lt;/el-option&gt; &lt;/template&gt; &lt;/el-select&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; value: &#123; type: [String, Number, Array] &#125;, data: &#123; type: [], default: () =&gt; [] &#125;, multiple: &#123; type: Boolean, default: false &#125;, prop: &#123; type: Object, default: () =&gt; (&#123; key: &#x27;id&#x27;, label: &#x27;label&#x27;, value: &#x27;id&#x27;, &#125;) &#125; &#125;, model: &#123; prop: &#x27;value&#x27;, event: &#x27;change&#x27; &#125;, data() &#123; return &#123; keyWord: &#x27;&#x27;, pageData: &#123; pageIndex: 1, pageSize: 10 &#125;, lazyData: null, completeData: null &#125; &#125;, directives: &#123; &#x27;el-select-loadmore&#x27;: &#123; bind(el, binding) &#123; const SELECTWRAP_DOM = el.querySelector( &#x27;.el-select-dropdown .el-select-dropdown__wrap&#x27; ); SELECTWRAP_DOM.addEventListener(&#x27;scroll&#x27;, function () &#123; const condition = this.scrollHeight - this.scrollTop &lt;= this.clientHeight; if (condition) &#123; binding.value(); &#125; &#125;); &#125; &#125; &#125;, watch: &#123; data: &#123; deep: true, immediate: true, handler(val) &#123; if (val.length &gt; 0) &#123; this.lazyData = val.slice(0, this.pageData.pageSize) this.completeData = JSON.parse(JSON.stringify(val)) this.updateLazyData(this.value) &#125; &#125;, &#125;, value: &#123; immediate: true, handler(val) &#123; this.updateLazyData(val) &#125; &#125; &#125;, methods: &#123; handleChange(val) &#123; this.$emit(&#x27;change&#x27;, val) &#125;, // 自定义搜索 handleSearch(key) &#123; this.keyWord = key.trim() if (key) &#123; this.lazyData = this.completeData.filter(item =&gt; &#123; return item.name.includes(key) &#125;) &#125; else &#123; this.lazyData = this.completeData.slice(0, this.pageData.pageSize) &#125; &#125;, // 懒加载 loadmore() &#123; // 如果有搜索关键字，则不加载懒加载数据 if (this.keyWord) &#123; this.pageData.pageIndex = 1 return &#125; this.pageData.pageIndex++; let num = this.pageData.pageIndex * this.pageData.pageSize; this.lazyData = this.completeData.filter((item, index, arr) =&gt; &#123; return index &lt; num; //这里默认allData已经取到了数据 &#125;); &#125;, // 有 value 时更新懒加载数据 updateLazyData(val) &#123; if (val &amp;&amp; this.completeData &amp;&amp; this.lazyData) &#123; let isShow = this.lazyData.some(item =&gt; item.id == val) if (!isShow) &#123; let index = this.completeData.findIndex(item =&gt; item.id == val) let item = this.completeData.splice(index, 1) this.lazyData = [...this.lazyData, ...item] &#125; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;"},{"title":"NuxtJS基础","path":"2025/05/12/NuxtJS/","text":"NuxtJS中文网：https://www.nuxtjs.cn/ 最常见的就是服务端渲染（SSR），与传统的 Vue SPA 相比，使用 SSR 将带来巨大的 SEO 提升、更好的用户体验和更多的机会。 也有生成静态站点和单页应用程序 (SPA)，相对来讲用的没有那么多 安装为了快速入门，Nuxt.js 团队创建了脚手架工具 create-nuxt-app。 确保安装了 npx（npx 在 NPM 版本 5.2.0 默认安装了）： 1npx create-nuxt-app &lt;项目名&gt; 或者用 yarn ： 1yarn create nuxt-app &lt;项目名&gt; 从头开始新建项目如果不使用 Nuxt.js 提供的 starter 模板，我们也可以从头开始新建一个 Nuxt.js 应用项目，过程非常简单，只需要 1 个文件和 1 个目录。如下所示： 12mkdir &lt;项目名&gt;cd &lt;项目名&gt; 新建 package.json 文件package.json 文件用来设定如何运行 nuxt： 123456&#123; &quot;name&quot;: &quot;my-app&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;nuxt&quot; &#125;&#125; 上面的配置使得我们可以通过运行 npm run dev 来运行 nuxt。 安装 nuxt一旦 package.json 创建好， 可以通过以下 npm 命令将 nuxt 安装至项目中： 1npm install --save nuxt pages 目录Nuxt.js 会依据 pages 目录中的所有 *.vue 文件生成应用的路由配置。 创建 pages 目录： 1mkdir pages 创建我们的第一个页面 pages/index.vue： 123&lt;template&gt; &lt;h1&gt;Hello world!&lt;/h1&gt;&lt;/template&gt; 然后启动项目： 1npm run dev 现在我们的应用运行在 http://localhost:3000 上运行。 路由 要在页面之间使用路由，我们建议使用标签。 1&lt;nuxt-link to=&quot;/&quot;&gt;首页&lt;/nuxt-link&gt; 使用a链接跳转会刷新页面 1&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt; 编程式导航和Vue的一样，就是用的Router 1234567&lt;button @click=&quot;goto&quot;&gt;首页&lt;/button&gt;···methods:&#123; goto()&#123; this.$router.push(&#x27;/&#x27;) &#125;&#125; 基础路由假设 pages 的目录结构如下： 12345pages/--| user/-----| index.vue-----| one.vue--| index.vue 那么，Nuxt.js 自动生成的路由配置如下： 12345678910111213141516171819router: &#123; routes: [ &#123; name: &#x27;index&#x27;, path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27; &#125;, &#123; name: &#x27;user&#x27;, path: &#x27;/user&#x27;, component: &#x27;pages/user/index.vue&#x27; &#125;, &#123; name: &#x27;user-one&#x27;, path: &#x27;/user/one&#x27;, component: &#x27;pages/user/one.vue&#x27; &#125; ]&#125; 动态路由在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的以下划线作为前缀的 Vue 文件 或 目录。 以下目录结构： 1234567pages/--| _slug/-----| comments.vue-----| index.vue--| users/-----| _id.vue--| index.vue Nuxt.js 生成对应的路由配置表为： 123456789101112131415161718192021222324router: &#123; routes: [ &#123; name: &#x27;index&#x27;, path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27; &#125;, &#123; name: &#x27;users-id&#x27;, path: &#x27;/users/:id?&#x27;, component: &#x27;pages/users/_id.vue&#x27; &#125;, &#123; name: &#x27;slug&#x27;, path: &#x27;/:slug&#x27;, component: &#x27;pages/_slug/index.vue&#x27; &#125;, &#123; name: &#x27;slug-comments&#x27;, path: &#x27;/:slug/comments&#x27;, component: &#x27;pages/_slug/comments.vue&#x27; &#125; ]&#125; 你会发现名称为 users-id 的路由路径带有 :id? 参数，表示该路由是可选的。如果你想将它设置为必选的路由，需要在 users/_id 目录内创建一个 index.vue 文件。 嵌套路由你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。 创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。 Warning: 别忘了在父组件(.vue文件) 内增加 &lt;nuxt-child/&gt; 用于显示子视图内容。 假设文件结构如： 12345pages/--| users/-----| _id.vue-----| index.vue--| users.vue Nuxt.js 自动生成的路由配置如下： 1234567891011121314151617181920router: &#123; routes: [ &#123; path: &#x27;/users&#x27;, component: &#x27;pages/users.vue&#x27;, children: [ &#123; path: &#x27;&#x27;, component: &#x27;pages/users/index.vue&#x27;, name: &#x27;users&#x27; &#125;, &#123; path: &#x27;:id&#x27;, component: &#x27;pages/users/_id.vue&#x27;, name: &#x27;users-id&#x27; &#125; ] &#125; ]&#125; 动态嵌套路由这个应用场景比较少见，但是 Nuxt.js 仍然支持：在动态路由下配置动态子路由。 假设文件结构如下： 123456789pages/--| _category/-----| _subCategory/--------| _id.vue--------| index.vue-----| _subCategory.vue-----| index.vue--| _category.vue--| index.vue Nuxt.js 自动生成的路由配置如下： 123456789101112131415161718192021222324252627282930313233343536router: &#123; routes: [ &#123; path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27;, name: &#x27;index&#x27; &#125;, &#123; path: &#x27;/:category&#x27;, component: &#x27;pages/_category.vue&#x27;, children: [ &#123; path: &#x27;&#x27;, component: &#x27;pages/_category/index.vue&#x27;, name: &#x27;category&#x27; &#125;, &#123; path: &#x27;:subCategory&#x27;, component: &#x27;pages/_category/_subCategory.vue&#x27;, children: [ &#123; path: &#x27;&#x27;, component: &#x27;pages/_category/_subCategory/index.vue&#x27;, name: &#x27;category-subCategory&#x27; &#125;, &#123; path: &#x27;:id&#x27;, component: &#x27;pages/_category/_subCategory/_id.vue&#x27;, name: &#x27;category-subCategory-id&#x27; &#125; ] &#125; ] &#125; ]&#125; 更多的路由配置异步数据Nuxt.js 扩展了 Vue.js，增加了一个叫 asyncData 的方法，使得我们可以在设置组件的数据之前能异步获取或处理数据。 1234async asyncData(&#123; params &#125;) &#123; const &#123; data &#125; = await axios.get(`https://my-api/posts/$&#123;params.id&#125;`) return &#123; title: data.title &#125;&#125; 上下文对象可通过 API context 来了解该对象的所有属性和方法。"},{"title":"004.从零开始复习前端--JavaScript","path":"2025/05/12/004.从零开始复习前端--JavaScript/","text":"004.从零开始复习前端–JavaScript JavaScript内容非常多，但是常用的就是一些字符串和数组的方法已经Dom和BOM的事件 只有多用多看，没有速通的方法 复习时可以选择性的看一些书籍 JavaScript半知半解 JavaScript基础教程 JavaScript权威指南 JavaScript高级程序设计 ES6标准入门 你不知道的JavaScript 等等 常规内容1. 基础部分 变量:用来存放数据,保存的数据可以修改 常量:用来存放数据,保存的数据不可修改 变量和常量的本质,无论是变量还是常量,其本身都是数据,也需要在内存中占用内存空间,保存在内存的栈结构分区中 ECMAScript标准定义了8种数据类型 1. 7种原始数据类型：String,Numbr,Boolean,Undefined,null,Symbol,BigInt Object 引用数据类型 Object,Function,Array,Date,RegExp typeof 运算符(判断数据的类型) 作用:用来获取当前变量中存储的数据的类型 typeof的返回值有多少个 String,Number,Boolean,Undefined,Object,Function 特殊的有两个:null和array的结果都是Object instanceOf 运算符(原生JS判断实例的类型) 作用:用来判断当前实例对象是不是某种数据类型 基本数据类型和引用数据类型在内存中,内存空间是如何存储数据的 除 Object 以外的所有类型都是不可变的（值本身无法被改变）,JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。 基本数据类型的值在栈空间中存储,如果修改了数据,则是把原来的值直接干掉,重新存放新的值 引用数据类型的对象在堆空间中存储,该空间的地址在栈空间中存储,如果修改栈空间存储的地址,则指向发生变化,也叫引用发生了变化,此时是在堆空间中重新指向了一个新的内存空间(存储了一个新的对象) 基本类型之间的值如何传递? 传递的是数值 引用类型之间的值如何传递? 传递的是引用(地址) 内存:用于暂时存放CPU中的运算数据以及与硬盘等外部存储器交换的数据 计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来，内存的运行也决定了计算机的稳定运行。 内存通电后产生的存储空间(临时的) 产生和死亡:内存条(集成电路板)—&gt;通电—&gt;产生一定的容量存储空间—&gt;存储各种数据—&gt;断电—&gt;内存空间全部消失 内存的空间是临时的,而硬盘的空间是持久的 内存包含2个数据:内存存储的数据(一般数据/地址数据)和内存地址值数据 内存分类: - 栈结构: 全局变量，局部变量(空间较小) - 堆结构(列表结构): 对象 (空间较大) 2. 对象 具有一定的属性或者方法,特指的某个事物 看得见或者是摸得到,特指的某个东西 识别对象,抽象出对象有什么特征和行为 抽象出当前的对象属于什么类别 以上都是抽象出对象和类别的过程,抽象性 抽象的过程要转变成代码的方式,写代码:先有类别(构造函数),创建对象并设置对象的属性及方法的初始值,对象的初始化过程,最终对象调用相关方法,操作相关属性及某些行为 特征就是属性,行为就是方法,类别就是构造函数,创建对象就是实例化的过程(初始化属性及方法的中) 工厂模式:自定义函数实现对象的创建 通过构造函数实现对象的创建 字面量的方式创建对象 1234567891011121314151617181920212223// 1.通过字面量创建对象var obj =&#123;&#125;// 2.通过工厂模式创建对象function createObject(name,age)&#123; var obj = new Object() obj.name = name obj.age = age return obj&#125;var obj1 =createObject(&#x27;小明&#x27;,10)var obj2 =createObject(&#x27;小红&#x27;,20)console.log(obj1,obj2)// 3.构造函数的方式创建对象function Person(name,gender)&#123; this.name = name this.gender = gender this.sayHi=function()&#123; console.log(&#x27;您好,我是:&#x27;+this.name) &#125;&#125;var per = new Person(&#x27;小明&#x27;,&#x27;男&#x27;)per.sayHi()console.log(per) 通过ES6中的class来创建 12345678910111213141516// 类的方式class Student&#123; constructor(name,age,gender)&#123; this.name = name this.age =age this.gender = gender &#125; // 在原型上 sayHi()&#123; console.log(`您好,我是$&#123;this.name&#125;,几年$&#123;this.age&#125;岁了,是$&#123;this.gender&#125;生`) &#125; // 在实例上 eat=()=&gt;&#123; console.log(&#x27;吃东西啊&#x27;) &#125;&#125; 单例模式 123456789101112131415function createObj() &#123; var instance = null return function (name) &#123; if (!instance) &#123; instance = new Object() instance.name =name &#125; return instance &#125;&#125;var getObj = createObj()var obj1 = getObj(&#x27;小明&#x27;)var obj2 = getObj(&#x27;小红&#x27;)console.log(obj1,obj2)console.log(obj1===obj2) 123451. 对象.属性名字2. 对象[&#x27;属性名字&#x27;]3. 什么时候使用对象[属性名字]的写法 - 不确定属性名字是什么(属性名字是变量) - 属性名字不太规范的时候 123456js是弱类型语言,声明变量都用varjs是脚本语言 直接执行js是解释性语言 直接解释js是动态类型语言 变量在执行的时候才知道具体的类型,对象没有这个属性,点了,就有了js是单线程语言 执行的时候安装一定的顺序,之前的代码执行完毕后,后面才执行js是基于对象的语言,最终所有的对象都指向了object 3. 原型 原型就是对象,JS中原型一共有两个,一个是prototype，一个是**__proto__属性** 1234567891011121314151617181920 - prototype: 浏览器的标准属性,程序员使用的,显示原型,存在于函数中 - __proto__: 浏览器的非标准属性,浏览器使用的,隐式原型,存在于实例对象中 - 函数中有prototype,实例对象中有__proto__ - 实例对象也是对象,里面就有__proto__ - 实例的__proto__与对应函数的prototype都指向原型对象 - 无论是构造函数还是普通函数,或者是方法,只要是函数,内部就有prototype2. 原型的作用之一:共享数据,节省内存空间 1.实例对象一般都是通过构造函数进行创建的,实例化对象的时候做的四件事: - var per = new Person(&#x27;卡卡西&#x27;,20) 1) 申请一块空闲的空间,用来存储当前的实例对象 2) 设置this为当前的实例对象(修改this的指向) 3) 初始化实例对象中的属性和方法的值 4) 把this作为当前对象进行返回 2. 在构造函数中定义的属性及方法,仅仅是编写代码进行定义而已,而实际上里面定义的属性及方法是属于每个实例对象的,所以,创建多个对象,就会开辟多个空间,每个空间中的每个对象都有自己的属性及方法,大量创建对象,对象的方法都不是同一个方法(方法也是函数,函数代码也占用空间),为了节省内存空间,那么可以使用原型的方式,实现数据共享,节省内存空间 3. 原型的作用之二:实现JS中的继承 1). 通过改变原型指向实现继承 2). 借用构造函数显示继承 3). 组合继承 4). 拷贝继承:浅拷贝和深拷贝(递归后再说) 原型对象上有一个constructor属性指向对应的构造函数 function Fn () {} const fn = new Fn() : 区别执行函数定义与执行函数 执行函数定义: 也就是去创建函数对象, 只是有可能被JS引擎提升预处理执行 执行函数: 执行函数体中所有语句 先有函数定义的执行,才有执行函数 常见的回调 DOM事件的回调 定时器中的回调 ajax回调函数(后面讲) 生命周期的回调(后面讲) 立即执行函数(Immediately-Invokey Function Expression) 匿名函数自调用 作用:隐藏内部实现,减少命名空间的污染 说说函数对象上的prototype属性?(prototype什么时候出现,执行函数定义的时候) 执行函数定义定义(有可能被提升执行)创建函数对象 给函数对象添加prototype属性, 属性值为空的Object实例对象, 也就是原型对象 给原型对象添加constructor属性, 值为函数 伪代码: 123456789// 给函数对象添加prototype属性, 属性值为空的Object实例对象, 也就是原型对象function Fn()&#123;&#125;console.dir(Fn)var obj =&#123;&#125;console.log(obj.__proto__===Object.prototype)console.log(Fn.prototype.__proto__===Object.prototype)// 伪代码this.prototype = &#123;&#125; // this就是函数对象this.prototype.constructor = Fn 说说实例对象上的**__proto__属性**?(_proto-什么时候出现,实例化对象的时候) ​ JS引擎在创建实例对象时内部自动执行时, 会自动给实例对象添加__proto__属性, 值为构造函数的 prototype属性的值 1this.__proto__ = Fn.prototype // this是实例对象 原型链(实际上是隐式原型链,言外之意就是和显示原型没毛关系,显示原型产生实例的一瞬间起的作用) 从对象的__proto__开始, 连接的所有对象, 就是我们常说的原型链, 也可称为隐式原型链 查找对象属性简单说: 先在自身上查找, 找不到就沿着原型链查找,如果还找不到返回undefined 查找对象上属性的基本流程 先在对象自身上查找, 如果有, 直接返回 如果没有, 根据__proto__在原型对象上查找, 如果有, 直接返回 如果没有根据原型对象的__proto__在原型对象的原型对象上查找, 一直查找到Object原型对象为止 如果找到了返回, 如果查找不到由于它的__proto__为null, 只能返回undefined 查找对象属性时候,会不会读函数的prototype?(会还是不会) 123456789101112// 简单的原型链function F1()&#123;&#125;F1.prototype.number =100function F2()&#123;&#125;F2.prototype=new F1()F2.prototype.number =200function F3()&#123;&#125;F3.prototype=new F2()F3.prototype.number =300var f3 = new F3()console.log(f3.number)console.dir(f3) 表达式a.b的解析流程 查看a变量: 作用域链查看 不存在 ==&gt; 报错 存在, 得到它的值 基本类型(var a=null/a=undefined,此时a.b报错) null/undefined ===&gt; 报错 number/string/boolean ==&gt; 创建一个包含此值的包装类型对象, 进入下面流程 地址值 ===&gt; 解析.b ===&gt; 查找b属性 先在自身找, 找到了返回, 如果没有找到 原型链查找 找到了返回 没找到, 返回undefined instanceOf 作用: 判断一个任意类型对象的具体类型 如何判断? 对于 A instanceof B A是实例对象, B是构造函数 如果B的prototype属性所指向的原型对象是A实例对象的原型链接上的某个对象, 返回true, 否则返回false 原型与原型链结构图 123456789101112131415function Foo() &#123; &#125;const f1 = new Foo()const f2 = new Foo() const o1 = new Object()const o2 = &#123;&#125;// 下面的结果console.log(Foo instanceof Object)console.log(Foo instanceof Function)console.log(Object instanceof Object)console.log(Function instanceof Function)console.log(Function instanceof Object)console.log(Object instanceof Foo)console.log(f1 instanceof Function)console.log(f1 instanceof Object) 1234561. 对象中有__proto__,函数中有prototype - 实例对象中__proto__指向的是当前实例对象对应的构造函数中的prototype - 而每个prototype都是一个对象,所以,内部必然有__proto__，普通函数中的prototype的__proto__指向的是Object的prototype - 每个函数是Function的实例对象,所以,只要是函数,那么函数对象中__proto__指向的都是Function的prototype,那么这个prototype中的__proto__指向的仍然是Object的prototype - 但是,Object这个构造函数也是函数,所以,Object的__proto__指向的是Function的prototype - Function这个构造函数也是对象,所以里面的__proto__指向的是Function的prototype 继承(改变原型指向/借用构造函数/组合/拷贝) 方式一: 基于构造函数的继承: 原型链 + 借用构造函数的组合式继承 借用父类型构造函数: Person.call(this, name, age) 让子类的原型为父类的实例: Student.prototype = new Person() 让子类型原型的构造器为子类型: Student.prototype.constructor = Student 12345678910111213141516171819202122232425262728// 通过原型实现继承function Person(name,age,gender)&#123; this.name = name this.age =age this.gender = gender&#125;Person.prototype.sayHi=function()&#123; console.log(&#x27;您好&#x27;)&#125;Person.prototype.eat=function()&#123; console.log(&#x27;好吃&#x27;)&#125;function Student(name,age,gender,score)&#123; // 借用构造函数实现属性的继承 Person.call(this,name,age,gender) this.score = score&#125;// 原型实现方法的继承Student.prototype=new Person()Student.prototype.constructor = Student// 重写方法Student.prototype.eat=function()&#123; console.log(&#x27;学生吃&#x27;)&#125;var stu = new Student(&#x27;小明&#x27;,20,&#x27;男&#x27;,100)stu.sayHi()stu.eat()console.log(stu) 方式二: 基于class/类的继承 子类 extends 父类: class Teacher extends Person2 子类构造器中调用父类的构造: super(name, age) 12345678910111213141516171819202122232425262728293031323334353637// ES6的方式实现继承class Person&#123; constructor(name,age)&#123; this.name = name this.age = age &#125; // 原型上的方法 sayHi()&#123; console.log(&#x27;您好&#x27;) &#125; // 赋值的写法就是给实例添加属性或者方法-------- // 实例属性 sex = &#x27;男&#x27; // 实例上的方法 run =function()&#123;&#125; eat=()=&gt;&#123; console.log(&#x27;好吃啊&#x27;) &#125; // 静态属性 static gender=&#x27;男&#x27;&#125;var per = new Person(&#x27;小明明&#x27;,30)console.log(per)console.dir(Person) class Student extends Person&#123; constructor(name,age,gender)&#123; super(name,age) this.gender = gender &#125; // 重写父类中的方法 sayHi()&#123; console.log(&#x27;我很好&#x27;) &#125;&#125;var stu = new Student(&#x27;小明&#x27;,20,&#x27;男&#x27;)console.log(stu) 4. 预解析 js引擎在js代码正式执行之前会做一些预解析的操作 先找关键字var,function 找到var以后将var后面的变量提前声明,但是不赋值 找到function以后将function后面的函数提前声明,但是不赋值,也就是说函数在解析之前已经定义完毕了 变量的提升 - 浏览器在解析js代码之前,先把变量的声明提升 6. 函数的提升 - 浏览器在解析js代码之前,先把函数的声明提升 - 函数提升 ==&gt; 变量提升, 同名的变量忽略 1234567// 先提升的谁?a()var a = 100function a()&#123; console.log(&#x27;函数&#x27;)&#125;console.log(a) ​​ 7. 注意:f2() var f2=function()&#123;&#125;; 报错:因为f2是undefined 8. 预解析:全局预解析和局部预解析 5. 执行上下文 执行上下文(动态的):就是一个代码的执行环境(全局执行上下文和函数执行上下文,eval函数执行上下文) 123456789101112131. 执行上下文概念:代表了代码执行的环境,包含:执行环境,变量对象,this,作用域链2. 流程:- js引擎在js代码正式执行前会先创建一个执行环境- 进入该环境以后会创建一个变量对象,该对象用于收集:变量,函数,函数的参数,this- 找关键字var,function- 确认this- 创建作用域链3. 在全局代码执行前,js引擎就会创建一个栈来存储管理所有的执行上下文4. 在全局执行上下文(window)确定后,将其添加到栈中(压栈)5. 在函数执行上下文创建后,将其添加到栈中(压栈)6. 在当前函数执行完毕后,将栈顶的对象移除(出栈)7. 当所有的代码执行完毕后,栈中只剩下window8. 重点:执行上下文是动态创建的,尤其是针对函数,每调用一次函数都会创建一次执行上下文 总结执行上下文: 当代码要执行,但是没有执行,或者将要执行,在预解析之后,此时出现了全局执行上下文环境(全局执行上下文),创建了一个变量对象,用来收集var , function ,函数参数,确定this的指向,默认全局执行上下文是确定了this是window,这个变量对象会被压入到栈中(全局执行上下文的变量对象在栈中的最下面),如果出现了函数调用,此时出现了局部执行上下文环境(局部执行上下文),再次创建一个变量对象,用来收集函数参数,var ,function,改变this的指向,这个变量对象会被再次压入栈中,在全局执行上下文的变量对象的上面,如果当前函数调用完毕,此时出栈(把局部上下文的变量对象干掉),依次弹出变量对象,就结束了 6. 作用域 概念:变量的使用范围,静态的(编写代码的时候就已经确定了) 全局作用域和局部作用域 全局作用域:函数外部变量的使用范围 局部作用域:函数内变量的使用范围(一个函数就是一个作用域) 块级作用域(ES6新增): const / let 作用:隔离变量,不同的作用域下同名的变量不会冲突 变量分为:全局变量(非函数内部定义的变量)和局部变量(函数内部定义的变量) 多个嵌套的作用域形成的由内向外的结构, 用于查找变量 作用域于执行上下文 123456789101112131415161718192021221. 全局作用域之外,每个函数都会创建自己的作用域,作用域在函数定义时已经确定了,而不是函数调用时2. 全局执行上下文环境在全局作用域确定之后,js代码马上执行之前创建3. 函数执行上下文环境是在调用函数时,函数体代码执行之前创建4. 作用域是静态的,只要函数定义好了就一直存在,且不会再变化5. 执行上下文是动态的,调用函数时创建,函数调用结束时上下文环境就会释放6. 上下文环境(对象)是从属于所在的作用域7. 全局上下文环境--&gt;全局作用域8. 作用域链 1. 用来决定代码执行的范围,变量的作用范围 2. 作用域是代码定义的时候决定的 3. 作用域链是如何产生的 - 函数在定义的时候自动添加一个属性&#x27;[[Scopes]]&#x27;该属性保存的是其上级作用域链 - 当函数执行的时候,进入执行上下文环境,将创建的变量对象添加到&#x27;[[Scopes]]&#x27;数组的第一个位置,形成新的数组 4. 查找变量的规则 - 先在当前作用域的变量对象中查找,找到则使用 - 如果没有则沿着作用域链的数组去上级作用域中的变量对象中查找 - 找到就返回对应的值,如果没有继续向上查找,知道找到最后一个变量对象(全局的变量对象),如果没有则报错变量的查找:代码编写的时候确定了当前全局作用域及局部作用域在代码马上执行,还没执行,执行上下文环境就出现了,函数调用完毕后,局部执行上下文没了,整个代码结束,全局的执行上下文环境也没了全局作用域----&gt;预解析---&gt;全局执行上下文环境---&gt;全局的变量对象&#123;var ,function ,函数参数,this的指向&#125;-----&gt;函数定义----&gt;局部作用域----&gt;出现了函数调用-----&gt;局部局解析---&gt;局部的执行上下文环境----&gt;局部的变量对象&#123;var ,function ,函数参数,this的指向&#125; 7. 闭包- 理解: - 当嵌套的内部函数引用了外部函数的变量时就产生了闭包(执行外部函数,不一定就会产生闭包) - 什么时候产生的闭包? 执行内部函数定义(创建内部函数对象)后 - 通过chrome工具得知: 闭包本质是内部函数中的一个对象(非js的容器), 这个容器中包含引用的变量 1. 闭包内部包含了被引用变量(函数)的对象 2. 说白了,闭包其实就是一种引用关系,引用关系存在于内部函数中,引用的是外部函数的变量的对象(深入理解) 2. 函数内部本身是个局部作用域,如果出现闭包,延长了局部作用域的生命周期 3. 闭包延长局部变量的生命周期后,如果不及时释放会出现内存泄漏 4. 闭包作用: - 闭包的作用:延长外部函数变量对象的生命周期 - 让函数外部可以操作(读写)函数内部的数据(变量/函数) 5. 闭包什么产生的? - 闭包在嵌套内部函数定义执行完成时就产生了(不是调用) 6. 闭包什么时候挂的? - 在嵌套的内部函数成为垃圾对象的时候 7. 闭包的优点/缺点及如何清除闭包 - 优点/缺点: 延长外部函数变量对象的生命周期(不及时清除容易造成内存溢出、泄漏) - 释放闭包: 让内部函数对象成为垃圾对象, 断开指向它的所有引用 注意问题:函数中定义函数,内部函数没有调用,则不会出现在局部执行上下文的变量对象中 ​​​ 123456789101112131415161718192021222324function fn1() &#123; var a = 2; function fn2() &#123; a++; console.log(a); &#125; return fn2;&#125;// 此时fn2释放了没有呢?var f = fn1();// 产生一个闭包f();// 产生一个闭包f();var f2 = ff = nullfunction showDedelay (time, msg) &#123; setTimeout(() =&gt; &#123; alert(msg) &#125;, time)&#125;showDelay(1000) 闭包什么时候产生的? 执行函数定义产生引用变量的的时候产生闭包 下面的没有产生闭包(没有产生内部函数引用变量,函数引用变量是执行函数定义才能有该应用变量,fn2就是内部引用变量) 闭包的应用: 举删除删除列表中的的某个商品的例子(带确定框) 内存溢出和内存泄漏 1. 内存泄露 ：是指程序在申请内存后，无法释放已申请的内存空间就造成了内存泄漏，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 2. 内存溢出： 指程序申请内存时，没有足够的内存供申请者使用，或者说，一个杯子里你非要装一桶的水，那么结果就是内存不够用，即所谓的内存溢出，简单来说就是自己所需要使用的空间比我们拥有的内存大内存不够使用所造成的内存溢出。 this在不同场景下的取值? this学习的2个目标: 能判断出函数中的this是谁 能控制函数的this是需要的特定对象 常规情况下, 函数中的this取决于执行函数的方式 fn(): 直接调用 ==&gt; this是? window new fn(): new调用 ==&gt; this是? 新建的对象 obj.fn(): 通过对象调用 ==&gt; this是? obj obj.fn()() fn.call/apply(obj): 通过函数对象的call/apply来调用 ==&gt; this是? obj (调用fn这个函数,指定或绑定了内部的this为obj) 特殊情况: bind(obj)返回的函数 ==&gt; this是? obj 箭头函数 ==&gt; this是? 外部作用域的this 回调函数 定时器/ajax/promise/数组遍历相关方法回调 ==&gt; this是? window(非严格模式,否则都是undefined) vue控制的回调函数 ==&gt; this是? 组件的实例 React控制的生命周期回调, 事件监听回调 ==&gt; this是? 组件对象 / undefined 如何控制函数的this? 利用函数的bind() 利用箭头函数 也可以用外部保存了this的变量 12345678910111213141516171819202122 var m = 1 function f1()&#123; console.log(this.m) return 3 &#125; var obj = &#123;m:2&#125; f1.bind(obj) // 结果? f1() // 结果?? f1.bind(obj)()// 结果??? console.log(f1.bind(obj)()) // 自己实现bind Function.prototype.bind = function (obj) &#123; console.log(&#x27;myBind&#x27;) return () =&gt; &#123; return this.call(obj) &#125; &#125; 12345678910111213var obj2= &#123; test()&#123; const f1=()=&gt;&#123; console.log(&#x27;+++&#x27;,this) // 谁? &#125; f1() const f2 = function()&#123; console.log(&#x27;----&#x27;,this) // 谁? &#125; f2() &#125;&#125;obj2.test() 9. 同步/异步进程: 程序的一次执行,它占有一片独有的内存空间 线程: CPU的基本调度单位,是程序执行的一个完整流程 1. 一个进程中一般至少有一个运行的线程:主线程 2. 一个进程中也可以同时运行多个线程,我们会说程序是多线程的 3. 一个进程中的数据可以供其多个线程直接共享 4. 多个进行质检的数据是不能直接共享的 浏览器运行是单进程还是多进程 1. 有的是单进程的 - firefox - 老版本IE 2. 有的是多进程 - chrome - 新版IE - 新版火狐 3. 如何查看浏览器是否是多进程运行的 - 任务管理器-----&gt;进程 - 都是多线程运行的 浏览器内核 1234567891011121. 支持浏览器运行的核心的程序2. 不同的浏览器内核不太一样 - IE浏览器内核：Trident内核，也是俗称的IE内核； - Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核； - Firefox浏览器内核：Gecko内核，俗称Firefox内核； - Safari浏览器内核：Webkit内核； - Opera浏览器内核：最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核； - 360浏览器、猎豹浏览器内核：IE+Chrome双内核； - 搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）； - 百度浏览器、世界之窗内核：IE内核； - 2345浏览器内核：好像以前是IE内核，现在也是IE+Chrome双内核了； - UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident，还有说是基于火狐内核。。 js是单线程的 1234567891011121. 如何证明JS执行是单线程的 - setImteout()的回调函数是在主线程执行的 - 定时器回调函数只有在运行栈中的代码全部执行完毕后才有可能执行2. 为什么JS要用单线程模式，而不是多线程模式 - JS的单线程与它的用途 - 作为浏览器脚本语言,JS的主要用途是与用户互动,以及操作DOM - 这决定了它只能是单线程,否则会带来很复杂的同步问题 - 同步会阻塞代码执行 - 异步不会阻塞代码执行 JS是单线程编程语言, 只能同时做一件事(普通人-&gt;单线程,影分身–&gt;多线程) 12345678910111213141516171819202122// 同步回调 [1, 2, 3].forEach(item =&gt; &#123; console.log(item) &#125;) console.log(&#x27;forEach()之后&#x27;) new Promise((resolve, reject) =&gt; &#123; // excutor 执行器函数,作用:执行异步代码 console.log(&#x27;执行excutor&#x27;) // 执行异步任务 &#125;) console.log(&#x27;new Promise()之后&#x27;) // 异步回调,宏任务 setTimeout(() =&gt; &#123; console.log(&#x27;执行timout回调&#x27;) &#125;, 0); console.log(&#x27;setTimeout()之后&#x27;)// 微任务 Promise.resolve(1).then(() =&gt; &#123; console.log(&#x27;promise成功的回调&#x27;) &#125;) console.log(&#x27;.then之后&#x27;) js引擎是在一个线程(可以称为JS线程)上解析执行js代码的(web worker除外), 无论是同步代码还是异步代码 界面第一次渲染: 初始化同步代码 ==&gt; 所有的微任务==&gt; 渲染界面==&gt; 执行第一个宏任务 ​ ==&gt; 所有的微任务==&gt; 渲染界面==&gt; 执行第一个宏任务 界面更新渲染: 所有的微任务==&gt; 渲染界面==&gt; 执行第一个宏任务总结: 清空微队列中所有微任务 ==&gt; 渲染界(UI线程) ==&gt; 执行宏队列中的第一个宏任务 浏览器在另一个线程(GUI渲染线程)进行页面渲染操作, GUI渲染线程与js线程是互斥(不会同时执行), 因为 JS 可以修改 DOM 结构 遇到需要等待 (网络请求, 定时任务) 不能卡住，需要异步 回调callback函数 浏览器多线程演示 12345678910111213141516171819202122232425262728293031&lt;ul&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;/ul&gt; &lt;button id=&quot;test&quot;&gt;test&lt;/button&gt; &lt;div id=&quot;content&quot;&gt; aaaaaaa &lt;/div&gt; &lt;script&gt; Promise.resolve().then(() =&gt; &#123; // 微任务 alert(&#x27;promise1&#x27;) // 页面渲染了吗? &#125;) Promise.resolve().then(() =&gt; &#123; // 微任务 alert(&#x27;promise2&#x27;) // 页面渲染了吗? &#125;) setTimeout(() =&gt; &#123;// 宏任务 alert(document.getElementById(&#x27;content&#x27;).innerHTML) // 页面渲染了吗? &#125;, 0) document.getElementById(&#x27;test&#x27;).onclick = () =&gt; &#123;// 宏任务 document.getElementById(&#x27;content&#x27;).innerHTML = &#x27;xxxx&#x27; // dom渲染 setTimeout(() =&gt; &#123;// 宏任务 alert(document.getElementById(&#x27;content&#x27;).innerHTML) // 页面更新渲染了吗? &#125;, 0); Promise.resolve().then(() =&gt; &#123; // 微任务 alert(&#x27;promise3&#x27;) //页面更新渲染了吗? &#125;) &#125; alert(&#x27;1111&#x27;) // 页面渲染了吗? &lt;/script&gt; 使用Promise解决回调地狱问题(可阅读性很差,仍然要用回调,但是没有嵌套了) Promise相对纯回调形式, 指定回调函数的时机更灵活(可以在发送请求后或请求结束后) ​ 10. 事件轮询机制event loop1(异步实现的原理统称:事件循环(轮询机制))​ JS是通过事件循环机制来实现JS的单线程异步 js确实是单线程的,也确实可以异步执行函数,之所以能做到(浏览器中有辅助它单线程异步执行的分线程管理模块) js是单线程运行的 异步要基于回调来实现 event loop 就是异步回调的实现原理 ![](004.从零开始复习前端–JavaScript.assets/event loop(只有宏任务).png) 事件循环机制的2个重要部分 ​ 在分线程执行的管理模块: 定时器/ajax/dom事件 ​ 保存待执行的回调函数的事件队列(Event queue)/任务队列(Task queue) 事件轮询的执行过程:首先执行初始化代码,就是先执行同步代码,执行同步代码的时候,有可能启动定时器,有可能发送ajax请求,有可能绑定事件监听,执行这些代码的时候,会把回调函数交给对应的管理模块进行管理,而对应的管理模块在分线程执行,不会影响js执行,js会继续向下执行,比如启动一个setTimeout定时器(有个定时器的管理模块),假设1秒后执行,就会在1秒后把回调放在待执行的回调队列里,此时js有可能还在执行初始化代码,只有初始化代码全部的执行完毕后,一个一个,依次的取出执行 宏任务与微任务(任务就是回调,任务的本质就是回调) 宏任务: setTimeout, setInterval, Ajax, DOM事件监听 微任务: Promise, async/await, mutationobserver(H5)(用来监视标签的变化的,标签只要有任何的变化,对应的回调就会微任务异步执行) 宏队列与微队列(队列本质就是数组) 宏队列: 用来保存n个宏任务的队列容器 微队列: 用来保存n个微任务的队列容器 event loop2 js-web中的dom事件回调, 定时器回调与ajax回调异步执行, 都是基于event loop ===&gt; 宏任务 H5新的MutationObserver也基于event loop ==&gt; 微任务 promise成功和失败的回调也是异步执行的, 也是基于event loop ==&gt; 微任务 执行顺序: 第一步: 先执行script下的所有同步代码 第二步: 再依次取出微列中的所有微任务执行 第三步: 再取出宏队列中第一个宏任务执行 再循环第二步与第三步 ![](004.从零开始复习前端–JavaScript.assets/event loop(宏任务与微任务).png) 12345678910111213定时器注意:1. 千万不要在定时器后面放大量的代码块(会阻塞定时器,导致定时器不准确的)2. 定时器模块何时开始计时: - 开定时器的时候交给定时器管理模块就执行 H5规范提供了js分线程的实现,取名:Web Workers(了解)1. Worker:构造函数,加载分线程执行的js文件2. Worker.prototype.onmessage:用于接收另一个线程的回调函数3. Worker.prototype.postMessage:向另一个线程发送消息4. 不足 - Worker 内代码不能操作DOM(更新UI) - 不能跨域加载JS - 不是每个浏览器都支持这个新特性 11. Promise ES6推出的新的更好的异步编程解决方案(相对于纯回调的方式) 可以异步操作启动后或完成后, 再指定回调函数得到异步结果数据 解决嵌套回调的回调地狱问题 —promise链式调用 promise对象有3种状态 pending resolved/fulfilled rejected promise状态的2种变化 pending –&gt; resolved pending –&gt; rejected 注意: 变化是不可逆 4..promise的then()的理解 then()总是返回一个新的promise 新promise的结果状态由then指定的回调函数执行的结果决定 抛出错误 返回失败的promise 返回成功的promise 返回其它任何值 12345678910111213141516171819202122232425262728293031323334353637 /* .then()返回的promise的结果状态由什么决定? 简单说: 由.then()指定并执行的回调函数的执行结果决定 详细说: 什么情况导致promise是失败的? 执行出错(抛异常了), 失败的reason就是抛出的错误 返回一个失败的promise, 失败的reason就是返回的promise的reason 什么情况导致promise是成功的? 返回一个成功的promise, 成功的value就是返回promise的value 返回一个非promise任务值, 也可以不返回(返回undefined), 成功的value就是返回值 */new Promise((resolve, reject) =&gt; &#123; // 成功 // resolve(1) // 失败 reject(2) &#125;).then( value =&gt; &#123; console.log(&#x27;onResolved1&#x27;, value) &#125;, // onResolved reason =&gt; &#123; console.log(&#x27;onRejected1&#x27;, reason) // 抛出错误 // throw 100 // 返回一个失败的promise // return Promise.reject(200) // 返回一个成功的promise // return Promise.resolve(300) // 返回一个其他的值 // return 1000 Promise.resolve(2000) &#125; ).then(value=&gt;&#123; console.log(&#x27;onResolved1&#x27;, value) &#125;,reason=&gt;&#123; console.log(&#x27;onRejected2&#x27;, reason) &#125;) 12345678910111213141516171819202122232425262728293031 5.Promise.all([promise1, promise2, promise3]) - 批量/一次性发送多个异步请求 - 当都成功时, 返回的promise才成功 - 一旦有一个失败的, 返回的promise就失败了 问题: 发3请求成功后再4个请求 ```js function ajax(url) &#123; return axios.get(url) &#125; const p1 = ajax(url1) const p2 = ajax(url2) const p3 = ajax(url3) Promise.all([p1, p2, p3])// values和数组中数据的顺序有关系 .then(values =&gt; &#123; return ajax(url4) &#125;) .then(value =&gt; &#123; console.log(value) // 就是第4个请求成功的value &#125;) .catch(error =&gt; &#123; &#125;) 6.async/await与promise的关系 async/await是消灭异步回调的终极武器 作用: 简化promise对象的使用, 不用再使用then/catch来指定回调函数 但和Promise并不互斥 反而, 两者相辅相成 执行async函数, 返回promise对象 await相当于promise的then try…catch可捕获异常, 相当于promise的catch 1234567891011121314151617181920212223242526272829303132333435// function ajax(url) &#123; // return axios.get(url)// &#125; // async function getProduct() &#123; // try &#123; // const response = await ajax(&#x27;/product2.json&#x27;) // return response.data // &#125; catch (error) &#123; // console.log(&#x27;请求出错&#x27;, error.message) // // throw error // return Promise.reject(error) // &#125; // &#125; // // 等同于上面async&amp;await的函数 // function getProduct() &#123; // return ajax(&#x27;/product.json&#x27;) // .then(response =&gt; &#123; // return response.data // &#125;) // .catch(error =&gt; &#123; // console.log(&#x27;请求出错&#x27;, error.message) // // throw error // return Promise.reject(error) // &#125;) // &#125; // function test() &#123; // getProduct().then(value =&gt; &#123; // console.log(value) // &#125;).catch(error =&gt; &#123; // console.log(&#x27;error&#x27;, error.message) // &#125;) // &#125; // test() 1234 ##12.ES6 ECMA组织:欧洲计算机制造商协会,制定和发布的脚本语言规范 ECMAscript是基于Netscape javaScript的一种标准脚本语言。 JavaScript包含3个部分:1)ECMAScript核心(JS标准语法)2)浏览器端的扩展 BOM(浏览器对象模型) DOM(文档对象模型)3)服务器端的扩展 Node.js ES的几个重要版本ES5:09年发布ES6:15年发布,也叫ECMA2015ES7:16年发布,也叫ECMA2016 ES5给Object扩展了一些静态方法,常用的2个: Object.create(prototype,[descriptors]) 创建对象并继承 作用: 以指定对象为原型创建新的对象 为新的对象指定新的属性,并对属性进行描述 value: 指定的值 weitable:标识当前属性值是否是可修改的,默认为false configurable:标识当前属性是否可以被删除,默认是false enumberable: 标识当前属性是否能用for in 枚举,默认为false for-in(性能问题)不仅枚举自身属性,也可以枚举原型对象上的属性,一般配合对象.hasOwnProperty()方法 12345678910var person = &#123;name: &#x27;小明&#x27;,sayHi: function () &#123; console.log(&#x27;您好&#x27;) &#125;&#125;// 新创建的stu对象和person对象是继承关系var stu = Object.create(person) // stu.__proto__----&gt;personconsole.log(stu.name)stu.sayHi() Objectt.defineProperties(object, descriptors) 作用:为指定对象定义扩展多个属性 get: 用来获取当前属性值的回调函数 set: 修改当前属性值的触发的回调函数,并且实参为修改后的值 存储器属性: settter,getter一个用来存值,一个用来取值 对象本身有两个方法 get propertyName(){} 用来得到当前属性值的回调函数 set propertyName(){} 用来监视当前属性值变化的回调函 Array的方法扩展 123451. Array.prototype.indexOf(value):得到数组中的某个数据的第一个下标,用来找数据的2. Array.prototype.lastIndexOf(value):得到数组中某个数据的最后一个小标3. Array.prototype.forEach(function(item,index)&#123;&#125;):遍历数组4. Array.prototype.map(function(item,index)&#123;&#125;):遍历数组,返回新数组5. Array.prototype.filter(function(item,index)&#123;&#125;):遍历数组,过滤后的数组 ES6+ 箭头函数 作用: 定义匿名函数 基本语法: ()=&gt;{console.log(‘xxxx’)} 一个参数: msg=&gt; msg+2 多个参数: (m,n)=&gt;m+n 函数体不用大括号:默认有返回结果 函数体如果有多个语句,需要使用{}包裹,如果内部有需要返回的值,则手动return 使用场景: 多用来定义回调函数 箭头函数的特定: 简洁 箭头函数没有自己的this,箭头函数的this不是调用的时候决定的,而是在定义的时候处在自己对象就是它的this 扩展理解: 箭头函数的this看外层的是否有函数,如果有,外层函数的this就是内部箭头函数的this,如果没有则this是window 7.三点运算符: 拆包和打包 8.形参默认值: 简化函数的形参语法 9.Symbol: 1. ES5中对象的属性名都是字符串,容易造承重名,污染环境 2. 概念:ES6中的添加了一种原始数据类型Symbol(已有的原始数据类型:String,Number,Boolean,null,undefined,对象) 3. 特点: - Symbol 属性对应的值是唯一的,解决命名冲突问题 - Symbol 值不能与其他数据进行计算,包括同字符串拼串 - for in , for of 遍历时不会遍历symbol 属性 4. 使用: - 调用Symbol 函数得到symbol 值 - let symbol =Symbol() - let obj =&#123;&#125; - obj[symbol]=&#39;hello&#39;; 5. 传参标识 - let symbol = Symbol(&#39;one&#39;) - let symbol2 = Symbol(&#39;two&#39;) - console.log(symbol) // Symbol(&#39;one&#39;) - console.log(symbol2) // Symbol(&#39;two&#39;) 6. 定义常量标识 - 可以定义常量,就是标识 - const person_key = Symbol(&#39;person_key&#39;) - console.log(person_key) 7. 内置Symbol值 - 除了定义自己使用的Symbol值以外,ES6还提供了11个内置的Symbol值,指向语言内部使用的方法 - Symbol.iterator - 对象的Symbol.iterator属性,指向该对象的默认遍历器方法(很快就讲了) 10.iterator 是一种接口机制,为各种不同的数据结构提供统一的访问机制 1. 作用: - 为各种数据结构,提供一个统一的，简便的访问接口 - 使得数据结构的成员能够按某种次序排列 - ES6创造了一种新的遍历命令,for..of循环,Iterator接口主要提供for...of消费 2. 工作原理 - 创建一个指针对象(遍历器对象),指向数据结构的起始位置 - 第一次调用next方法,指针自动指向数据结构的第一个成员 - 接下来不断调用next方法,指针会一直往后移动,知道指向最后一个成员 - 每调用next方法返回的是一个包含value和done的对象,&#123;value:当前成员的值,done:布尔值&#125; - value表示当前成员的值,done对应的布尔值表示当前的数据的结构是否遍历结束 - 当遍历结束的时候返回的value值是undefine,done值为false - 原生具备iterator接口的数据(可用for of遍历) - 扩展理解: - 当数据结构上部署了Symbol.iterator接口,该数据可以用for-of遍历 - 当使用for of去遍历目标数据的时候,该数据会自动去找Symbol.iterator - Symbol.iterator属性指向对象的默认遍历器方法(iterator接口) - Array - arguments - set容器 - map容器 - String .... 123456789101112131415161718192021// 模拟遍历器对象(指针对象)function myIterator(arr) &#123; // iterator接口 let nextIndex = 0 // 默认第一次记录指针的位置 return &#123; // 遍历器对象 next: function () &#123; return nextIndex &lt; arr.length ? &#123; value: arr[nextIndex++], done: false &#125; : &#123; value: undefined, done: true &#125; &#125; &#125;&#125;let arr = [1, 2, 3, 4, 5]let interatorObj = myIterator(arr)console.log(interatorObj.next())console.log(interatorObj.next())console.log(interatorObj.next())console.log(interatorObj.next())console.log(interatorObj.next())console.log(interatorObj.next()) 11.Generator函数 1. 概念: - ES6提供的解决异步编程的方案之一 - Generator函数是一个状态,内部封装了不同状态数据 - 用来生成遍历对象 - 可暂停函数(惰性求值),yield可暂停,next方法可启动,每次返回的是yield后的表达式结果 2. 特点: - function 与函数名之间有一个星号 - 内部用yield表达式来定义不同的状态 - 例如: function * generatorExample()&#123; let result = yield &#39;hello&#39;; // 状态值为hello yield &#39;generator&#39;; // 状态值为generator &#125; - generator函数返回的是指针对象(接iterator),而不会执行函数内部逻辑 - 调用next方法函数内部逻辑开始执行,遇到yield表达式停止,返回&#123;value:yield后的表达式结果/undefined,done:true&#125; - 再次调用next方法会从上一次停止时的yield处开始,直到最后 - yield语句返回结果通常为undefine,当调用next方法时传参内容会作为启动时yield语句的返回值 1234567891011121314151617181920// 需求,先做第一件事,然后做第二件事,最后最第三件事 function* generator()&#123; setTimeout(function()&#123; console.log(&#x27;第一件是做完了&#x27;) iterator.next(&#x27;aaaa&#x27;) &#125;,1000); let result=yield; console.log(result) setTimeout(function()&#123; console.log(&#x27;第二件是做完了&#x27;) iterator.next(&#x27;bbbb&#x27;) &#125;,2000); let result2=yield; console.log(result2) setTimeout(function()&#123; console.log(&#x27;第三件是做完了&#x27;) &#125;,3000); &#125; let iterator = generator() iterator.next() 12.async 函数是generator函数的语法糖 1. 概念: 真正意义上去解决异步回调问题,同步流程表达异步操作 2. 本质: Generator的语法糖 3. 语法: - async function foo()&#123; await 异步操作; await 异步操作; &#125; 4. 特点: - 不需要像Generator去调用next方法,遇到await等待,当恰你的异步操作完成就往下执行 - 返回的总是Promise对象,可以用then方法进行下一步操作 - async 取代Generator函数的星号*,await 取代Generator的yield - 语义上更为明确,使用简单,经临床验证,暂时没有副作用及不良反应 1. await 是暂停,但是必须跟着promise对象才会暂停,其他的都不暂停 1234567891011121314151617// async 函数 async function f1() &#123; console.log(&#x27;函数开始执行&#x27;) await setTimeout(function()&#123; console.log(&#x27;定时器&#x27;) &#125;,2000); console.log(&#x27;函数执行中&#x27;) await 456; console.log(&#x27;函数执行结束&#x27;) &#125; f1() // 只有在await后面有promise才会暂停,如果要继续执行,修改promise对象的状态(暂停到promise对象状态为成功的情况,如果是失败状态,则直接报错) // resolve(value) value就会作为await的返回值返回 // async 函数调用返回的是Promise对象 // 默认是peding状态 // 当async 函数所有代码全部执行完毕,并且没有出错,此时就会变成成功状态 // 当async 函数代码出错了,就会变成失败状态 12.字符串扩展 1. includes(str) 判断是否包含指定的字符串 2. startsWith(str) 判断是否以指定字符串开头 3. endsWith(str) 判断是否以指定字符串结尾 4. repeat(count) 重复指定的次数 13.二进制与八进制数值表示法:二进制用0b,八进制用0o 1. Number.isFinite(i) 判断是否是有限大的数 2. Number.isNaN(i) 判断是否是NaN 3. Number.isInteger(i) 判断是否是整数 4. Number.parseInt(str) 将字符串转换为对应的数值 5. Math.trunc(i) 直接去除小数部分 14.数组扩展 1. Array.form(伪数组) 伪数组转真数组 2. Array.of(val1,val2,val3)将一些列数值转换为数组 3. find(回调) 找出第一个满足条件的元素 4. findIndex(回调) 找出第一个满足条件的元素的下标 15.对象扩展 1. Object.is(v1,v2) 2. Object.assign(target,obj1,obj2) 将对象的属性复制到目标对象上 3. 直接操作__proto__属性 - let obj2=&#123;&#125; - obj2.__proto__=obj1 16.拷贝数据 1. 基本数据类型 - 拷贝后悔生成一份新的数据,修改拷贝以后的数据不会影响原数据 2. 对象/数组 - 拷贝后不会生成新的数据,而是拷贝的是引用,修改拷贝以后的数据会影响原来的数据 3. 拷贝数据的方法: - 直接赋值给一个变量 浅拷贝 - Object.assgin() 浅拷贝 - Array.prototype.concat() 浅拷贝 - Array.pototype.slice() 浅拷贝 - JSON.parse(JSON.stringify()) 深拷贝(深度克隆),拷贝的数据里不能有函数,处理不了 4. 浅拷贝(对象/数组) - 特点: 拷贝引用,修改拷贝以后的数据会影响原数据 5. 深拷贝(深度克隆) - 特点: 拷贝的时候生成新数据,修改拷贝以后的数据不会影响原数据 - 深度克隆会进行深度的遍历(会用到递归) - 需要进行类型的检测 : typeof 返回数据类型:String,Number,Boolean,Undefined,Object,Function - Object.prototype.toString.call(obj) 返回的是该对象到底是什么类型 - console.log(Object.prototype.toString.call(result)) - 截取获取的真正的数据类型 - console.log(Object.prototype.toString.call(result).slice(8, -1)) - for-in循环 对象(属性名) 数组(下标) 17.Set容器:无序不可重复的多个值的集合体 1. Set() 2. Set(array) 3. add(value) 4. delete(value) 5. has(value) 6. clear() 7. size 18.Map容器: 无序的key不重复的多个key-value的集合体 1. Map() 2. Map(array) 3. set(key,value) 添加 4. get(key) 5. delete(key) 6. has(key) 7. clear() 8. size 19.for-of循环可以遍历下面内容: 1. 遍历数组 2. 遍历Set 3. 遍历Map 4. 遍历字符串 5. 遍历伪数组 20.ES7 Array.prototype.includes() 判断数组中是否包含指定的value 指数运算符(幂): ** 21.ES8 Object.values(对象) 获取对象中所有的属性的值 Object.entries(对象) 把对象转数组 22.ES9 Promise.finally let promise = new Promise((resolve,reject)=&gt;&#123; console.log(&#39;开始执行&#39;) resolve(&#39;111&#39;) console.log(&#39;结束执行&#39;) &#125;) promise.then((data)=&gt;&#123; console.log(&#39;成功:&#39;+data) &#125;).catch((errorMsg)=&gt;&#123; console.log(&#39;报错啦:&#39;+errorMsg) &#125;).finally(()=&gt;&#123; console.log(&#39;成功失败都会执行的&#39;) &#125;) 23.总结ES6+面试题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109ES6+常用语法列出整体ES6+新语法列表说明: 跟面试官交流ES6, 先快速说出这套列表, 再选择几个常用的/有些难度的/有说头的说, 或者看面试官关注哪方面的1. const与let2. 解构赋值==================1. 字符串的扩展2. 数值的扩展3. 函数的扩展4. 数组的扩展5. 对象的扩展====================6. 类语法7. 模块化语法8. 异步语法9. 新容器语法10. 代理(Proxy)与反射(Reflect)语法===================================const与let- const定义常量, let定义变量- 相对于var - 有块作用域 - 没有变量提升 - 不会添加到window上 - 不能重复声明==============================解构赋值- 解构对象: const &#123;id, name&#125; = this.product- 解构数组: const [count, setCount] = useState() - 形参解构: add (&#123; id, title &#125;) &#123;&#125;- 引入模块解构: import &#123; getProductList &#125; from &#x27;@/api&#x27;===================================字符串的扩展- 模板字符串: 我是$&#123;name&#125;, 今年$&#123;age&#125;- 方法: includes() / startsWith() / endswith()数值的扩展- 完善二进制(0b)与八进制(0o)表示- 给Math添加方法: parseInt()与parseFloat() (原本window上有)- 指数计算: **函数的扩展- 箭头函数 - 没有自己的this, 使用外部作用域中的this, 不能通过bind来绑定this - 不能通过new来创建实例对象 - 内部没有arguments, 可以通过rest参数来代替- 形参默认值: fn (a=2, b=&#123;&#125;) &#123;&#125;- rest参数: fn (a, ...args) &#123;&#125; / fn (a, ...args) &#123;&#125; fn(1, 2, 3, 4)数组的扩展- 扩展运算符 - 浅拷贝数组: const arr2 = [...arr] - 合并多个数组: const arr3 = [...arr1, ...arr2]- 静态方法 - Array.from(): 将类数组对象和可遍历对象转为真数组 - Array.from(new Set(arr)) - [...new Set(arr)] - Array.of(1, 2, 3): 将一组值，转换为数组- 实例方法 - find() / findIndex(): 查找匹配的元素或下标 - arr.flat(): 将多维数组转为一维数组(也称为: 数组扁平化)对象的扩展- 扩展运算符 - 浅拷贝对象: const obj2 = &#123;...obj1&#125; - 合并多个对象: const obj3 = &#123;...obj1, ...obj2&#125;- 属性/方法的简洁写法: &#123;name, getName () &#123;&#125;&#125;- 遍历内部属性 - for..of: 遍历对象及其原型链上所有属性 - Object.keys(obj): 得到对象自身可遍历的所有属性名的数组- 静态方法: - Object.is(value1, value2): 判断2个值是否完全一样 - Object.assign(target, ...sources): 将后面任意多个对象合并到target对象上 类语法- class- extends- constructor- super() / super.xxx()- static模块化语法- export - export default value- import: 静态导入, 合并一起打包- import(): 动态导入, 拆分打包, 用于懒加载 const Home = () =&gt; import(&#x27;./views/Home.vue&#x27;) import(&#x27;./views/Home.vue&#x27;).then((module) =&gt; &#123; // 使用module块 module.default module.xxx &#125;)异步语法- Promise- async 函数- await 表达式新容器语法- Map- Set代理(Proxy)与反射(Reflect)语法- Proxy- Reflect面试可说的: ES6常用语法- const与let- 箭头函数- 解构赋值- 形参默认值- rest/剩余参数- 类语法: class / extends / constructor / static /super- 扩展运算符: ...- 模板字符串- 异步语法: promise / async &amp; await- 对象的属性与方法简写- set / map- 模块化语法: export / default / import / import() JS其他内容事件冒泡与事件委托1) 事件冒泡的流程 基于DOM树形结构 事件在目标元素上处理后, 会由内向外(上)逐层传递 应用场景: 事件代理/委托/委派 2) 事件委托 减少内存占用(事件监听回调从n变为1) 动态添加的内部元素也能响应 不要滥用 3) 封装一个绑带事件监听的函数(有难度)1234567891011121314151617181920212223242526272829303132333435363738/* 绑定事件监听的通用函数(不带委托)*/function bindEvent1 (ele, type, fn) &#123; ele.addEventListener(type, fn)&#125;/* 绑定事件监听的通用函数(带委托)*/function bindEvent2(ele, type, fn, selector) &#123; ele.addEventListener(type, event =&gt; &#123; // 得到发生事件的目标 const target = event.target if (selector) &#123; // 如果元素被指定的选择器字符串选择, 返回true; 否则返回false。 if (target.matches(selector)) &#123; // 委托绑定调用 fn.call(target, event) &#125; &#125; else &#123; // 普通绑定调用 fn.call(ele, event) // fn(event) // this不对 &#125; &#125;)&#125;&lt;ul&gt; &lt;span&gt; &lt;li&gt; &lt;li&gt;&lt;/ul&gt; bindEvent2(ul, &#x27;click&#x27;, (event) =&gt; &#123;&#125;, &#x27;li&#x27;)bindEvent2(ul, &#x27;click&#x27;, (event) =&gt; &#123;&#125;) ajaxxhr.status 2XX: 表示成功处理请求, 如200, 201 3XX: 需要生定向, 浏览器直接跳转, 如302 4XX: 客户端请求错误, 如: 401, 404 5XX: 服务器端错误, 如: 500 区别ajax请求与一般HTTP请求 ajax请求是一种特别的http请求 对服务器端来说, 没有任何区别, 区别在浏览器端 浏览器端发请求: 只有XHR或fetch发出的才是ajax请求, 其它所有的都是非ajax请求 浏览器端接收到响应 一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面 ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据 封装一个简易的ajax异步请求函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* xhr + promise 封装一个异步ajax请求的通用函数 简洁版*/function ajax(url) &#123; return new Promise((resolve, reject) =&gt; &#123; // 创建一个XHR对象 const xhr = new XMLHttpRequest() // 初始化一个异步请求(还没发请求) xhr.open(&#x27;GET&#x27;, url, true) xhr.onreadystatechange = function () &#123; /* ajax引擎得到响应数据后 将xhr的readyState属性指定为4 将响应数据保存在response / responseText属性上 调用此回调函数 */ // 如果状态值不为4, 直接结束(请求还没有结束) if (xhr.readyState !== 4) &#123; return &#125; // 如果响应码在200~~299之间, 说明请求都是成功的 if (xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) &#123; // 指定promise成功及结果值 resolve(JSON.parse(xhr.responseText)) &#125; else &#123; // 请求失败了 // 指定promise失败及结果值 reject(new Error(&#x27;request error staus &#x27;+ request.status)) &#125; &#125; xhr.send(null) &#125;)&#125;/* xhr + promise 封装一个异步ajax请求的通用函数 加强版 返回值: promise 参数为配置对象 url: 请求地址 params: 包含所有query请求参数的对象 data: 包含所有请求体参数数据的对象 method: 为请求方式*/function axios(&#123;url, params=&#123;&#125;, data=&#123;&#125;, method=&#x27;GET&#x27;&#125;) &#123; // 返回一个promise对象 return new Promise((resolve, reject) =&gt; &#123; // 创建一个XHR对象 const request = new XMLHttpRequest() // 根据params拼接query参数 let queryStr = Object.keys(params).reduce((pre, key) =&gt; &#123; pre += `&amp;$&#123;key&#125;=$&#123;params[key]&#125;` return pre &#125;, &#x27;&#x27;) if (queryStr.length&gt;0) &#123; queryStr = queryStr.substring(1) url += &#x27;?&#x27; + queryStr &#125; // 请求方式转换为大写 method = method.toUpperCase() // 初始化一个异步请求(还没发请求) request.open(method, url, true) // 绑定请求状态改变的监听 request.onreadystatechange = function () &#123; // 如果状态值不为4, 直接结束(请求还没有结束) if (request.readyState !== 4) &#123; return &#125; // 如果响应码在200~~299之间, 说明请求都是成功的 if (request.status&gt;=200 &amp;&amp; request.status&lt;300) &#123; // 准备响应数据对象 const responseData = &#123; data: JSON.parse(request.response), status: request.status, statusText: request.statusText &#125; // 指定promise成功及结果值 resolve(responseData) &#125; else &#123; // 请求失败了 // 指定promise失败及结果值 const error = new Error(&#x27;request error staus &#x27;+ request.status) reject(error) &#125; &#125; // 如果是post/put请求 if (method===&#x27;POST&#x27; || method===&#x27;PUT&#x27; || method===&#x27;DELETE&#x27;) &#123; // 设置请求头: 使请求体参数以json形式传递 request.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json;charset=utf-8&#x27;) // 包含所有请求参数的对象转换为json格式 const dataJson = JSON.stringify(data) // 发送请求, 指定请求体数据 request.send(dataJson) &#125; else &#123;// GET请求 // 发送请求 request.send(null) &#125; &#125;)&#125; 跨域 什么是跨域(同源策略) JSONP CORS 代理服务器 同源策略 同源: 协议, 域名, 端口, 三者都相同 ajax请求时, 浏览器要求当前网页和Server必须同源(安全), 否则会抛出跨域的错误 加载image/link/script不受同源策略限制 JSONP原理 前台: &lt;script src=&quot;目标url?callback=fn&quot; /&gt; 接收响应数据的函数: function fn (data) {} 后台 处理请求, 产生需要返回的数据data 读取callback请求参数得到前台处理响应数据的函数名fn 返回执行函数fn的js代码: ‘fn &amp;&amp; fn(data)’ 不足 只能处理GET请求 每个请求在后台都要做处理, 麻烦 12345678910111213// 发送jsonp请求的函数function jsonp() &#123; var script = document.createElement(&#x27;script&#x27;) script.type = &#x27;text/javascript&#x27; // 传参并指定回调执行函数为backFn script.src = &#x27;http://localhost:4000/getUserInfo?id=100&amp;callback=fn&#x27; document.body.appendChild(script)&#125;// 回调函数, 接收响应数据function fn(data) &#123; console.log(data)&#125; CORS原理 后台: 返回允许浏览器在某个域上发送跨域请求的相关响应头 123456789101112// 使用cors, 允许跨域, 且允许携带跨域cookieapp.use(function (req, res, next) &#123; // console.log(&#x27;----&#x27;) // 允许跨域的地址 res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://localhost:5500&#x27;) // 不要是* // 允许携带凭证(也就是cookie) res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;) // 允许跨域的请求头 res.set(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;) // 放行 next()&#125;) 前台: 不需要做特别任何处理 12axios.defaults.withCredentials = true // 允许携带cookiexhr.withCredentials = true 代理服务器 开发环境: 利用webpack-dev-server中的http-proxy-middle 进行正向代理 vue脚手架项目 react脚手架项目 自定义webpack配置 直接使用http-proxy-middle配置 生产环境: 利用nigix 进行反向代理 https://www.cnblogs.com/taostaryu/p/10547132.html 使用axios发送ajax请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162axios(url)axios(&#123; method: &#x27;&#x27;, url: &#x27;&#x27;, // 如果有params参数必须拼接在url中 params: &#123;&#125;, // query参数 data: &#123;&#125; // 请求体参数&#125;)axios.get(url, &#123;配置&#125;)axios.post(url, data, &#123;配置&#125;)axios.put(url, data, &#123;配置&#125;)axios.delete(url, &#123;配置&#125;)const service = axios.create(&#123; baseURL: &#x27;&#x27;, timeout: 20000,&#125;)service.interceptors.request.use((config) =&gt; &#123; // 添加请求头 config.headers[&#x27;token&#x27;] = token值 return config // 必须返回config&#125;)xhr.send()service.interceptors.response.use( response =&gt; &#123; // return response return response.data &#125;, error =&gt; &#123; &#125;)service(&#123;&#125;).then(data =&gt; &#123; &#125;)Promise.resolve(config) .then((config) =&gt; &#123; // 请求拦截器的回调 return config &#125;) .then((config) =&gt; &#123; // 用来发ajax的回调 return new Promise((resolve, reject) =&gt; &#123; // 根据config使用xhr发请求 resolve(response) &#125;) &#125;) .then( // 响应拦截器 (response) =&gt; &#123; return response.data &#125;, (error) =&gt; &#123; &#125; ) .then((data) =&gt; &#123; // 最终发具体请求的成功回调 &#125;) axios二次封装 配置通用的基础路径和超时 显示请求进度条 显示进度条: 请求拦截器回调 结束进度条: 响应拦截器回调 成功返回的数据不再是response, 而直接是响应体数据response.data 统一处理请求错误, 具体请求也可以选择处理或不处理 每个请求自动携带userTempId的请求头: 在请求拦截器中实现 如果当前有token, 自动携带token的请求头 对token过期的错误进行处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import axios from &#x27;axios&#x27;import NProgress from &#x27;nprogress&#x27;import &#x27;nprogress/nprogress.css&#x27;import store from &#x27;@/store&#x27;import router from &#x27;@/router&#x27;NProgress.configure(&#123; showSpinner: false &#125;) // 隐藏右侧的旋转进度条// 创建instanceconst instance = axios.create(&#123; // baseURL: &#x27;http://182.92.128.115/api&#x27;, baseURL: &#x27;/api&#x27;, timeout: 20000&#125;)// 指定请求拦截器instance.interceptors.request.use(config =&gt; &#123; // 显示进度条: 请求拦截器回调 NProgress.start() /* 每个请求自动携带userTempId的请求头: 在请求拦截器中实现 */ const userTempId = store.state.user.userTempId config.headers.userTempId = userTempId /* 6. 如果当前有token, 自动携带token的请求头 */ const token = store.state.user.token if (token) &#123; config.headers.token = token &#125; return config // 必须返回config&#125;) // 指定响应拦截器instance.interceptors.response.use( response =&gt; &#123; // 成功的回调 // 结束进度条: 响应拦截器回调 NProgress.done() // 成功返回的数据不再是response, 而直接是响应体数据response.data return response.data &#125;, async error =&gt; &#123; // 失败的回调 // 结束进度条: 响应拦截器回调 NProgress.done() // 统一处理请求错误, 具体请求也可以选择处理或不处理 // alert(&#x27;请求出错: &#x27; + error.message||&#x27;未知错误&#x27;) // 取出响应对象 const &#123; response &#125; = error // 如果是请求处理出错 if (response &amp;&amp; response.status) &#123; // 401说明token非法 if (response.status === 401) &#123; // 如果当前没在登陆页 if (router.currentRoute.path!==&#x27;/login&#x27;) &#123; // 分发action去清除用户token信息 await store.dispatch(&#x27;logout&#x27;) // 跳转到登陆页面 router.replace(&#x27;/login&#x27;) // 提示 message.error(&#x27;登陆已过期, 请重新登陆&#x27;) &#125; &#125; else &#123; message.error(&#x27;请求出错: &#x27; + error.message||&#x27;未知错误&#x27;) &#125; &#125; else if (!response) &#123; // 网络连接不上服务器 message.error(&#x27;您的网络发生异常，无法连接服务器&#x27;) &#125; // throw error return Promise.reject(error) // 将错误向下传递 &#125;)// 向外暴露instanceexport default instance Restless API 与 Restful API Restless API 传统的API, 把每个url当作一个功能操作 /deleteUser 同一个url, 后台只进行CRUD的某一种操作 请求方式不决定请求的CRUD操作 一个请求路径只对应一个操作 一般只有GET/POST Restful API 新式的API, 把每个url当作一个唯一资源 /user/2 同一个url, 可以通过不同类型的请求对后台资源数据进行CRUD四种操作 请求方式来决定了请求在后台进行CRUD的哪种操作 GET: 查询 POST: 添加 PUT: 更新 DELETE: 删除 同一个请求路径可以进行多个操作 请求方式会用到GET/POST/PUT/DELETE 测试: 可以使用json-server快速搭建模拟的rest api 接口 前台数据存储存储方式 cookie sessionStorage localStorage 注意: session后台数据存储 cookie 本身用于浏览器和Server通讯 被 “借用” 到本地存储 可用document.cookie读取或保存 可以利用cookies工具库简化编码 cookie的缺点 存储大小有限, 最大4KB http请求时会自动发送给服务器, 增加了请求的数据量 原生的操作语法不太方便操作cookie 浏览器可以设置禁用 localStoarge与sessionStorage 相同点: 纯浏览器端存储, 大小不受限制, 请求时不会自动携带 只能保存文本, 如果是对象或数组, 需要转换为JSON API相同: setItem(key, value) getItem(key, value) removeitem(key, value) 浏览器不能禁用 不同点: localStorage保存在本地文件中, 除非编码或手动删除, 否则一直存在 sessonStorage数据保存在当前会话内存中, 关闭浏览器则清除 区别cookie 与 localStorage和sessionStorage 容量 请求时是否自动携带 API易用性 浏览器是否可禁用 区别cookie与session cookie保存在浏览器端(前台可以操作) session保存在服务器端(前台不能操作) session依赖于cookie(session的id以cookie的形式保存在浏览器端) 从输入url到渲染出页面的整个过程http://www.baidu.com DNS 解析（查询）：将域名地址解析 ip 地址 浏览器 DNS 缓存 计算机 DNS 缓存 路由器 DNS 缓存 网络运营商 DNS 缓存 递归查询 TCP 链接：TCP 三次握手 ===&gt; 建立连接 客户端发送服务端：我准备好了，请你准备一下 服务端发送客户端：我也准备好了，请你确认一下 客户端发送服务端：确认完毕 发送请求 将请求报文发送过去 返回响应 将响应报文发送过来 解析渲染页面 遇到 HTML，调用 HTML 解析器，解析成 DOM 树 遇到 CSS，调用 CSS 解析器，解析成 CSSOM 树 遇到 JS，调用 JS 解析器（JS 引擎），解析 JS 代码 可能要修改元素节点，重新调用 HTML 解析器，解析更新DOM 树 可能要修改样式节点，重新调用 CSS 解析器，解析更新 CSSOM 树 将 DOM + CSSOM = Render Tree（渲染树） layout 布局：计算元素的位置和大小信息 render 渲染：将颜色/文字/图片等渲染上去 断开链接：TCP 四次挥手 (断开请求链接 2 次, 断开响应链接 2 次) 客户端发送服务端：请求数据发送完毕，可以断开了 服务端发送客户端：请求数据接受完毕，可以断开了 服务端发送客户端：响应数据发送完毕，可以断开了 客户端发送服务端：响应数据接受完毕，可以断开了 手写代码函数的call() / apply() / bind()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 自定义函数对象的call方法*/function call (fn, obj, ...args) &#123; // 如果传入的是null/undefined, this指定为window if (obj===null || obj===undefined) &#123; obj = obj || window &#125; // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象 obj.tempFn = fn // 通过obj调用这个方法 const result = obj.tempFn(...args) // 删除新添加的方法 delete obj.tempFn // 返回函数调用的结果 return result&#125;/* 自定义函数对象的apply方法*/function apply (fn, obj, args) &#123; // 如果传入的是null/undefined, this指定为window if (obj===null || obj===undefined) &#123; obj = obj || window &#125; // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象 obj.tempFn = fn // 通过obj调用这个方法 const result = obj.tempFn(...args) // 删除新添加的方法 delete obj.tempFn // 返回函数调用的结果 return result&#125;/* 自定义函数对象的bind方法 重要技术: 高阶函数 闭包 call() 三点运算符*/function bind (fn, obj, ...args) &#123; if (obj===null || obj===undefined) &#123; obj = obj || window &#125; return function (...args2) &#123; return call(fn, obj, ...args, ...args2) &#125;&#125; 函数的节流(throttle)与防抖(debounce)12345678910111213141516171819202122232425262728293031323334353637/* 实现函数节流的函数*/function throttle(callback, delay) &#123; let start = 0 // 必须保存第一次点击立即调用 return function (event) &#123; // 事件回调函数 // this是发生事件的dom元素 console.log(&#x27;throttle 事件&#x27;) const current = Date.now() if (current - start &gt; delay) &#123; // 从第2次点击开始, 需要间隔时间超过delay callback.call(this, event) // 将当前时间指定为start, ==&gt; 为后面的比较做准备 start = current &#125; &#125;&#125;/* 实现函数防抖的函数*/function debounce(callback, delay) &#123; return function (event) &#123; console.log(&#x27;debounce 事件...&#x27;) // 清除待执行的定时器任务 if (callback.timeoutId) &#123; clearTimeout(callback.timeoutId) &#125; // 每隔delay的时间, 启动一个新的延迟定时器, 去准备调用callback callback.timeoutId = setTimeout(() =&gt; &#123; callback.call(this, event) // 如果定时器回调执行了, 删除标记 delete callback.timeoutId &#125;, delay) &#125;&#125; 数组去重(unique)12345678910111213141516171819202122232425262728293031323334353637383940/*方法1: 利用forEach()和indexOf() 说明: 本质是双重遍历, 效率差些*/function unique1 (array) &#123; const arr = [] array.forEach(item =&gt; &#123; if (arr.indexOf(item)===-1) &#123; // 内部在遍历判断出来的 arr.push(item) &#125; &#125;) return arr&#125;/*方法2: 利用forEach() + 对象容器 说明: 只需一重遍历, 效率高些*/function unique2 (array) &#123; const arr = [] const obj = &#123;&#125; array.forEach(item =&gt; &#123; if (!obj.hasOwnProperty(item)) &#123;// 不用遍历就能判断出是否已经有了 obj[item] = true arr.push(item) &#125; &#125;) return arr&#125;/*方法3: 利用ES6语法 1). from + Set 2). ... + Set 说明: 编码简洁*/function unique3 (array) &#123; // return Array.from(new Set(array)) return [...new Set(array)]&#125; 数组扁平化(flatten)123456789101112131415161718192021222324252627282930/* 数组扁平化: 取出嵌套数组(多维)中的所有元素放到一个新数组(一维)中 如: [1, [3, [2, 4]]] ==&gt; [1, 3, 2, 4]*//*方法一: 递归 + reduce() + concat()*/function flatten1 (array) &#123; return array.reduce((pre, item) =&gt; &#123; if (Array.isArray(item) &amp;&amp; item.some((cItem =&gt; Array.isArray(cItem)))) &#123; return pre.concat(flatten1(item)) &#125; else &#123; return pre.concat(item) &#125; &#125;, [])&#125;/*方法二: ... + some() + concat()*/function flatten2 (array) &#123; let arr = [].concat(...array) while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr) &#125; return arr&#125; 深拷贝123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* 深度克隆1). 大众乞丐版 问题1: 函数属性会丢失 问题2: 循环引用会出错2). 面试基础版本 解决问题1: 函数属性还没丢失3). 面试加强版本 解决问题2: 循环引用正常4). 面试加强版本2(优化遍历性能) 数组: while | for | forEach() 优于 for-in | keys()&amp;forEach() 对象: for-in 与 keys()&amp;forEach() 差不多*/const obj = &#123; a: &#123; &#125;, b: [], fn: function ()&#123;&#125;&#125;obj.a.c = obj.bobj.b[0] = obj.a/* 1). 大众乞丐版 问题1: 函数属性会丢失 问题2: 循环引用会出错*/export function deepClone1(target) &#123; return JSON.parse(JSON.stringify(target))&#125;/* 获取数据的类型字符串名*/function getType(data) &#123; return Object.prototype.toString.call(data).slice(8, -1) // -1代表最后一位 // [object Array] ===&gt; Array [object Object] ==&gt; Object&#125;/*2). 面试基础版本 解决问题1: 函数属性还没丢失*/function deepClone2(target) &#123; const type = getType(target) if (type===&#x27;Object&#x27; || type===&#x27;Array&#x27;) &#123; const cloneTarget = type === &#x27;Array&#x27; ? [] : &#123;&#125; for (const key in target) &#123; if (target.hasOwnProperty(key)) &#123; cloneTarget[key] = deepClone2(target[key]) &#125; &#125; return cloneTarget &#125; else &#123; return target &#125;&#125;/* 3). 面试加强版本 解决问题2: 循环引用正常*/function deepClone3(target, map = new Map()) &#123; const type = getType(target) if (type===&#x27;Object&#x27; || type===&#x27;Array&#x27;) &#123; // 从map容器取对应的clone对象 let cloneTarget = map.get(target) // 如果有, 直接返回这个clone对象 if (cloneTarget) &#123; return cloneTarget &#125; cloneTarget = type===&#x27;Array&#x27; ? [] : &#123;&#125; // 将clone产生的对象保存到map容器 map.set(target, cloneTarget) for (const key in target) &#123; if (target.hasOwnProperty(key)) &#123; cloneTarget[key] = deepClone3(target[key], map) &#125; &#125; return cloneTarget &#125; else &#123; return target &#125;&#125;/* 4). 面试加强版本2(优化遍历性能) 数组: while | for | forEach() 优于 for-in | keys()&amp;forEach() 对象: for-in 与 keys()&amp;forEach() 差不多*/function deepClone4(target, map = new Map()) &#123; const type = getType(target) if (type===&#x27;Object&#x27; || type===&#x27;Array&#x27;) &#123; let cloneTarget = map.get(target) if (cloneTarget) &#123; return cloneTarget &#125; if (type===&#x27;Array&#x27;) &#123; cloneTarget = [] map.set(target, cloneTarget) target.forEach((item, index) =&gt; &#123; cloneTarget[index] = deepClone4(item, map) &#125;) &#125; else &#123; cloneTarget = &#123;&#125; map.set(target, cloneTarget) Object.keys(target).forEach(key =&gt; &#123; cloneTarget[key] = deepClone4(target[key], map) &#125;) &#125; return cloneTarget &#125; else &#123; return target &#125;&#125; 自定义new和instanceof工具函数12345678910111213141516171819202122232425262728293031323334353637383940414243/* 自定义new工具函数 语法: newInstance(Fn, ...args) 功能: 创建Fn构造函数的实例对象 实现: 创建空对象obj, 调用Fn指定this为obj, 返回obj*/function newInstance(Fn, ...args) &#123; // 创建一个新的对象 const obj = &#123;&#125; // 执行构造函数 const result = Fn.apply(obj, args) // 相当于: obj.Fn() // 如果构造函数执行的结果是对象, 返回这个对象 if (result instanceof Object) &#123; return result &#125; // 如果不是, 返回新创建的对象 obj.__proto__.constructor = Fn // 让原型对象的构造器属性指向Fn return obj&#125;/* 自定义instanceof工具函数: 语法: myInstanceOf(obj, Type) 功能: 判断obj是否是Type类型的实例 实现: Type的原型对象是否是obj的原型链上的某个对象, 如果是返回true, 否则返回false*/function myInstanceOf(obj, Type) &#123; // 得到原型对象 let protoObj = obj.__proto__ // 只要原型对象存在 while(protoObj) &#123; // 如果原型对象是Type的原型对象, 返回true if (protoObj === Type.prototype) &#123; return true &#125; // 指定原型对象的原型对象 protoObj = protoObj.__proto__ &#125; return false&#125; 字符串处理12345678910111213141516171819202122232425262728/* 1. 字符串倒序: reverseString(str) 生成一个倒序的字符串2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束*//* 1. 字符串倒序: reverseString(str) 生成一个倒序的字符串*/function reverseString(str) &#123; // return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) // return [...str].reverse().join(&#x27;&#x27;) return Array.from(str).reverse().join(&#x27;&#x27;)&#125;/* 2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false*/function palindrome(str) &#123; return str === reverseString(str)&#125;/* 3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束*/function truncate(str, num) &#123; return str.length &gt; num ? str.slice(0, num) + &#x27;...&#x27; : str&#125; 简单排序: 冒泡 / 选择 / 插入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* 冒泡排序的方法*/function bubbleSort (array) &#123; // 1.获取数组的长度 var length = array.length; // 2.反向循环, 因此次数越来越少 for (var i = length - 1; i &gt;= 0; i--) &#123; // 3.根据i的次数, 比较循环到i位置 for (var j = 0; j &lt; i; j++) &#123; // 4.如果j位置比j+1位置的数据大, 那么就交换 if (array[j] &gt; array[j + 1]) &#123; // 交换 // const temp = array[j+1] // array[j+1] = array[j] // array[j] = temp [array[j + 1], array[j]] = [array[j], array[j + 1]]; &#125; &#125; &#125; return arr;&#125;/* 选择排序的方法*/function selectSort (array) &#123; // 1.获取数组的长度 var length = array.length // 2.外层循环: 从0位置开始取出数据, 直到length-2位置 for (var i = 0; i &lt; length - 1; i++) &#123; // 3.内层循环: 从i+1位置开始, 和后面的内容比较 var min = i for (var j = min + 1; j &lt; length; j++) &#123; // 4.如果i位置的数据大于j位置的数据, 记录最小的位置 if (array[min] &gt; array[j]) &#123; min = j &#125; &#125; if (min !== i) &#123; // 交换 [array[min], array[i]] = [array[i], array[min]]; &#125; &#125; return arr;&#125;/* 插入排序的方法*/function insertSort (array) &#123; // 1.获取数组的长度 var length = array.length // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后 for (var i = 1; i &lt; length; i++) &#123; // 3.记录选出的元素, 放在变量temp中 var j = i var temp = array[i] // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环 while (j &gt; 0 &amp;&amp; array[j - 1] &gt; temp) &#123; array[j] = array[j - 1] j-- &#125; // 5.将选出的j位置, 放入temp元素 array[j] = temp &#125; return array&#125;"},{"title":"002.从零开始复习前端--CSS","path":"2025/05/12/002.从零开始复习前端--CSS/","text":"002.从零开始复习前端–CSS 学习没有动力就可以看看招聘网站上面的薪资，可以对比其他的工作环境 CSS MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/CSS w3school文档：https://www.w3school.com.cn/css/index.asp w3school手册：https://www.w3school.com.cn/cssref/index.asp CSS的内容非常多，只能靠慢慢积累 语法 选择器CSS 选择器分为五类： 简单选择器（根据名称、id、类来选取元素） 组合器选择器（根据它们之间的特定关系来选取元素） 伪类选择器（根据特定状态选取元素） 伪元素选择器（选取元素的一部分并设置其样式） 属性选择器（根据属性或属性值来选取元素） 选择器的权重问题 权重：听谁，多个选择器可以叠加 选择器 权重 权重的等级 ！important 无穷大 0 style 属性 1,0,0,0 1 id 选择器 0,1,0,0 2 类、伪类、结构伪类、属性选择器 0,0,1,0 3 标签、伪元素选择器 0,0,0,1 4 通配符选择器 0,0,0,0 5 继承的样式 没有权重 6 属性选择器 用的少，一般只针对特殊场景有奇效 [attr*=val]：属性包含某一个val值 [attr^=val]：属性以某一个val开头 [attr$=val]：属性以某一个val结尾 [attr|=val]：属性等于val或val开头并且紧跟连接符- [attr~=val]：属性包含val，如果有其他值必须以空格与val分割 BFC 可以解决高度坍塌，外边距重叠，自适应布局 https://fanyouf.gitee.io/interview/css/02.html#%E7%AE%80%E7%89%88 HTML 根元素 position 为 absolute 或 fixed float 属性不为 none（常用） overflow 不为 visible（常用） display 为 inline-block， table-cell， table-caption， flex（常用) 绝对定位的高度坍塌不行，得使用js 媒体查询 可以根据不同的设备或宽度大小等特性来修改样式 三大使用方法 通过@media和@import使用不同的css规则 1@import url(./css/index.css) (max-width:800px) 在link、style等标签中使用media属性指定媒体查询 1&lt;link res=&quot;stylesheet&quot; media=&quot;(max-width:800px)&quot; href=&quot;./css/index.css&quot;&gt; 使用@media 12345@media (max-width:800px)&#123; div&#123; color:red; &#125;&#125; 媒体类型 值 描述 all 用于所有媒体类型设备。 print 用于打印机。 screen 用于计算机屏幕、平板电脑、智能手机等等。 speech 用于大声“读出”页面的屏幕阅读器。 媒体特性 值 描述 width 可加max min前缀 height 可加max min前缀 device-width 可加max min前缀 orientation portrait竖屏/landscape横屏 更多规则：https://www.w3school.com.cn/cssref/pr_mediaquery.asp em/rem em：相对自身的字体大小，如果对自身字体大小设置，则相对父元素大小 rem：相对根元素（html）大小 移动端适配1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;&gt; 值 可能的附加值 描述 width 正整数或字符串device-width 定义viewport的宽度 height 正整数或字符串device-height 定义viewport的高度。未被任何浏览器使用 initial-scale 0.0-10.0之间 设备与viewport的缩放比例 maximum-scale 0.0-10.0之间 定义缩放的最大值必须大于等于maximum-scale，否则表现不可预测 minimum-scale 0.0-10.0之间 定义缩放的最大值必须大于等于minimum-scale，否则表现不可预测 user-scalable yes或no 是否允许缩放，默认yes。部分浏览器忽视这个规则 移动端通常使用媒体查询或者rem，也可能使用uniapp来做 重点 flex布局：https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html grid布局：https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html grid视频教程：https://www.bilibili.com/video/BV1w84y1r7X8/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=b307bf90a5b243266e19ff3e3d323e66 样式穿透 样式穿透 1. &gt;&gt;&gt;适用与 css、stylus，不太推荐，可能会有问题外层类 &gt;&gt;&gt; 想要修改类名 {修改样式} 2. /deep/适用于 scss、less外层类 /deep/ 想要修改类名 {修改样式} 3. ::v-deep通用，据说可以加快编译速度::deep 想要修改类名 {修改样式} css函数 css函数 var(–name,value)：全局变量 name前缀必须是– value是默认值，如果没有找到name时使用 示例： 123456:root&#123; --blue: #1e90ff&#125;div&#123; color: var(--blue)&#125; calc()：css四则运算 示例： 123div&#123; width: calc(100% - 80px);&#125; class命名 参考单词 header页眉 body页身 footer页脚container集装箱 aside侧边栏 main主体 submain副主体left左侧 center中间 right右侧top上部 middle中部 bottom底部group 分组 row行 col列 list组max 最大 plus超大 medium中等 small小 mini极小primary 主要的 success成功的 warning警告的 danger危险的 default默认的info信息 text文本 link链接 tips小贴条active活跃的 disabled禁用的 readonly只读的 highlight高亮的height高 width宽 weight粗 更多查看：https://guide.aotu.io/index.html 属性书写顺序建议遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … 更多代码规范查看：https://guide.aotu.io/index.html"},{"title":"003.从零开始复习前端--Less","path":"2025/05/12/003.从零开始复习前端--Less/","text":"003.从零开始复习前端–Less 学习没有动力就可以看看招聘网站上面的薪资，可以对比其他的工作环境 Less css预处理器 中文文档：https://less.bootcss.com/ 浏览器环境中使用 原生 12&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/less@4&quot; &gt;&lt;/script&gt; 在vue中使用 npm/yarn 1npm install --save less less-loader 在main.js中引入 12import less from &#x27;less&#x27;Vue.use(less) 或者在webpack.base.config.js中配置 12345678910111213141516171819const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, devServer: &#123; open: true, host: &#x27;localhost&#x27;, port: 8080 &#125;, module: &#123; rules: [ // less配置 &#123; test: /\\.less$/, loader: &quot;style-loader!css-loader!less-loader&quot;, options: &#123; sourceMap: true &#125; &#125; ] &#125;&#125;) 基本使用变量1234567@width: 10px;@height: @width + 10px;#header &#123; width: @width; height: @height;&#125; 嵌套123456789#header &#123; color: black;&#125;#header .navigation &#123; font-size: 12px;&#125;#header .logo &#123; width: 300px;&#125; 运算 不推荐使用，less运算有的只认第一个单位 123@conversion-1: 5cm + 10mm; // 结果是 6cm@conversion-2: 2 - 3cm - 5mm; // 结果是 -1.5cm@base: 2cm * 3mm; // 结果是 6cm 混入12345678910111213141516171819202122232425262728293031323334353637383940414243444546基本使用.bordered &#123; border-top: dotted 1px black; border-bottom: solid 2px black;&#125;#menu a &#123; color: #111; .bordered();&#125;.post a &#123; color: red; .bordered();&#125;携带参数.bordered (@color:#fff)&#123; // @color:#fff默认值 border-top: dotted 1px black; border-bottom: solid 2px black; color:@color;&#125;#menu a &#123; color: #111; .bordered(#999);&#125;.post a &#123; color: red; .bordered();&#125;结合映射.bordered ()&#123; border-top: dotted 1px black; border-bottom: solid 2px black; color:#fff;&#125;#menu a &#123; color: .bordered()[color]; // color: .bordered[color]; // 缩写，但是不方便阅读看个人或团队&#125;.post a &#123; color: red; .bordered();&#125; 引入12@import &quot;library&quot;; // library.less@import &quot;typo.css&quot;; 其他内容查看文档：https://less.bootcss.com/ Sass/Scss 与less类似，使用基本是一样的 文档：https://www.sass.hk/"},{"title":"001.从零开始复习前端--HTML","path":"2025/05/12/001.从零开始复习前端--HTML/","text":"001.从零开始复习前端–HTML 学习没有动力就可以看看招聘网站上面的薪资，可以对比其他的工作环境 安装VScode 搜索VScode官网下载，免费的但是它是外网会可能会很慢，也可以选择国内的第三方下载（不建议可能有广告） 安装插件 转成中文：Chinese (Simplified) (简体中文) Language Pack for Visual Studio Cod 不需要刷新就能更新：Live Server 自动修改结束标签：Auto Rename Tag 修改默认配置 自动保存：在VScode左上角点击文件打开自动保存 修改字体大小：在设置里面找到Font Size 自动换行：在设置里面找到Word Wrap 展示空格：在设置里面找到Render Whitespace 跳转tab缩进：在设置里面找到Tab Size Tab向后缩进、shift+Tab向前缩进 HTML MDN链接：https://developer.mozilla.org/zh-CN/docs/Web/HTML w3school：https://www.w3school.com.cn/html/index.asp 元素的主要部分有： 开始标签（Opening tag）：包含元素的名称（本例为 p），被大于号、小于号所包围。表示元素从这里开始或者开始起作用 —— 在本例中即段落由此开始。 结束标签（Closing tag）：与开始标签相似，只是其在元素名之前包含了一个斜杠。这表示着元素的结尾 —— 在本例中即段落在此结束。初学者常常会犯忘记包含结束标签的错误，这可能会产生一些奇怪的结果。 内容（Content）：元素的内容，本例中就是所输入的文本本身。 元素（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素。 属性应该包含： 在属性与元素名称（或上一个属性，如果有超过一个属性的话）之间的空格符。 属性的名称，并接上一个等号。 由引号所包围的属性值。 空元素 不包含任何内容的元素称为空元素。比如 img 元素 h(1-6)标签 h标签和seo优化有关 合理的使用是可能提高网站的权重的、提高网站在搜索引擎的排名 img标签 alt属性 都知道图片加载失败显示文字要使用alt，但是不要忽略使用阅读器时也会描述alt的内容 title鼠标悬停显示文字 可能会遇到图片403问题 用 &lt;a&gt;、&lt;area&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;script&gt; 或者 &lt;link&gt; 元素上的 referrerpolicy 属性为其设置独立的请求策略，例如： 1&lt;img src=&quot;http://……&quot; referrerPolicy=&quot;no-referrer&quot;&gt; 或者直接在HTMl 页面头中通过meta 属性全局配置： 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; a标签 target _self：当前页面加载 _blank：新窗口打开 _parent：父级页面打开，没有父级页面和_self效果相同（iframe嵌套） _top：顶级页面打开，没有父级页面和_self效果相同（iframe嵌套多级） href 指定地址 锚点 下载文件（xxx.zip） mailto:&#x37;&#54;&#x36;&#x31;&#56;&#55;&#51;&#57;&#55;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;（协议地址） iframe标签 用于嵌入其他页面 全局属性 不仅仅属于某一个或多个标签的属性 class：设置样式类名 data-*：自定义数据属性 HTMLElement.dataset获取 该名称不能以xml开头，无论这些字母是大写还是小写； 该名称不能包含任何分号 (U+003A)； 该名称不能包含 A 至 Z 的大写字母。 id：唯一标识 lang：语义化定义 style：样式 title：鼠标悬浮的名称 行元素块元素行内元素: 就是在web页面布局时可以与其他元素一块共享一行的元素 块元素： 就是每一个元素,占有一行,即使自己的内容不够多也不让其他元素侵犯自己的底盘"}]